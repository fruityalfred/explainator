<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Explainator - Ultimate Edition</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            padding: 10px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 100%;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
        }
        
        h2 {
            text-align: center;
            margin-bottom: 20px;
            font-size: 28px;
            color: #2c3e50;
            font-weight: 600;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            align-items: center;
        }
        
        .btn {
            padding: 10px 18px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-success {
            background: linear-gradient(135deg, #84fab0 0%, #8fd3f4 100%);
            color: #1a1a1a;
        }
        
        .btn-warning {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
            color: #1a1a1a;
        }
        
        .btn-danger {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }
        
        .btn-info {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }
        
        .btn-secondary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .main-container {
            display: flex;
            gap: 10px;
            overflow-x: auto;
            padding-bottom: 20px;
            /* min-height: 600px; */ /* <-- Auskommentiert oder gel√∂scht */
        }
        
        .column {
            min-width: 200px;
            max-width: none; /* remove width cap */
            width: 400px; /* default width */
            background: white;
            border: 2px solid #8B4513;
            border-radius: 8px;
            position: relative;
            display: flex;
            flex-direction: column;
            transition: all 0.3s;
        }
        
        /* Split column layout */
        /* legacy split classes no longer used; kept for compatibility */
        /* .column.split-column, .column.split-column-3 { } */
        
        .column-split-content {
            display: flex;
                        gap: 10px;            /* horizontal gap between parts */
            flex: 0 0 auto;       /* do not grow; columns independent */
            padding: 0;      /* match .column-content horizontal padding */
            position: relative;
            margin: 0;            /* rely on parent gap for vertical spacing */
        }

        .column-part {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px; /* match vertical spacing with normal sections */
            border-right: 1px solid #e0e0e0;
            padding-right: 10px;
            margin-top: 0;
        }
        .column-part:last-child { border-right: none; padding-right: 0; padding-left: 0px; }
        
        /* removed legacy .column-half/.column-third; using .column-part only */
        
        .column:hover {
            box-shadow: 0 5px 20px rgba(139,69,19,0.2);
        }

        /* Do not cover bottom borders of sections; mask only the vertical divider ends */
        .column-split-content::after { display: none; }

        .column-part { position: relative; }
        .column-part::after {
            content: '';
            position: absolute;
            right: -1px; bottom: 0;
            width: 2px; height: 10px; /* hide last 10px of divider only */
            background: #fff; pointer-events: none;
        }
        .column-part:last-child::after { display: none; }
        
        .column-header {
            background: linear-gradient(to bottom, #8B4513, #A0522D);
            color: white;
            padding: 12px;
            text-align: center;
            font-weight: bold;
            font-size: 14px;
            border-radius: 6px 6px 0 0;
            position: relative;
            cursor: move;
            /* Reserve space for left counter to keep title visually centered */
            --header-left-pad: 80px;
            padding-left: var(--header-left-pad);
            padding-right: 96px; /* space for color + delete */
        }
        
        .column-header .delete-column {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.3s;
        }
        

        .split-counter {
            position: absolute;
            left: 0;
            right: auto;
            top: 50%;
            transform: translateY(-50%);
            display: inline-flex;
            align-items: center;
            gap: 4px;
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            border-radius: 12px;
            padding: 2px 6px;
            user-select: none;
            z-index: 1;
        }
        .split-counter button {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.4);
            background: rgba(255,255,255,0.25);
            color: white;
            cursor: pointer;
            line-height: 18px;
            font-weight: 700;
        }
        .split-counter .value { min-width: 16px; text-align: center; font-weight: 700; }
        
        .section-delete {
            position: absolute;
            right: 35px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255,0,0,0.7);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            transition: all 0.3s;
        }
        
        .section-delete:hover {
            background: rgba(255,0,0,0.9);
            transform: translateY(-50%) scale(1.1);
        }
        
        .column-header .delete-column:hover {
            background: rgba(255,0,0,0.5);
        }
        
        .resize-handle {
            position: absolute;
            right: -6px;
            top: 0;
            bottom: 0;
            width: 12px;
            cursor: ew-resize;
            background: transparent;
        }
        
        .resize-handle:hover {
            background: rgba(139,69,19,0.2);
        }
        
        .column-content {
            padding: 12px;
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 8px; /* slightly tighter vertical spacing */
        }
        
        .section-group {
            border: 2px dashed #999;
            border-radius: 6px;
            padding: 10px;
            min-height: 80px;
            transition: all 0.3s;
            position: relative;
            cursor: move;
        }
        
        .section-group.drag-over {
            background: #e8f5e9;
            border-color: #4CAF50;
            border-style: solid;
        }
        
        .column-content.drag-over {
            background: rgba(76, 175, 80, 0.1);
            border: 2px dashed #4CAF50;
            border-radius: 8px;
        }
        
        .section-group.dragging {
            opacity: 0.7;
            transform: rotate(2deg);
            z-index: 1000;
        }
        
        .section-title {
            background: #8B4513;
            color: white;
            padding: 6px 12px;
            text-align: center;
            font-size: 12px;
            font-weight: bold;
            border-radius: 4px;
            margin-bottom: 10px;
            position: relative;
            cursor: pointer;
        }
        
        .section-title input {
            background: transparent;
            border: none;
            color: white;
            text-align: center;
            font-size: 12px;
            font-weight: bold;
            width: 100%;
        }
        
        .section-title .section-menu {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            cursor: pointer;
        }
        
        .section-title .section-menu:hover {
            background: rgba(255,255,255,0.4);
        }
        
        .add-section-btn {
            width: 100%;
            padding: 4px 8px;
            border: 2px dashed #ccc;
            background: #f9f9f9;
            color: #666;
            cursor: pointer;
            border-radius: 4px;
            text-align: center;
            transition: all 0.3s;
            font-size: 10px;
        }
        
        .add-section-btn:hover {
            background: #e8f5e9;
            border-color: #4CAF50;
            color: #2e7d32;
        }
        
        .box-container {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            min-height: 30px;
        }
        
        .app-box {
            padding: 8px 12px;
            text-align: center;
            font-size: 11px;
            border-radius: 4px;
            border: 1px solid #ccc;
            cursor: move;
            position: relative;
            min-height: 30px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            flex: 0 0 auto;
            max-width: 100%;
            word-break: break-word;
        }
        
        .app-box.half-width {
            flex: 0 0 calc(50% - 3px);
        }
        
        .app-box.full-width {
            flex: 0 0 100%;
        }
        
        .app-box:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            z-index: 10;
        }
        
        .app-box.dragging {
            opacity: 0.5;
        }

        /* Column dragging visual effect */
        .column.dragging {
            opacity: 0.7;
            transform: rotate(2deg);
            box-shadow: 0 12px 28px rgba(0,0,0,0.25);
            z-index: 1000;
        }
        
        .app-box .delete-btn {
            position: absolute;
            top: -8px;
            right: -8px;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
        
        .app-box:hover .delete-btn {
            display: flex;
        }
        
        .app-box .resize-btn {
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 10px;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
        }
        
        .app-box:hover .resize-btn {
            display: flex;
        }
        
        /* Add Column Button */
        .add-column {
            min-width: 60px;
            background: #f0f0f0;
            border: 2px dashed #999;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
            padding: 20px;
        }
        
        .add-column:hover {
            background: #e8f5e9;
            border-color: #4CAF50;
        }
        
        .add-column span {
            font-size: 32px;
            color: #666;
        }
        
        /* Grid lines for better alignment */
        .grid-lines .section-group {
            border-bottom: 1px dashed #ccc;
            margin-bottom: 5px;
            padding-bottom: 5px;
        }
        
        .grid-lines .section-group:last-of-type {
            border-bottom: none;
        }
        
        /* removed grid-lines styling for legacy halves/thirds */
        
        .grid-lines .column-split-content {
            border-top: 1px dashed #ccc;
        }
        
        .grid-lines .column-content {
            position: relative;
        }
        
        .grid-lines .column-content::before {
            content: '';
            position: absolute;
            top: 0;
            bottom: 0;
            left: 50%;
            border-left: 1px dashed #eee;
            pointer-events: none;
            z-index: 1;
        }
        
        /* Legend */
        .legend {
            display: flex;
            gap: 20px;
            justify-content: flex-start;
            padding: 15px;
            background: #f9f9f9;
            border-radius: 8px;
            flex-wrap: wrap;
            margin-top: 20px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            padding: 5px 10px;
            border-radius: 4px;
            transition: all 0.3s;
        }
        
        .legend-item:hover {
            background: white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .legend-box {
            width: 30px;
            height: 20px;
            border-radius: 4px;
        }
        
        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        
        .modal.show {
            display: flex;
        }
        
        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 12px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        .modal-header {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 20px;
            color: #2c3e50;
        }
        
        .modal-body {
            margin-bottom: 20px;
        }
        
        .modal-body input, .modal-body select {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            margin-bottom: 10px;
        }
        
        .modal-footer {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        
        .category-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            border: 1px solid #ddd;
            margin-bottom: 10px;
            border-radius: 6px;
            background: #f9f9f9;
        }
        
        .category-preview {
            width: 40px;
            height: 30px;
            border-radius: 4px;
            flex-shrink: 0;
        }
        
        .category-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            flex: 1;
        }
        
        .category-controls input[type="text"] {
            flex: 1;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .category-controls input[type="color"] {
            width: 40px;
            height: 30px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .color-input-group {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .placeholder {
            background: #e8f5e9;
            border: 2px dashed #4CAF50;
            min-height: 30px;
        }
        
        .info-panel {
            background: #fffbf0;
            border: 2px solid #ffc107;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 15px;
            font-size: 13px;
        }
        
        .info-panel strong {
            color: #f57c00;
        }
        
        .small-btn {
            padding: 5px 10px;
            font-size: 12px;
        }
        
        .template-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 15px;
            margin-bottom: 10px;
            background: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .template-item:hover {
            background: #e8f5e9;
            border-color: #4CAF50;
        }
        
        .template-info {
            flex: 1;
        }
        
        .template-name {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .template-date {
            font-size: 12px;
            color: #666;
        }
        
        .template-actions {
            display: flex;
            gap: 10px;
        }
        
        #exportCanvas {
            position: fixed;
            top: -10000px;
            left: -10000px;
            pointer-events: none;
        }
        
        .section-color-picker {
            position: absolute;
            top: 25px;
            right: 0;
            background: white;
            border: 2px solid #ddd;
            border-radius: 6px;
            padding: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1000;
            display: none;
            min-width: 240px;
            max-width: 520px;
        }
        
        .section-color-picker.show { display: flex; flex-wrap: wrap; gap: 8px; }
        .section-color-picker .swatch { width: 22px; height: 22px; border-radius: 4px; border: 1px solid #bbb; cursor: pointer; }
        .section-color-picker .swatch:hover, .column-color-picker .swatch:hover { outline: 2px solid #888; }
    </style>

<style>
.column, .column-header { overflow: visible !important; }
.column-header .header-btn { position:absolute; top:50%; transform:translateY(-50%); background:rgba(255,255,255,0.15); border:1px solid rgba(255,255,255,0.3); color:#fff; width:24px; height:24px; border-radius:50%; cursor:pointer; display:flex; align-items:center; justify-content:center; font-size:12px; }
.column-header .delete-column { right:10px; font-size:16px; }
.column-header .color-column-btn { right:40px; }
.column-header .insert-split-btn { right:70px; }
.column-color-picker { z-index:30000; position:absolute; top:110%; right:0; background:#fff; border:2px solid #ddd; border-radius:6px; padding:10px; box-shadow:0 4px 12px rgba(0,0,0,0.15); z-index:12000; display:none; min-width:240px; max-width:520px; }
.column-color-picker.show{ display:flex; flex-wrap: wrap; gap:8px; }
.column-color-picker .row{ display:flex; align-items:center; gap:8px; margin:0; width: calc(33.333% - 8px); }
.column-color-picker .row:last-child{ width:100%; margin-top:8px; }
.column-color-picker .swatch{ width:22px; height:22px; border-radius:4px; border:1px solid #bbb; cursor:pointer; }
.column-color-picker .swatch{ width:30px; height:20px; border-radius:4px; border:1px solid #ccc; cursor:pointer; }
</style>

<style>.column-header{position:relative}</style>

<style>
/* Hide picker icon during screenshots/exports */
.screenshot-mode .color-column-btn,
[data-screenshot="true"] .color-column-btn,
.exporting .color-column-btn { display: none !important; }
</style>

<style>
    /* Visuelles Feedback f√ºr das Ziehen von Elementen */
    .dragging-placeholder {
        background: rgba(0, 128, 0, 0.1);
        border: 2px dashed #4CAF50;
        border-radius: 6px;
        margin: 4px 0;
    }
    /* Visual cue when Alt enables full-width drop for split-origin sections */
    .dragging-placeholder.full-width-mode {
        background: rgba(33, 150, 243, 0.10);
        border-color: #2196F3;
    }
    .dragging {
        opacity: 0.5;
        transform: rotate(2deg);
    }
</style>

<style>
/* Original w√§hrend Ctrl-Klon nicht dimmen */
.app-box[data-no-dim="1"],
.app-box[data-no-dim="1"].dragging {
  opacity: 1 !important;
  filter: none !important;
}
</style>

<style>
    /* Styling f√ºr das Bearbeitungs-Eingabefeld in einer App-Box */
    .app-box-editor {
        width: 100%;
        height: 100%;
        border: none;
        background-color: rgba(255, 255, 255, 0.8);
        font-family: inherit;
        font-size: inherit;
        text-align: center;
        padding: 2px;
        box-sizing: border-box;
    }
    .app-box-editor:focus {
        outline: 2px solid #007bff;
        box-shadow: 0 0 5px rgba(0,123,255,0.5);
    }
</style>

<style>
.column-color-picker { max-width: 260px; }
.header-btn.color-column-btn { user-select: none; }
.column-header { overflow: visible; }
</style>

<style>
/* Image boxes */
.app-box.image-box {
    padding: 6px;
    border: 1px solid #ccc;
    background: #fff;
}
.app-box.image-box img {
    display: block;
    max-width: 100%; /* constrain but do not upscale */
    width: auto;      /* keep intrinsic width to avoid stretching */
    height: auto;
    max-height: 270px; /* 3 x (3 lines) ~ 270px */
    object-fit: contain;
    margin: 0 auto;   /* center if narrower than container */
    border-radius: 4px;
}

/* Modal dropzone for images */
.image-dropzone {
    width: 100%;
    min-height: 80px;
    border: 2px dashed #999;
    border-radius: 6px;
    background: #f9f9f9;
    color: #666;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
    padding: 10px;
    user-select: none;
}
.image-dropzone.dragover { border-color: #4CAF50; background: #e8f5e9; color: #2e7d32; }
.image-preview img { max-width: 100%; height: auto; max-height: 200px; display: block; border-radius: 4px; }
</style>

</head>
<body>
    <div class="container">
        <h2 data-translate="mainTitle">üè¢ Explainator - Ultimate Edition</h2>
        
        <div class="controls">
                        <button class="btn btn-primary" onclick="showLayoutBuilder()">Layout Builder</button>
<button class="btn btn-secondary" onclick="showFormattingModal()" data-translate="formatting">üî† Formatierung</button>
            <button class="btn btn-primary" onclick="addNewColumn()" data-translate="addColumn">‚ûï Neue Spalte</button>
            <button class="btn btn-success" onclick="showAddBoxModal()" data-translate="addBox">üì¶ Neue Box</button>
            <button class="btn btn-info" onclick="showCategoryModal()" data-translate="manageCategories">üé® Kategorien verwalten</button>
            <button class="btn btn-warning" onclick="exportToPNG()" data-translate="exportPNG">üì∏ Als PNG exportieren</button>
            <button class="btn btn-secondary" id="gridToggleBtn" onclick="toggleGridLines()" data-translate="gridLines">‚äû Hilfslinien</button>
            <button class="btn btn-info" onclick="saveTemplate()" data-translate="saveTemplate">üíæ Template speichern</button>
            <button class="btn btn-success" onclick="showLoadTemplateModal()" data-translate="loadTemplate">üìÇ Template laden</button>
            <button class="btn btn-warning" onclick="resetLayout()" data-translate="resetLayout">üîÑ Layout zur√ºcksetzen</button>
            <button class="btn btn-danger" onclick="clearAll()" data-translate="clearAll">üóëÔ∏è Alles l√∂schen</button>
            <button id="langSwitchBtn" class="btn btn-info" onclick="toggleLanguage()">EN</button>
        </div>
        
        <div class="main-container" id="mainContainer">
            </div>
        
        <div class="legend" id="legend">
            </div>
    </div>
        
    <div class="modal" id="addBoxModal">
        <div class="modal-content">
            <div class="modal-header" data-translate="addBoxModalTitle">Neue Box hinzuf√ºgen</div>
            <div class="modal-body">
                <input type="text" id="boxName" placeholder="Box Name" data-translate="boxNamePlaceholder">
                <select id="boxType"></select>
                <select id="boxWidth">
                    <option value="full-width" data-translate="fullWidth">Volle Breite</option>
                    <option value="half-width" data-translate="halfWidth">Halbe Breite</option>
                </select>
                <label for="boxLines" id="boxLinesLabel" style="display:block;margin-top:8px;" data-translate="boxHeightLabel">H√∂he (Zeilen)</label>
                <select id="boxLines">
                    <option value="1" selected data-translate="boxHeight1">1 Zeile (Standard)</option>
                    <option value="2" data-translate="boxHeight2">2 Zeilen</option>
                    <option value="3" data-translate="boxHeight3">3 Zeilen</option>
                </select>
                
                <div id="textOptions" style="display: flex; gap: 20px; margin-top: 15px; align-items: center;">
                    <label><span data-translate="textColorLabel">Text:</span> <input type="color" id="boxTextColor" value="#000000"></label>
                </div>

                <hr style="margin:14px 0;">
                <label style="display:flex; align-items:center; gap:8px; cursor:pointer;">
                    <input type="checkbox" id="boxIsImage" />
                    <span data-translate="imageMode">Bild statt Text</span>
                </label>
                
                <div id="imageOptions" style="display:none; margin-top:10px;">
                    <div id="imageDropzone" class="image-dropzone" data-translate="imageSelectOrDrop" title="JPG oder PNG">
                        Bild ausw√§hlen oder hierher ziehen (JPG/PNG)
                    </div>
                    <input type="file" id="boxImageFile" accept="image/png, image/jpeg" style="margin-top:8px; width:100%;" />
                    <div id="imagePreview" class="image-preview" style="margin-top:8px; display:none;"></div>
                    <div style="font-size:12px; color:#666; margin-top:6px;" data-translate="imageMaxHeightHint">Maximale H√∂he: 3 √ó 3‚ÄëZeilen Boxen</div>
                </div>

            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" onclick="addBoxNew()" data-translate="add">Hinzuf√ºgen</button>
                <button class="btn btn-danger" onclick="closeModal('addBoxModal')" data-translate="cancel">Abbrechen</button>
            </div>
        </div>
    </div>

    <!-- Layout Builder Modal -->
    <div class="modal" id="layoutBuilderModal">
        <div class="modal-content">
            <div class="modal-header">Layout Builder</div>
            <div class="modal-body">
                <div style="display:flex; gap:12px; align-items:center; margin-bottom:12px;">
                    <label>Spalten:</label>
                    <input type="number" id="lbColumns" min="1" max="8" value="2" style="width:80px;">
                    <button class="btn btn-secondary" onclick="renderLayoutBuilderGrid()">Aktualisieren</button>
                </div>
                <div id="lbGrid" style="display:flex; flex-direction:column; gap:8px;"></div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" onclick="applyLayoutBuilder()">Erstellen</button>
                <button class="btn btn-danger" onclick="closeModal('layoutBuilderModal')">Abbrechen</button>
            </div>
        </div>
    </div>
    
    <div class="modal" id="categoryModal">
        <div class="modal-content">
            <div class="modal-header" data-translate="manageCategories">üé® Kategorien verwalten</div>
            <div class="modal-body">
                <div style="margin-bottom: 30px; padding: 20px; background: #f0f8ff; border-radius: 8px;">
                    <h4 style="margin-bottom: 15px;" data-translate="addNewCategoryTitle">Neue Kategorie hinzuf√ºgen:</h4>
                    <input type="text" id="categoryName" placeholder="Kategorie Name (z.B. Cloud Services)">
                    <div class="color-input-group" id="catColorGroup">
                        <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px; flex-wrap:wrap;">
                            <label style="min-width: 60px;" data-translate="color1">Farbe:</label>
                            <input type="color" id="categoryColor1" value="#8B4513" style="flex:0 0 40px; border:none; padding:0;">
                            <button class="btn small-btn" type="button" onclick="pickEyeDropper('categoryColor1')">Pipette</button>
                            <label style="margin-left:16px; display:flex; align-items:center; gap:6px;">
                                <input type="checkbox" id="useGradient" onchange="toggleGradient()"> Verlauf verwenden
                            </label>
                        </div>
                        <div id="catSwatches1" style="display:flex; flex-wrap:wrap; gap:6px; margin-bottom:10px;"></div>
                        <div id="gradientRow" style="display:none; align-items:center; gap:8px; margin:6px 0 10px 0; flex-wrap:wrap;">
                            <label style="min-width: 60px;">Farbe 2:</label>
                            <input type="color" id="categoryColor2" value="#8B4513" style="flex:0 0 40px; border:none; padding:0;">
                            <button class="btn small-btn" type="button" onclick="pickEyeDropper('categoryColor2')">Pipette</button>
                        </div>
                        <div id="catSwatches2" style="display:none; flex-wrap:wrap; gap:6px; margin-bottom:10px;"></div>
                        <div id="colorPreview" style="width: 120px; height: 30px; border-radius: 4px; background: linear-gradient(135deg, #8B4513 0%, #8B4513 100%);"></div>
                    </div>
                    <button class="btn btn-success" onclick="addCategory()" data-translate="addCategory">‚ûï Kategorie hinzuf√ºgen</button>
                </div>
                
                <div>
                    <h4 style="margin-bottom: 15px;" data-translate="existingCategories">Vorhandene Kategorien:</h4>
                    <div id="categoryList">
                        </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" onclick="closeModal('categoryModal')" data-translate="done">Fertig</button>
            </div>
        </div>
    </div>
    
    <div class="modal" id="loadTemplateModal">
        <div class="modal-content">
            <div class="modal-header" data-translate="loadTemplate">üìÇ Template laden</div>
            <div class="modal-body">
                <div style="margin-bottom: 20px;">
                    <h4 style="margin-bottom: 10px;">Vorlagen:</h4>
                    <div id="builtinTemplateList" style="display:flex; gap:10px; flex-wrap:wrap; margin-bottom:10px;">
                        <button class="btn btn-secondary small-btn" onclick="loadBuiltinTemplate('organigram')">Organigramm</button>
                        <button class="btn btn-secondary small-btn" onclick="loadBuiltinTemplate('office')">Office Map</button>
                        <button class="btn btn-secondary small-btn" onclick="loadBuiltinTemplate('kanban')">Kanban</button>
                    </div>
                </div>
                <div style="margin-bottom: 20px;">
                    <h4 style="margin-bottom: 10px;" data-translate="savedTemplates">Gespeicherte Templates:</h4>
                    <div id="templateList" style="max-height: 300px; overflow-y: auto;">
                        </div>
                </div>
                
                <div style="border-top: 2px solid #eee; padding-top: 20px;">
                    <h4 style="margin-bottom: 10px;" data-translate="loadTemplateFromFileTitle">Template aus Datei laden:</h4>
                    <input type="file" id="templateFileInput" accept=".json" style="margin-bottom: 10px;">
                    <button class="btn btn-primary" onclick="loadTemplateFromFile()" data-translate="loadFile">üìÇ Datei laden</button>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-danger" onclick="closeModal('loadTemplateModal')" data-translate="close">Schlie√üen</button>
            </div>
        </div>
    </div>
    
    <canvas id="exportCanvas" style="position: fixed; top: -10000px; left: -10000px; pointer-events: none;"></canvas>
    
    <script>
        // === LANGUAGE SWITCHER & TRANSLATIONS ===
        let currentLanguage = 'de';

        const translations = {
            de: {
                mainTitle: "üè¢ Explainator - Ultimate Edition",
                infoPanelTitle: "Vollst√§ndige Kontrolle:",
                infoPanelFeatures: "‚úì Templates speichern & laden | ‚úì PNG Export | ‚úì Section-Farben anpassbar | ‚úì Sections innerhalb & zwischen Spalten verschiebbar | ‚úì Kategorien mit eigenen Farben verwalten | ‚úì Spalten verschieben & resize | ‚úì Drag & Drop √ºberall | ‚úì Stabile Section-Funktionalit√§t | ‚úì 3-Spalten Split m√∂glich",
                formatting: "üî† Formatierung",
                addColumn: "‚ûï Neue Spalte",
                addBox: "üì¶ Neue Box",
                manageCategories: "üé® Kategorien verwalten",
                exportPNG: "üì∏ Als PNG exportieren",
                gridLines: "‚äû Hilfslinien",
                gridLinesHide: "‚äû Hilfslinien aus",
                saveTemplate: "üíæ Template speichern",
                loadTemplate: "üìÇ Template laden",
                resetLayout: "üîÑ Layout zur√ºcksetzen",
                clearAll: "üóëÔ∏è Alles l√∂schen",
                addBoxModalTitle: "Neue Box hinzuf√ºgen",
                boxNamePlaceholder: "Box Name",
                newApplicationName: "Neue Anwendung",
                fullWidth: "Volle Breite",
                halfWidth: "Halbe Breite",
                boxHeightLabel: "H√∂he (Zeilen)",
                boxHeight1: "1 Zeile (Standard)",
                boxHeight2: "2 Zeilen",
                boxHeight3: "3 Zeilen",
                add: "Hinzuf√ºgen",
                cancel: "Abbrechen",
                textColorLabel: "Text:",
                imageMode: "Bild statt Text",
                imageSelectOrDrop: "Bild ausw√§hlen oder hierher ziehen (JPG/PNG)",
                imageMaxHeightHint: "Maximale H√∂he: 3 √ó 3‚ÄëZeilen Boxen",
                alertChooseImage: "Bitte ein Bild (JPG/PNG) ausw√§hlen oder hineinziehen.",
                addNewCategoryTitle: "Neue Kategorie hinzuf√ºgen:",
                categoryNamePlaceholder: "Kategorie Name (z.B. Cloud Services)",
                color1: "Farbe 1:",
                color2: "Farbe 2:",
                addCategory: "‚ûï Kategorie hinzuf√ºgen",
                existingCategories: "Vorhandene Kategorien:",
                delete: "L√∂schen",
                done: "Fertig",
                savedTemplates: "Gespeicherte Templates:",
                noSavedTemplates: "Keine gespeicherten Templates gefunden",
                loadTemplateFromFileTitle: "Template aus Datei laden:",
                loadFile: "üìÇ Datei laden",
                close: "Schlie√üen",
                legendTitle: "Kategorien:",
                newColumn: "Neue Spalte",
                newSection: "Neue Section",
                confirmDeleteColumn: "Spalte wirklich l√∂schen?",
                confirmDeleteSection: "Section wirklich l√∂schen?",
                confirmResetLayout: "Layout wirklich zur√ºcksetzen?",
                confirmClearAll: "Wirklich alles l√∂schen?",
                alertEnterName: "Bitte geben Sie einen Namen ein!",
                alertCategoryAdded: "Kategorie \"{name}\" wurde hinzugef√ºgt!",
                alertOneCategoryNeeded: "Mindestens eine Kategorie muss vorhanden sein!",
                confirmDeleteCategory: "Kategorie \"{name}\" wirklich l√∂schen?",
                promptTemplateName: "Template Name eingeben:",
                defaultTemplateName: "Mein Template",
                alertTemplateSaved: "Template \"{name}\" gespeichert und heruntergeladen!",
                alertTemplateNotFound: "Template nicht gefunden!",
                confirmLoadTemplate: "Template \"{name}\" laden? Das aktuelle Layout wird √ºberschrieben.",
                alertTemplateLoaded: "Template \"{name}\" erfolgreich geladen!",
                alertChooseFile: "Bitte w√§hlen Sie eine Datei aus!",
                confirmLoadFromFile: "Template \"{name}\" aus Datei laden? Das aktuelle Layout wird √ºberschrieben.",
                alertFileLoadError: "Fehler beim Laden der Template-Datei: ",
                alertFileLoaded: "Template \"{name}\" erfolgreich aus Datei geladen!",
                exporting: "üì∏ Exportiere...",
                alertExportSuccess: "‚úÖ Sauberes PNG erfolgreich exportiert!",
                alertExportError: "‚ùå Fehler beim Export: ",
                initialColumn1: "Spalte 1",
                initialColumn2: "Spalte 2",
                sectionColor: "Section-Farbe",
                columnColor: "Header-Farbe",
                splitColumnTooltip: "Spalte in 2-3 Teile teilen/zusammenf√ºhren",
                deleteSectionTooltip: "Section l√∂schen"
            },
            en: {
                mainTitle: "üè¢ Explainator - Ultimate Edition",
                infoPanelTitle: "Full Control:",
                infoPanelFeatures: "‚úì Save & Load Templates | ‚úì PNG Export | ‚úì Adjustable Section Colors | ‚úì Move Sections within & between Columns | ‚úì Manage Categories with Custom Colors | ‚úì Move & Resize Columns | ‚úì Drag & Drop Everywhere | ‚úì Stable Section Functionality | ‚úì 3-Column Split Possible",
                formatting: "üî† Formatting",
                addColumn: "‚ûï New Column",
                addBox: "üì¶ New Box",
                manageCategories: "üé® Manage Categories",
                exportPNG: "üì∏ Export as PNG",
                gridLines: "‚äû Grid Lines",
                gridLinesHide: "‚äû Hide Grid Lines",
                saveTemplate: "üíæ Save Template",
                loadTemplate: "üìÇ Load Template",
                resetLayout: "üîÑ Reset Layout",
                clearAll: "üóëÔ∏è Clear All",
                addBoxModalTitle: "Add New Box",
                boxNamePlaceholder: "Box Name",
                newApplicationName: "New Application",
                fullWidth: "Full Width",
                halfWidth: "Half Width",
                boxHeightLabel: "Height (lines)",
                boxHeight1: "1 line (default)",
                boxHeight2: "2 lines",
                boxHeight3: "3 lines",
                add: "Add",
                cancel: "Cancel",
                textColorLabel: "Text:",
                imageMode: "Image instead of text",
                imageSelectOrDrop: "Select or drop an image (JPG/PNG)",
                imageMaxHeightHint: "Max height: 3 √ó 3‚Äëline boxes",
                alertChooseImage: "Please select or drop an image (JPG/PNG).",
                addNewCategoryTitle: "Add New Category:",
                categoryNamePlaceholder: "Category Name (e.g., Cloud Services)",
                color1: "Color 1:",
                color2: "Color 2:",
                addCategory: "‚ûï Add Category",
                existingCategories: "Existing Categories:",
                delete: "Delete",
                done: "Done",
                savedTemplates: "Saved Templates:",
                noSavedTemplates: "No saved templates found",
                loadTemplateFromFileTitle: "Load Template from File:",
                loadFile: "üìÇ Load File",
                close: "Close",
                legendTitle: "Categories:",
                newColumn: "New Column",
                newSection: "New Section",
                confirmDeleteColumn: "Really delete column?",
                confirmDeleteSection: "Really delete section?",
                confirmResetLayout: "Really reset layout?",
                confirmClearAll: "Really delete everything?",
                alertEnterName: "Please enter a name!",
                alertCategoryAdded: "Category \"{name}\" has been added!",
                alertOneCategoryNeeded: "At least one category must exist!",
                confirmDeleteCategory: "Really delete category \"{name}\"?",
                promptTemplateName: "Enter Template Name:",
                defaultTemplateName: "My Template",
                alertTemplateSaved: "Template \"{name}\" saved and downloaded!",
                alertTemplateNotFound: "Template not found!",
                confirmLoadTemplate: "Load template \"{name}\"? The current layout will be overwritten.",
                alertTemplateLoaded: "Template \"{name}\" loaded successfully!",
                alertChooseFile: "Please select a file!",
                confirmLoadFromFile: "Load template \"{name}\" from file? The current layout will be overwritten.",
                alertFileLoadError: "Error loading template file: ",
                alertFileLoaded: "Template \"{name}\" successfully loaded from file!",
                exporting: "üì∏ Exporting...",
                alertExportSuccess: "‚úÖ Clean PNG exported successfully!",
                alertExportError: "‚ùå Error during export: ",
                initialColumn1: "Column 1",
                initialColumn2: "Column 2",
                sectionColor: "Section Color",
                columnColor: "Header Color",
                splitColumnTooltip: "Split/merge column into 2-3 parts",
                deleteSectionTooltip: "Delete section"
            }
        };

        function setLanguage(lang) {
            currentLanguage = lang;
            document.documentElement.lang = lang;
            localStorage.setItem('ea_language', lang);

            const langSwitchBtn = document.getElementById('langSwitchBtn');
            if(langSwitchBtn) langSwitchBtn.textContent = lang === 'de' ? 'EN' : 'DE';

            const t = translations[lang];

            document.querySelectorAll('[data-translate]').forEach(el => {
                const key = el.dataset.translate;
                if (t[key]) {
                    el.innerHTML = t[key];
                }
            });
            
            // Special handling for placeholders
            const boxNameInput = document.getElementById('boxName');
            if(boxNameInput) boxNameInput.placeholder = t.boxNamePlaceholder;

            const categoryNameInput = document.getElementById('categoryName');
            if(categoryNameInput) categoryNameInput.placeholder = t.categoryNamePlaceholder;

            // Update dynamically created elements like buttons
            document.querySelectorAll('.add-section-btn').forEach(btn => btn.textContent = `+ ${t.newSection}`);

            // Update legend title
            updateLegend();
            // Equalize header heights after text changes
            requestAnimationFrame(equalizeHeaderHeights);
        }

        function toggleLanguage() {
            const newLang = currentLanguage === 'de' ? 'en' : 'de';
            setLanguage(newLang);
        }

        // Global variables
        let draggedElement = null;
        let columnIdCounter = 1;
        let isResizing = false;
        let currentResizeColumn = null;
        let startX = 0;
        let startWidth = 0;

        let sectionColorPalette = [
            { name: 'Standard', color: '#8B4513' }, { name: 'Blau', color: '#2196F3' }, { name: 'Gr√ºn', color: '#4CAF50' },
            { name: 'Orange', color: '#FF9800' }, { name: 'Lila', color: '#9C27B0' }, { name: 'Rot', color: '#F44336' },
            { name: 'Grau', color: '#607D8B' }, { name: 'Teal', color: '#009688' }, { name: 'Grau 0%', color: '#000000' },
            { name: 'Grau 10%', color: '#1A1A1A' }, { name: 'Grau 20%', color: '#333333' }, { name: 'Grau 30%', color: '#4D4D4D' },
            { name: 'Grau 40%', color: '#666666' }, { name: 'Grau 50%', color: '#808080' }, { name: 'Grau 60%', color: '#999999' },
            { name: 'Grau 70%', color: '#B3B3B3' }, { name: 'Grau 80%', color: '#CCCCCC' }, { name: 'Grau 90%', color: '#E6E6E6' },
            { name: 'Grau 100%', color: '#FFFFFF' }
        ];
        
        // Category management - Start with default categories
        let categories = {
            'cat1': { name: 'Cat. 1', color1: '#667eea', color2: '#764ba2' },
            'cat2': { name: 'Cat. 2', color1: '#f093fb', color2: '#f5576c' },
            'cat3': { name: 'Cat. 3', color1: '#fa709a', color2: '#fee140' },
            'cat4': { name: 'Cat. 4', color1: '#84fab0', color2: '#8fd3f4' },
            'cat5': { name: 'Cat. 5', color1: '#a8edea', color2: '#fed6e3' }
        };
        
        // Image modal state + last focused section box-container
        let pendingImageDataUrl = null;
        let lastFocusedBoxContainer = null;

        // Initialize on load
        document.addEventListener('DOMContentLoaded', function() {
            const savedLang = localStorage.getItem('ea_language') || 'de';
            setLanguage(savedLang);

            initializeDragAndDrop();
            initializeResize();
            initializeColumnDrag();
            updateCategoryStyles();
            updateCategoryDropdown();
            updateLegend();
            initializeDefaultLayout();
            setupImageModal();
            setupLastFocusTracking();
            normalizeDeleteIcons(document);
            setupDeleteIconObserver();
            equalizeHeaderHeights();
            window.addEventListener('resize', () => equalizeHeaderHeights());
        
            document.getElementById('categoryColor1').addEventListener('input', updateColorPreview);
            document.getElementById('categoryColor2').addEventListener('input', updateColorPreview);
        });

        function equalizeHeaderHeights() {
            try {
                const headers = Array.from(document.querySelectorAll('.column-header'));
                if (!headers.length) return;
                // Reset heights first to measure natural single-line heights
                headers.forEach(h => h.style.minHeight = '');
                const heights = headers.map(h => h.scrollHeight);
                const minH = Math.min(...heights);
                const maxH = Math.max(...heights);
                const wrapDetected = (maxH - minH) > 6; // tolerance
                if (!wrapDetected) {
                    headers.forEach(h => h.style.minHeight = maxH + 'px');
                } else {
                    headers.forEach(h => h.style.minHeight = '');
                }
            } catch(e) {}
        }

        function setupImageModal() {
            const chk = document.getElementById('boxIsImage');
            const textOpts = document.getElementById('textOptions');
            const linesLabel = document.getElementById('boxLinesLabel');
            const linesSel = document.getElementById('boxLines');
            const imgOpts = document.getElementById('imageOptions');
            const fileInput = document.getElementById('boxImageFile');
            const dz = document.getElementById('imageDropzone');
            const t = translations[currentLanguage];

            if (dz) dz.textContent = t.imageSelectOrDrop || dz.textContent;

            if (chk) {
                chk.addEventListener('change', () => {
                    const on = chk.checked;
                    if (textOpts) textOpts.style.display = on ? 'none' : 'flex';
                    if (linesLabel) linesLabel.style.display = on ? 'none' : 'block';
                    if (linesSel) linesSel.style.display = on ? 'none' : 'block';
                    if (imgOpts) imgOpts.style.display = on ? 'block' : 'none';
                });
            }

            if (fileInput) {
                fileInput.addEventListener('change', (e) => {
                    if (e.target.files && e.target.files.length) {
                        handleImageFiles(e.target.files);
                    }
                });
            }

            if (dz) {
                ;['dragenter','dragover'].forEach(evt => dz.addEventListener(evt, (e) => {
                    e.preventDefault(); e.stopPropagation(); dz.classList.add('dragover');
                }));
                ;['dragleave','dragend','drop'].forEach(evt => dz.addEventListener(evt, (e) => {
                    dz.classList.remove('dragover');
                }));
                dz.addEventListener('drop', (e) => {
                    e.preventDefault(); e.stopPropagation();
                    const files = e.dataTransfer && e.dataTransfer.files ? e.dataTransfer.files : null;
                    if (files && files.length) handleImageFiles(files);
                });
            }
        }

        function handleImageFiles(fileList) {
            const file = Array.from(fileList).find(f => /image\/(png|jpeg)/i.test(f.type));
            if (!file) { alert(translations[currentLanguage].alertChooseImage); return; }
            const reader = new FileReader();
            reader.onload = () => { setImagePreview(reader.result); };
            reader.readAsDataURL(file);
        }

        function setImagePreview(dataUrl) {
            pendingImageDataUrl = dataUrl;
            const prev = document.getElementById('imagePreview');
            if (prev) {
                prev.innerHTML = `<img src="${dataUrl}" alt="preview" />`;
                prev.style.display = 'block';
            }
        }

        function setupLastFocusTracking() {
            document.addEventListener('click', (e) => {
                const bc = e.target.closest && e.target.closest('.box-container');
                if (bc) { lastFocusedBoxContainer = bc; return; }
                const sg = e.target.closest && e.target.closest('.section-group');
                if (sg) {
                    const inner = sg.querySelector(':scope > .box-container');
                    if (inner) lastFocusedBoxContainer = inner;
                }
            }, true);
        }

        function getTargetBoxContainer() {
            if (lastFocusedBoxContainer && document.body.contains(lastFocusedBoxContainer)) return lastFocusedBoxContainer;
            return document.querySelector('.box-container');
        }

        function normalizeDeleteIcons(root) {
            const scope = root || document;
            scope.querySelectorAll('.delete-btn, .section-delete, .delete-column').forEach(el => { el.textContent = 'x'; });
        }

        function setupDeleteIconObserver() {
            try {
                const mo = new MutationObserver((mutations) => {
                    for (const m of mutations) {
                        m.addedNodes && m.addedNodes.forEach(node => {
                            if (!(node instanceof Element)) return;
                            normalizeDeleteIcons(node);
                        });
                    }
                });
                mo.observe(document.body, { childList: true, subtree: true });
            } catch(e) {}
        }
        
        function initializeDefaultLayout() {
            const container = document.getElementById('mainContainer');
            const t = translations[currentLanguage];
            
            const column1 = createColumnElement(t.initialColumn1, columnIdCounter++);
            const column2 = createColumnElement(t.initialColumn2, columnIdCounter++);
            
            container.innerHTML = '';
            container.appendChild(column1);
            container.appendChild(column2);
            
            const addBtn = document.createElement('div');
            addBtn.className = 'add-column';
            addBtn.onclick = addNewColumn;
            addBtn.innerHTML = '<span>+</span>';
            container.appendChild(addBtn);
        }
        
        function createColumnElement(title, id) {
            const column = document.createElement('div');
            const t = translations[currentLanguage];
            column.className = 'column';
            column.setAttribute('data-column-id', id);
            column.setAttribute('data-split-state', 'normal');
            column.innerHTML = `
                <div class="column-header" draggable="true">
                     ${title} 
                    <span class="header-btn color-column-btn" title="${t.columnColor}" draggable="false" onmousedown="event.stopPropagation();event.preventDefault();" onpointerdown="event.stopPropagation();event.preventDefault();" onclick="showColumnColorPicker(this)">üñåÔ∏è</span>


                    <span class="header-btn delete-column" onclick="deleteColumn(this)">√ó</span>
                </div>
                <div class="resize-handle"></div>
                <div class="column-content">
                    <div class="section-group" draggable="true">
                        <div class="section-title">
                            ${t.newSection}
                            <span class="section-delete" onclick="deleteSection(this)" title="${t.deleteSectionTooltip}">√ó</span>
                            <span class="section-menu" onclick="showSectionColorPicker(this)">üé®</span>
                        </div>
                        <div class="box-container"></div>
                    </div>
                </div>
            `;
            // Ensure split counter exists and reflects current parts
            try {
                const del1 = column.querySelector('.delete-column'); if (del1) del1.textContent = 'x';
                const del2 = column.querySelector('.section-delete'); if (del2) del2.textContent = 'x';
                const header = column.querySelector('.column-header');
                const del = header.querySelector('.delete-column');
                let counter = header.querySelector('.split-counter');
                if (!counter) {
                    counter = document.createElement('span');
                    counter.className = 'split-counter';
                    counter.setAttribute('title', t.splitColumnTooltip);
                    counter.innerHTML = '\n                        <button onclick="decrementSplit(this); event.stopPropagation();" onmousedown="event.stopPropagation();">-</button>\n                        <span class="value">1</span>\n                        <button onclick="incrementSplit(this); event.stopPropagation();" onmousedown="event.stopPropagation();">+</button>\n                    ';
                    header.insertBefore(counter, del);
                }
                if (!column.hasAttribute('data-split-parts')) column.setAttribute('data-split-parts', '1');
                updateSplitCounterDisplay(column);
            } catch(e) {}
            // Ensure consistent header height alignment
            requestAnimationFrame(equalizeHeaderHeights);
            return column;
        }

        function splitColumn(column, parts) {
            const content = column.querySelector('.column-content');
            const sections = Array.from(content.querySelectorAll('.section-group'));
            
            column.classList.remove('split-column', 'split-column-3');
            
            const splitContainer = document.createElement('div');
            splitContainer.className = 'column-split-content';
            
            for (let i = 0; i < parts; i++) {
                const partDiv = document.createElement('div');
                partDiv.className = 'column-part';
                
                const sectionsPerSplit = Math.ceil(sections.length / parts);
                const startIndex = i * sectionsPerSplit;
                const endIndex = Math.min((i + 1) * sectionsPerSplit, sections.length);
                
                for (let j = startIndex; j < endIndex; j++) {
                    if (sections[j]) partDiv.appendChild(sections[j]);
                }
                
                splitContainer.appendChild(partDiv);
            }
            
            content.innerHTML = '';
            content.appendChild(splitContainer);
            // Do not force width on split; user controls size by dragging
        }

        function unsplitColumn(column) {
            const content = column.querySelector('.column-content');
            const splitContainer = content.querySelector('.column-split-content');
            
            if (splitContainer) {
                const allSections = Array.from(splitContainer.querySelectorAll('.section-group'));
                column.classList.remove('split-column', 'split-column-3');
                content.innerHTML = '';
                allSections.forEach(section => content.appendChild(section));
            }
        }

        function updateSplitCounterDisplay(column) {
            const valueSpan = column.querySelector('.split-counter .value');
            if (!valueSpan) return;
            const p = parseInt(column.getAttribute('data-split-parts') || '1', 10) || 1;
            valueSpan.textContent = String(p);
        }

        function applySplit(column, parts) {
            const p = Math.max(1, parseInt(parts, 10) || 1);
            column.setAttribute('data-split-parts', String(p));
            updateSplitCounterDisplay(column);
            if (p === 1) {
                unsplitColumn(column);
                column.setAttribute('data-split-state', 'normal');
            } else {
                splitColumn(column, p);
                column.setAttribute('data-split-state', p === 2 ? 'split-2' : (p === 3 ? 'split-3' : 'split-n'));
            }
            requestAnimationFrame(equalizeHeaderHeights);
        }

        function incrementSplit(btn) {
            const column = btn.closest('.column');
            const parts = parseInt(column.getAttribute('data-split-parts') || '1', 10);
            applySplit(column, parts + 1);
        }

        function decrementSplit(btn) {
            const column = btn.closest('.column');
            const parts = parseInt(column.getAttribute('data-split-parts') || '1', 10);
            applySplit(column, Math.max(1, parts - 1));
        }

        function cloneColumn(btn){
            const orig = btn.closest('.column');
            if (!orig) return;
            const parent = orig.parentElement;
            const clone = orig.cloneNode(true);
            clone.setAttribute('data-column-id', ++columnIdCounter);
            // remove any open pickers within clone
            clone.querySelectorAll('.column-color-picker, .section-color-picker').forEach(el => el.remove());
            // keep split parts attribute/state
            const parts = parseInt(orig.getAttribute('data-split-parts') || '1', 10);
            clone.setAttribute('data-split-parts', String(parts));
            // insert after original
            parent.insertBefore(clone, orig.nextSibling);
            // placeholders entfernt
        }
        
        function updateColorPreview() {
            const color1 = document.getElementById('categoryColor1').value;
            const useGrad = document.getElementById('useGradient') && document.getElementById('useGradient').checked;
            const color2 = useGrad ? (document.getElementById('categoryColor2').value || color1) : color1;
            document.getElementById('colorPreview').style.background = `linear-gradient(135deg, ${color1} 0%, ${color2} 100%)`;
        }
        
        function updateCategoryStyles() {
            let styleEl = document.getElementById('dynamic-styles');
            if (!styleEl) {
                styleEl = document.createElement('style');
                styleEl.id = 'dynamic-styles';
                document.head.appendChild(styleEl);
            }
            let styles = '';
            for (const [key, cat] of Object.entries(categories)) {
                const c1 = cat.color1; const c2 = cat.color2 || cat.color1;
                styles += `.${key} { background: linear-gradient(135deg, ${c1} 0%, ${c2} 100%); color: ${isLightColor(c1) ? '#1a1a1a' : 'white'}; border: none; }`;
            }
            styleEl.innerHTML = styles;
        }
        
        function isLightColor(color) {
            const hex = color.replace('#', '');
            const r = parseInt(hex.substr(0, 2), 16);
            const g = parseInt(hex.substr(2, 2), 16);
            const b = parseInt(hex.substr(4, 2), 16);
            return ((r * 299) + (g * 587) + (b * 114)) / 1000 > 155;
        }
        
        function updateCategoryDropdown() {
            const select = document.getElementById('boxType');
            select.innerHTML = '';
            for (const [key, cat] of Object.entries(categories)) {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = cat.name;
                select.appendChild(option);
            }
        }
        
        function updateLegend() {
            const legend = document.getElementById('legend');
            const t = translations[currentLanguage];
            legend.innerHTML = `<strong style="margin-right: 20px;">${t.legendTitle}</strong>`;
            for (const [key, cat] of Object.entries(categories)) {
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.onclick = () => filterByCategory(key);
                item.innerHTML = `<div class="legend-box" style="background: linear-gradient(135deg, ${cat.color1} 0%, ${cat.color2} 100%)"></div><span>${cat.name}</span>`;
                legend.appendChild(item);
            }
        }
        
        function showCategoryModal() {
            document.getElementById('categoryModal').classList.add('show');
            updateCategoryList();
            // Render preset swatches for quick selection
            const palette = ['#8B4513','#A0522D','#CD853F','#D2691E','#FF9800','#FFC107','#FF5722','#2196F3','#1E88E5','#64B5F6','#00BCD4','#009688','#4CAF50','#8BC34A','#9C27B0','#AB47BC','#E91E63','#F44336','#607D8B','#455A64','#000000','#333333','#666666','#999999','#CCCCCC','#FFFFFF'];
            const sw1 = document.getElementById('catSwatches1');
            const sw2 = document.getElementById('catSwatches2');
            if (sw1) sw1.innerHTML = palette.map(c=>`<div class="swatch" data-target="categoryColor1" data-c="${c}" style="width:22px;height:22px;border-radius:4px;border:1px solid #bbb;cursor:pointer;background:${c}"></div>`).join('');
            if (sw2) sw2.innerHTML = palette.map(c=>`<div class="swatch" data-target="categoryColor2" data-c="${c}" style="width:22px;height:22px;border-radius:4px;border:1px solid #bbb;cursor:pointer;background:${c}"></div>`).join('');
            document.getElementById('catColorGroup').addEventListener('click', function(e){
                const s = e.target.closest && e.target.closest('.swatch');
                if (!s) return;
                const target = s.getAttribute('data-target');
                const color = s.getAttribute('data-c');
                const input = document.getElementById(target);
                if (input) { input.value = color; updateColorPreview(); }
            });
            toggleGradient();
        }

        // === LAYOUT BUILDER ===
        function showLayoutBuilder(){
            const m = document.getElementById('layoutBuilderModal');
            document.getElementById('lbColumns').value = Math.max(1, document.querySelectorAll('.column').length || 2);
            renderLayoutBuilderGrid();
            m.classList.add('show');
        }

        function renderLayoutBuilderGrid(){
            const n = parseInt(document.getElementById('lbColumns').value, 10) || 1;
            const grid = document.getElementById('lbGrid');
            grid.innerHTML = '';
            for (let i=0;i<n;i++){
                const row = document.createElement('div');
                row.style.display='grid';
                row.style.gridTemplateColumns='1fr 1fr 1fr';
                row.style.gap='8px';
                row.style.alignItems='center';
                row.innerHTML = `
                    <div>
                        <label>Titel</label>
                        <input type="text" class="lbTitle" data-index="${i}" value="Spalte ${i+1}" style="width:100%">
                    </div>
                    <div>
                        <label>Splits</label>
                        <input type="number" class="lbSplits" data-index="${i}" min="1" max="8" value="1" style="width:100%">
                    </div>
                    <div>
                        <label>Sections/Teil</label>
                        <input type="number" class="lbSections" data-index="${i}" min="0" max="20" value="1" style="width:100%">
                    </div>`;
                grid.appendChild(row);
            }
        }

        function applyLayoutBuilder(){
            const cols = parseInt(document.getElementById('lbColumns').value,10) || 1;
            const titles = Array.from(document.querySelectorAll('#lbGrid .lbTitle')).map(i=>i.value.trim()||'Spalte');
            const splits = Array.from(document.querySelectorAll('#lbGrid .lbSplits')).map(i=>Math.max(1, parseInt(i.value,10)||1));
            const sections = Array.from(document.querySelectorAll('#lbGrid .lbSections')).map(i=>Math.max(0, parseInt(i.value,10)||0));

            const container = document.getElementById('mainContainer');
            container.innerHTML = '';
            for (let i=0;i<cols;i++){
                const col = createColumnElement(titles[i] || `Spalte ${i+1}`, i+1);
                container.appendChild(col);
                const parts = splits[i] || 1;
                if (parts > 1) applySplit(col, parts);
                const per = sections[i] || 0;
                if (parts === 1){
                    // Remove default section, then add desired
                    const content = col.querySelector('.column-content');
                    const def = content.querySelector('.section-group');
                    if (def) def.remove();
                    for (let s=0;s<per;s++){
                        const btn = content.querySelector('.add-section-btn');
                        addSection(btn);
                    }
                } else {
                    const partsNodes = col.querySelectorAll('.column-part');
                    partsNodes.forEach(pNode => {
                        // Remove any default section in part
                        const defS = pNode.querySelector('.section-group'); if (defS) defS.remove();
                        const btn = pNode.querySelector('.add-section-btn');
                        for (let s=0;s<per;s++){ addSection(btn); }
                    });
                }
            }
            // Add trailing + column button
            const addBtn = document.createElement('div');
            addBtn.className='add-column'; addBtn.onclick=addNewColumn; addBtn.innerHTML='<span>+</span>';
            container.appendChild(addBtn);
            // placeholders entfernt
            closeModal('layoutBuilderModal');
        }
        
        function updateCategoryList() {
            const list = document.getElementById('categoryList');
            list.innerHTML = '';
            const t = translations[currentLanguage];
            for (const [key, cat] of Object.entries(categories)) {
                const item = document.createElement('div');
                item.className = 'category-item';
                const c2 = cat.color2 || cat.color1;
                item.innerHTML = `
                    <div class="category-preview" style="background: linear-gradient(135deg, ${cat.color1} 0%, ${c2} 100%);"></div>
                    <div class="category-controls">
                        <input type="text" value="${cat.name}" onchange="updateCategoryName('${key}', this.value)">
                        <input type="color" value="${cat.color1}" onchange="updateCategoryColor('${key}', this.value, '${c2}')">
                        <input type="color" value="${c2}" onchange="updateCategoryColor('${key}', '${cat.color1}', this.value)">
                        <button class="btn btn-danger small-btn" onclick="deleteCategory('${key}')">${t.delete}</button>
                    </div>`;
                list.appendChild(item);
            }
        }
        
        function addCategory() {
            const name = document.getElementById('categoryName').value.trim();
            const color1 = document.getElementById('categoryColor1').value;
            const useGrad = document.getElementById('useGradient').checked;
            const color2 = useGrad ? (document.getElementById('categoryColor2').value || color1) : color1;
            const t = translations[currentLanguage];
            if (!name) { alert(t.alertEnterName); return; }
            
            const key = 'cat-' + Date.now();
            categories[key] = { name, color1, color2 };
            
            updateCategoryStyles(); updateCategoryDropdown(); updateLegend(); updateCategoryList();
            document.getElementById('categoryName').value = '';
        }
        
        function updateCategoryName(key, newName) {
            if (categories[key] && newName.trim()) {
                categories[key].name = newName.trim();
                updateCategoryDropdown(); updateLegend();
            }
        }
        
        function updateCategoryColor(key, color1, color2) {
            if (categories[key]) {
                categories[key].color1 = color1; categories[key].color2 = color2;
                updateCategoryStyles(); updateLegend(); updateCategoryList();
            }
        }

        function toggleGradient(){
            const row = document.getElementById('gradientRow');
            const sw2 = document.getElementById('catSwatches2');
            const chk = document.getElementById('useGradient');
            if (!row || !chk) return;
            const show = chk.checked;
            row.style.display = show ? 'flex' : 'none';
            if (sw2) sw2.style.display = show ? 'flex' : 'none';
            updateColorPreview();
        }

        async function pickEyeDropper(targetId){
            try{
                if (!('EyeDropper' in window)) { alert('Pipette wird von diesem Browser nicht unterst√ºtzt.'); return; }
                const ed = new EyeDropper();
                const res = await ed.open();
                const input = document.getElementById(targetId);
                if (input) { input.value = res.sRGBHex; updateColorPreview(); }
            }catch(err){ /* user cancelled */ }
        }
        
        function deleteCategory(key) {
            const t = translations[currentLanguage];
            if (Object.keys(categories).length <= 1) { alert(t.alertOneCategoryNeeded); return; }
            if (confirm(t.confirmDeleteCategory.replace('{name}', categories[key].name))) {
                delete categories[key];
                updateCategoryStyles(); updateCategoryDropdown(); updateLegend(); updateCategoryList();
            }
        }
        
        function filterByCategory(key) {
            document.querySelectorAll('.app-box').forEach(box => box.style.opacity = box.classList.contains(key) ? '1' : '0.3');
            setTimeout(() => document.querySelectorAll('.app-box').forEach(box => box.style.opacity = '1'), 2000);
        }

        function toggleGridLines() {
            const container = document.querySelector('.main-container');
            const btn = document.getElementById('gridToggleBtn');
            const t = translations[currentLanguage];
            container.classList.toggle('grid-lines');
            btn.textContent = container.classList.contains('grid-lines') ? t.gridLinesHide : t.gridLines;
        }
        
// HELFER-FUNKTION: Findet heraus, vor welches BOX-Element eingef√ºgt werden soll.
        function getDragAfterElement(container, x, y) {
            const draggableElements = [...container.querySelectorAll('.app-box:not(.dragging-placeholder)')];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offsetY = y - box.top - box.height / 2;
                if (offsetY < 0 && offsetY > closest.offsetY) {
                    return { offsetY: offsetY, element: child };
                } else {
                    return closest;
                }
            }, { offsetY: Number.NEGATIVE_INFINITY }).element;
        }

        // HELFER-FUNKTION: Findet heraus, vor welches SECTION-Element eingef√ºgt werden soll.
        function getDragAfterSection(container, y) {
            const draggableElements = [...container.querySelectorAll('.section-group:not(.dragging-placeholder)')];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        // Calculates insertion point among direct children (sections or split blocks)
        function getDragAfterBlock(container, y) {
            const selector = ':scope > .section-group:not(.dragging-placeholder), :scope > .column-split-content';
            const elements = [...container.querySelectorAll(selector)];
            return elements.reduce((closest, el) => {
                const rect = el.getBoundingClientRect();
                const offset = y - rect.top - rect.height / 2;
                if (offset < 0 && offset > closest.offset) {
                    return { offset, element: el };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        // ==================================================================
        // FINALE, KOMPLETTE DRAG & DROP FUNKTION
        // ==================================================================
        function initializeDragAndDrop() {
            let draggedElement = null; // Das Element, das WIRKLICH bewegt wird
            let placeholder = null;    // Das visuelle Feedback-Element
            let isCloning = false;     // Merkt sich, ob wir gerade klonen
            let draggedFromSplit = false; // Ursprung in .column-part?
            let sourceSplitParts = 0;      // Anzahl Parts im Ursprungs-Split
            let lastDragX = 0;             // letzte Maus-X-Position

            document.addEventListener('dragstart', function(e) {
                const target = e.target.closest && e.target.closest('.app-box, .section-group, .column-split-content');
                if (!target) return;
                if (target.classList.contains('section-group') && target.querySelector('.section-title input')) return;

                isCloning = e.ctrlKey;
                
                if (isCloning) {
                    draggedElement = target.cloneNode(true);
                    draggedElement.classList.add('dragging');
                } else {
                    draggedElement = target;
                    setTimeout(() => target.classList.add('dragging'), 0);
                }
                
                placeholder = document.createElement('div');
                placeholder.classList.add('dragging-placeholder');
                if (target.classList.contains('section-group')) {
                    placeholder.style.height = '100px';
                } else {
                    placeholder.style.height = target.offsetHeight + 'px';
                }
                // Track origin split context
                if (target.classList.contains('section-group')) {
                    const srcPart = target.closest('.column-part');
                    draggedFromSplit = !!srcPart;
                    const srcSplit = srcPart ? srcPart.parentElement : null;
                    sourceSplitParts = srcSplit ? srcSplit.querySelectorAll(':scope > .column-part').length : 0;
                } else { draggedFromSplit = false; sourceSplitParts = 0; }
                
                e.dataTransfer.effectAllowed = 'move';
                try { e.dataTransfer.setData('text/plain', ''); } catch (err) {}
            });

            document.addEventListener('dragover', function(e) {
                e.preventDefault();
                if (!draggedElement) return;
                lastDragX = e.clientX;

                if (draggedElement.classList.contains('app-box')) {
                    const container = e.target.closest('.box-container');
                    if (container) {
                        const afterElement = getDragAfterElement(container, e.clientX, e.clientY);
                        container.insertBefore(placeholder, afterElement);
                    }
                } 
                else if (draggedElement.classList.contains('section-group') || draggedElement.classList.contains('column-split-content')) {
                    // This part is for dragging a section from one split part to another.
                    // It should only apply when dragging a section-group.
                    if (draggedFromSplit && draggedElement.classList.contains('section-group')) {
                        let part = e.target.closest('.column-part');
                        if (!part) {
                            const split = e.target.closest('.column-split-content');
                            if (split) {
                                const parts = Array.from(split.querySelectorAll(':scope > .column-part'));
                                let best = null, bestDx = Infinity;
                                parts.forEach(p => { const r = p.getBoundingClientRect(); const cx = r.left + r.width/2; const dx = Math.abs(e.clientX - cx); if (dx < bestDx) { bestDx = dx; best = p; } });
                                part = best;
                            }
                        }
                        if (part) {
                            const afterElement = getDragAfterSection(part, e.clientY);
                            part.insertBefore(placeholder, afterElement);
                            return;
                        }
                    }
                    
                    // This part is for dropping into the main column content area.
                    // It should apply to both section-group and column-split-content.
                    const container = e.target.closest('.column-content');
                    if (container) {
                        const afterElement = getDragAfterBlock(container, e.clientY);
                        container.insertBefore(placeholder, afterElement);
                        // If we are dragging from a split, allow user to choose mode via Alt key
                        if (draggedFromSplit && draggedElement.classList.contains('section-group')) {
                            const full = !!e.altKey; // Alt = insert as full-width (unsplitted)
                            placeholder.setAttribute('data-drop-mode', full ? 'full' : 'split');
                            placeholder.classList.toggle('full-width-mode', full);
                        } else {
                            placeholder.removeAttribute('data-drop-mode');
                            placeholder.classList.remove('full-width-mode');
                        }
                    }
                }
            });

            document.addEventListener('drop', function(e) {
                e.preventDefault();
                if (!placeholder || !placeholder.parentElement) return;
                
                const dropContainer = placeholder.parentElement;
                if (draggedElement && draggedElement.classList && draggedElement.classList.contains('section-group')
                    && draggedFromSplit && dropContainer.classList.contains('column-content')) {
                    // Check placeholder mode: Alt during dragover toggles 'full' mode
                    const mode = placeholder && placeholder.getAttribute('data-drop-mode');
                    if (mode === 'full') {
                        dropContainer.replaceChild(draggedElement, placeholder);
                    } else {
                    // Preserve split: create a new split block here and insert into the nearest part
                    const column = dropContainer.closest('.column');
                    const parts = Math.max(2, parseInt((column && column.getAttribute('data-split-parts')) || (sourceSplitParts || '2'), 10) || 2);
                    const splitContainer = document.createElement('div');
                    splitContainer.className = 'column-split-content';
                    for (let i = 0; i < parts; i++) {
                        const partDiv = document.createElement('div');
                        partDiv.className = 'column-part';
                        splitContainer.appendChild(partDiv);
                    }
                    // Choose part by mouse X relative to container
                    let index = 0;
                    try {
                        const rect = dropContainer.getBoundingClientRect();
                        const relX = Math.max(0, Math.min(rect.width - 1, lastDragX - rect.left));
                        index = Math.min(parts - 1, Math.max(0, Math.floor(relX / (rect.width / parts))));
                    } catch(_) { index = 0; }
                    const targetPart = splitContainer.querySelectorAll(':scope > .column-part')[index];
                    targetPart.appendChild(draggedElement);
                    dropContainer.replaceChild(splitContainer, placeholder);
                    }
                } else {
                    dropContainer.replaceChild(draggedElement, placeholder);
                }
                draggedElement.classList.remove('dragging');

                // placeholders entfernt
            });

            document.addEventListener('dragend', function(e) {
                if(draggedElement) {
                    draggedElement.classList.remove('dragging');
                }
                if (placeholder && placeholder.parentElement) {
                    placeholder.remove();
                }
                draggedElement = null;
                placeholder = null;
                isCloning = false;
            });
        }

        // Sorgt dafr, dass in jedem Content-Bereich (unsplitted oder .column-part)
        // genau ein "+ New Section"-Button vorhanden ist und am Ende steht.
        function normalizeAddButtons(){ /* Placeholder-Buttons entfernt: no-op */ }
        
        function getDragAfterElement(container, x) {
            const draggableElements = [...container.querySelectorAll('.app-box:not(.dragging)')];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = x - box.left - box.width / 2;
                if (offset < 0 && offset > closest.offset) return { offset, element: child };
                else return closest;
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }
        
        function initializeResize() {
            document.addEventListener('mousedown', e => {
                if (e.target.classList.contains('resize-handle')) {
                    isResizing = true;
                    currentResizeColumn = e.target.parentElement;
                    startX = e.pageX;
                    startWidth = currentResizeColumn.offsetWidth;
                    e.preventDefault();
                }
            });
            document.addEventListener('mousemove', e => {
                if (!isResizing) return;
                const width = startWidth + e.pageX - startX;
                const minW = 150;
                if (width >= minW) currentResizeColumn.style.width = width + 'px';
            });
            document.addEventListener('mouseup', () => { isResizing = false; currentResizeColumn = null; });
        }
        
        function initializeColumnDrag() {
            let draggedColumn = null;
            let cloningColumn = false;
            document.addEventListener('dragstart', e => {
                if (e.target.classList.contains('column-header')) {
                    const original = e.target.parentElement;
                    cloningColumn = !!e.ctrlKey;
                    if (cloningColumn) {
                        const clone = original.cloneNode(true);
                        original.parentNode.insertBefore(clone, original.nextSibling);
                        draggedColumn = clone;
                    } else {
                        draggedColumn = original;
                    }
                    // add visual dragging effect
                    draggedColumn.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                }
            });
            document.addEventListener('dragover', e => {
                if (!draggedColumn) return;
                e.preventDefault();
                const column = e.target.closest('.column');
                if (column && column !== draggedColumn) {
                    const columns = [...document.getElementById('mainContainer').querySelectorAll('.column')];
                    const draggedIndex = columns.indexOf(draggedColumn);
                    const targetIndex = columns.indexOf(column);
                    if (draggedIndex < targetIndex) column.parentNode.insertBefore(draggedColumn, column.nextSibling);
                    else column.parentNode.insertBefore(draggedColumn, column);
                }
            });
            document.addEventListener('dragend', () => {
                if (draggedColumn) draggedColumn.classList.remove('dragging');
                draggedColumn = null;
                cloningColumn = false;
            });
        }
        
        function addNewColumn() {
            const container = document.getElementById('mainContainer');
            const addButton = container.querySelector('.add-column');
            const t = translations[currentLanguage];
            const newColumn = createColumnElement(t.newColumn, columnIdCounter++);
            container.insertBefore(newColumn, addButton);
            requestAnimationFrame(equalizeHeaderHeights);
        }
        
        function deleteColumn(btn) {
            if (confirm(translations[currentLanguage].confirmDeleteColumn)) {
                btn.closest('.column').remove();
            }
        }

        // Insert a new split block at the end of the column
        function addSection(btn) {
  const columnContent = btn.parentElement;
  const t = translations[currentLanguage];
  const newSection = document.createElement("div");
  newSection.className = "section-group";
  newSection.draggable = true;
  newSection.innerHTML = '<div class="section-title">' + t.newSection + '<span class="section-delete" onclick="deleteSection(this)" title="' + t.deleteSectionTooltip + '">x</span><span class="section-menu" onclick="showSectionColorPicker(this)">üé®</span></div><div class="box-container"></div>';
  columnContent.appendChild(newSection);
  try { const sd = newSection.querySelector(".section-delete"); if (sd) sd.textContent = 'x'; } catch(e) {}
}

function insertSplitBlock(btn) {
  try {
    const header = btn.closest(".column-header");
    const column = header.closest(".column");
    const content = column.querySelector(".column-content");
    const parts = parseInt(column.getAttribute("data-split-parts") || '2', 10) || 2;
    const splitContainer = document.createElement("div");
    splitContainer.className = "column-split-content";
    for (let i = 0; i < parts; i++) {
      const partDiv = document.createElement("div");
      partDiv.className = "column-part";
      splitContainer.appendChild(partDiv);
    }
    content.appendChild(splitContainer);
  } catch(e) { console.warn(e); }
}

        function deleteSection(deleteBtn) {
            if (confirm(translations[currentLanguage].confirmDeleteSection)) {
                const sectionGroup = deleteBtn.closest('.section-group');
                sectionGroup.remove();
            }
        }

        function deleteBox(btn) { btn.parentElement.remove(); }
        
        function toggleBoxWidth(btn) {
            const box = btn.parentElement;
            box.classList.toggle('full-width');
            box.classList.toggle('half-width');
        }
        
        function showAddBoxModal() {
            const modal = document.getElementById('addBoxModal');
            modal.classList.add('show');
            const input = document.getElementById('boxName');
            if (input) {
                input.value = '';
                // place caret to start and focus for immediate typing
                input.focus();
                input.select();
                // Pressing Enter triggers Add
                input.onkeydown = function(e){ if(e.key === 'Enter'){ e.preventDefault(); addBoxNew(); } };
            }
            // Reset image options each time the modal opens
            try {
                const t = translations[currentLanguage];
                const chk = document.getElementById('boxIsImage');
                const textOpts = document.getElementById('textOptions');
                const linesLabel = document.getElementById('boxLinesLabel');
                const linesSel = document.getElementById('boxLines');
                const imgOpts = document.getElementById('imageOptions');
                const fileInput = document.getElementById('boxImageFile');
                const dz = document.getElementById('imageDropzone');
                const prev = document.getElementById('imagePreview');
                if (chk) chk.checked = false;
                if (textOpts) textOpts.style.display = 'flex';
                if (linesLabel) linesLabel.style.display = 'block';
                if (linesSel) linesSel.style.display = 'block';
                if (imgOpts) imgOpts.style.display = 'none';
                if (fileInput) fileInput.value = '';
                if (prev) { prev.innerHTML = ''; prev.style.display = 'none'; }
                if (dz) { dz.classList.remove('dragover'); dz.textContent = t.imageSelectOrDrop || dz.textContent; }
                pendingImageDataUrl = null;
            } catch (e) {}
        }
        
        function closeModal(modalId) { document.getElementById(modalId).classList.remove('show'); }
        
        // New: adds either a text-box or image-box based on modal state
        function addBoxNew() {
            const t = translations[currentLanguage];
            const isImage = !!document.getElementById('boxIsImage')?.checked;
            const name = document.getElementById('boxName').value;
            const type = document.getElementById('boxType').value;
            const width = document.getElementById('boxWidth').value;
            const lines = parseInt(document.getElementById('boxLines').value, 10) || 1;
            const textColorEl = document.getElementById('boxTextColor');
            const textColor = textColorEl ? textColorEl.value : '#000000';

            const newBox = document.createElement('div');
            newBox.draggable = true;

            if (isImage) {
                if (!pendingImageDataUrl) { alert(t.alertChooseImage); return; }
                newBox.className = `app-box image-box ${width}`;
                newBox.innerHTML = `<img src="${pendingImageDataUrl}" alt="image" />` +
                    `<button class="delete-btn" onclick="deleteBox(this)">ÔøΩ</button>` +
                    `<button class="resize-btn" onclick="toggleBoxWidth(this)">\u001d</button>`;
                pendingImageDataUrl = null;
            } else {
                newBox.className = `app-box ${type} ${width}`;
                newBox.innerHTML = `${name}<button class="delete-btn" onclick="deleteBox(this)">ÔøΩ</button><button class="resize-btn" onclick="toggleBoxWidth(this)">\u001d</button>`;
                newBox.dataset.lines = String(lines);
                const minHeight = ((lines * 26) + 12);
                newBox.style.minHeight = `${minHeight}px`;
                newBox.style.color = textColor;
            }

            const target = getTargetBoxContainer();
            if (target) target.appendChild(newBox);
            closeModal('addBoxModal');
        }

        function addBox() {
            const name = document.getElementById('boxName').value;
            const type = document.getElementById('boxType').value;
            const width = document.getElementById('boxWidth').value;
            const lines = parseInt(document.getElementById('boxLines').value, 10) || 1;
            const textColor = document.getElementById('boxTextColor').value;

            const newBox = document.createElement('div');
            newBox.className = `app-box ${type} ${width}`;
            newBox.draggable = true;
            newBox.innerHTML = `${name}<button class="delete-btn" onclick="deleteBox(this)">√ó</button><button class="resize-btn" onclick="toggleBoxWidth(this)">‚Üî</button>`;
            newBox.dataset.lines = String(lines);
            
            const minHeight = ((lines * 26) + 12);
            newBox.style.minHeight = `${minHeight}px`;

            // ALT: if (textColor !== '#000000') newBox.style.color = textColor;
            // NEU: Die Farbe wird jetzt immer direkt zugewiesen, auch wenn es schwarz ist.
            newBox.style.color = textColor;
        
            try { const db = newBox.querySelector('.delete-btn'); if (db) db.textContent = 'x'; } catch(e) {}
            const target2 = getTargetBoxContainer();
            if (target2) target2.appendChild(newBox);
            closeModal('addBoxModal');
        }       
        
        function resetLayout() {
            if (confirm(translations[currentLanguage].confirmResetLayout)) location.reload();
        }
        
        function clearAll() {
            if (confirm(translations[currentLanguage].confirmClearAll)) {
                document.getElementById('mainContainer').innerHTML = '<div class="add-column" onclick="addNewColumn()"><span>+</span></div>';
            }
        }
        
        document.addEventListener('click', e => {
            if (e.target.classList.contains('section-title') && !e.target.closest('.section-menu, .section-delete')) {
                const title = e.target;
                const menuHTML = title.querySelector('.section-menu')?.outerHTML || '';
                const deleteHTML = title.querySelector('.section-delete')?.outerHTML || '';
                const currentText = title.textContent.replace('‚öô', '').replace('√ó', '').trim();
                
                title.innerHTML = `<input type="text" value="${currentText}" onblur="updateSectionTitle(this)" onkeypress="if(event.key==='Enter') this.blur()">`;
                title.querySelector('input').focus();
                title.setAttribute('data-menu', deleteHTML + menuHTML);
            }
        });
        
        function updateSectionTitle(input) {
            const newTitle = input.value || translations[currentLanguage].newSection;
            const title = input.parentElement;
            const menuHTML = title.getAttribute('data-menu') || '';
            title.innerHTML = newTitle + ' ' + menuHTML;
            title.removeAttribute('data-menu');
        }
        
        document.addEventListener('dblclick', e => {
            if (e.target.classList.contains('column-header')) {
                const header = e.target;
                const currentText = header.childNodes[0].textContent.trim();
                const buttonsHTML = Array.from(header.querySelectorAll('.header-btn')).map(btn => btn.outerHTML).join('');
                header.innerHTML = `<input type="text" value="${currentText}" onblur="updateColumnTitle(this)" onkeypress="if(event.key==='Enter') this.blur()"> ${buttonsHTML}`;
                header.querySelector('input').focus();
            }
        });
        
        function updateColumnTitle(input) {
            const newTitle = input.value || translations[currentLanguage].newColumn;
            const header = input.parentElement;
            const buttonsHTML = Array.from(header.querySelectorAll('.header-btn')).map(btn => btn.outerHTML).join('');
            header.innerHTML = newTitle + ' ' + buttonsHTML;
            requestAnimationFrame(equalizeHeaderHeights);
        }

        // Capture-phase handler to sanitize section title editing and avoid stray 'x' character
        document.addEventListener('click', function(e){
            if (e.target.classList && e.target.classList.contains('section-title') && !e.target.closest('.section-menu, .section-delete')) {
                const title = e.target;
                const menuHTML = title.querySelector('.section-menu')?.outerHTML || '';
                const deleteHTML = title.querySelector('.section-delete')?.outerHTML || '';
                const textNode = (title.childNodes && title.childNodes[0] && title.childNodes[0].nodeType === 3) ? title.childNodes[0] : null;
                const currentText = textNode ? textNode.textContent.trim() : title.textContent.replace(/[x√ó‚öô?üé®]/g, '').trim();
                title.classList.add('editing');
                title.innerHTML = `<input type="text" value="${currentText}" onblur="updateSectionTitle(this)" onkeypress="if(event.key==='Enter') this.blur()">`;
                title.setAttribute('data-menu', deleteHTML + menuHTML);
                const inp = title.querySelector('input'); if (inp) { try { inp.focus(); inp.select && inp.select(); } catch(_){} }
                // Prevent the original bubble listener from re-running with unsanitized text
                e.stopImmediatePropagation();
                e.stopPropagation();
            }
        }, true);

        // Ensure editing class is removed after blur/update, regardless of original implementation
        (function(){
            try {
                var __orig = window.updateSectionTitle || updateSectionTitle;
                window.updateSectionTitle = function(input){
                    try { __orig(input); } catch(_) { try { updateSectionTitle(input); } catch(__){} }
                    try { var t = input && input.parentElement; if (t) t.classList.remove('editing'); } catch(__){}
                };
            } catch(__) {}
        })();

        document.addEventListener('contextmenu', e => {
            if (e.target.classList.contains('app-box')) {
                e.preventDefault();
                const box = e.target;
                const types = Object.keys(categories);
                const currentType = types.find(t => box.classList.contains(t));
                const currentIndex = types.indexOf(currentType);
                const nextIndex = (currentIndex + 1) % types.length;
                
                if (currentType) box.classList.remove(currentType);
                box.classList.add(types[nextIndex]);
            }
        });

        function showSectionColorPicker(menuBtn) {
            document.querySelectorAll('.section-color-picker').forEach(picker => picker.remove());
            const sectionTitle = menuBtn.closest('.section-title');
            const picker = document.createElement('div');
            picker.className = 'section-color-picker show';
            // Build palette identical to column header: swatch-only grid (no labels)
            const extraColors = ['#8B4513','#A0522D','#CD853F','#D2691E','#FF9800','#FFC107','#FF5722','#2196F3','#1E88E5','#64B5F6','#00BCD4','#009688','#4CAF50','#8BC34A','#9C27B0','#AB47BC','#E91E63','#F44336','#607D8B','#455A64','#000000','#333333','#666666','#999999','#CCCCCC','#FFFFFF'];
            const base = (Array.isArray(sectionColorPalette)? sectionColorPalette: []).map(c => (typeof c === 'string' ? c : c.color));
            const merged = [];
            const seen = new Set();
            base.concat(extraColors).forEach(c=>{ if(!seen.has(c)){ seen.add(c); merged.push(c);} });
            picker.innerHTML = merged.map(c => `<div class="swatch" data-c="${c}" style="background:${c}" title="${c}"></div>`).join('');
            sectionTitle.appendChild(picker);

            // After render, prevent off-screen clipping (left/right)
            requestAnimationFrame(() => {
                try {
                    const rect = picker.getBoundingClientRect();
                    const vw = window.innerWidth || document.documentElement.clientWidth;
                    if (rect.left < 0) { picker.style.left = '0'; picker.style.right = 'auto'; }
                    else if (rect.right > vw) { picker.style.right = '0'; picker.style.left = 'auto'; }
                    // If picker goes below viewport, try to open upwards
                    const vh = window.innerHeight || document.documentElement.clientHeight;
                    if (rect.bottom > vh && rect.height < vh) {
                        picker.style.top = 'auto';
                        picker.style.bottom = '25px';
                    }
                } catch(e) {}
            });

            // Event handling like column picker
            ['mousedown','pointerdown','click'].forEach(evt => picker.addEventListener(evt, e => e.stopPropagation(), true));
            picker.addEventListener('click', e => {
                const sw = e.target.closest && e.target.closest('.swatch');
                if (sw) { applySectionColor(sectionTitle, sw.getAttribute('data-c')); picker.remove(); }
            }, true);
            function onDoc(ev){ if(!picker.contains(ev.target) && ev.target!==menuBtn){ picker.remove(); document.removeEventListener('mousedown', onDoc, true);} }
            setTimeout(()=> document.addEventListener('mousedown', onDoc, true), 0);
        }

        function applySectionColor(sectionTitle, color){
            sectionTitle.style.background = color;
            sectionTitle.setAttribute('data-color', color);
        }
        
        function changeSectionColor(color, optionElement) {
            const sectionTitle = optionElement.closest('.section-title');
            sectionTitle.style.background = color;
            sectionTitle.setAttribute('data-color', color);
            optionElement.closest('.section-color-picker').remove();
        }
        
        // === TEMPLATE MANAGEMENT FUNCTIONS ===
        // Track the currently loaded template name for sane save behavior
        window.currentTemplateName = window.currentTemplateName || '';

        function deepClone(obj){ try { return JSON.parse(JSON.stringify(obj)); } catch(_) { return obj; } }
        // Remove heavy image data for localStorage (keeps structure so it still loads)
        function stripImagesForStorage(layout){
            const clone = deepClone(layout);
            try {
                (clone.columns||[]).forEach(col => {
                    const areas = col.contentAreas || [];
                    areas.forEach(area => {
                        const sectLists = [];
                        if (Array.isArray(area.sections)) sectLists.push(area.sections);
                        if (Array.isArray(area.splitParts)) area.splitParts.forEach(p=> sectLists.push(p.sections||[]));
                        sectLists.forEach(list => (list||[]).forEach(sec => {
                            (sec.boxes||[]).forEach(box => { if (box && box.isImage) { box.imageSrc = ''; } });
                        }));
                    });
                });
            } catch(_){}
            return clone;
        }
        function saveTemplate() {
            const t = translations[currentLanguage];
            const templates = getStoredTemplates();
            // Prefer the current loaded name when present
            const suggested = window.currentTemplateName && typeof window.currentTemplateName === 'string'
                ? window.currentTemplateName
                : `${t.defaultTemplateName} ${new Date().toLocaleDateString()}`;

            let name = prompt(t.promptTemplateName, suggested);
            if (!name) return;

            // Helper to find a free name with (n) suffix
            function nextName(base) {
                let i = 1; let candidate = base;
                while (templates[candidate]) { i++; candidate = `${base} (${i})`; }
                return candidate;
            }

            if (templates[name]) {
                // Ask before overwriting; if declined, pick next available sequential name
                const overwrite = confirm(t.confirmOverwriteTemplate ? t.confirmOverwriteTemplate.replace('{name}', name) : `Template "${name}" √ºberschreiben?`);
                if (!overwrite) name = nextName(name);
            }

            const templateData = { name, date: new Date().toISOString(), categories, layout: extractLayoutData() };
            templates[name] = templateData;
            // localStorage write guarded; full template always downloaded below
            try { localStorage.setItem('architectureTemplates', JSON.stringify(templates)); } catch(_) {}
            window.currentTemplateName = name; // remember last saved name

            downloadTemplateAsFile(templateData);
            alert(t.alertTemplateSaved.replace('{name}', name));
            updateTemplateList();
        }
        
        function getStoredTemplates() { return JSON.parse(localStorage.getItem('architectureTemplates') || '{}'); }
        
// Extract current layout data
        function extractLayoutData() {
            const columns = [];
            document.querySelectorAll('.column').forEach(column => {
                const columnData = {
                    id: column.getAttribute('data-column-id'),
                    title: column.querySelector('.column-header').childNodes[0].textContent.trim(),
                    width: column.offsetWidth + 'px',
                    splitState: column.getAttribute('data-split-state') || 'normal',
                    splitParts: parseInt(column.getAttribute('data-split-parts') || (function(ss){ if(ss==='split-2') return 2; if(ss==='split-3') return 3; return 1; })(column.getAttribute('data-split-state')||'normal'), 10),
                    contentAreas: []
                };
                
                const contentWrapper = column.querySelector('.column-content');

                function serializeSectionNodes(nodes) {
                    const areaData = { sections: [] };
                    nodes.forEach(section => {
                        const sectionTitle = section.querySelector('.section-title');
                        const sectionData = {
                            title: sectionTitle.childNodes[0].textContent.trim(),
                            color: sectionTitle.getAttribute('data-color') || '#8B4513',
                                boxes: Array.from(section.querySelectorAll('.app-box')).map(box => {
                                    const isImage = box.classList.contains('image-box');
                                    if (isImage) {
                                        const img = box.querySelector('img');
                                        return {
                                            isImage: true,
                                            imageSrc: img ? img.getAttribute('src') : '',
                                            width: ['full-width', 'half-width'].find(cls => box.classList.contains(cls)) || 'full-width'
                                        };
                                    } else {
                                        return {
                                            isImage: false,
                                            text: box.childNodes[0].textContent.trim(),
                                            type: Object.keys(categories).find(type => box.classList.contains(type)) || 'saas',
                                            width: ['full-width', 'half-width'].find(cls => box.classList.contains(cls)) || 'full-width',
                                            lines: box.dataset.lines || '1',
                                            textColor: box.style.color || ''
                                        };
                                    }
                                })
                        };
                        areaData.sections.push(sectionData);
                    });
                    return areaData;
                }

                // New flexible serialization: walk children, supporting multiple split blocks
                if (contentWrapper) {
                    let buffer = [];
                    const flush = () => { if (buffer.length) { columnData.contentAreas.push(serializeSectionNodes(buffer)); buffer = []; } };
                    Array.from(contentWrapper.children).forEach(ch => {
                        if (ch.classList && ch.classList.contains('section-group')) {
                            buffer.push(ch);
                        } else if (ch.classList && ch.classList.contains('column-split-content')) {
                            flush();
                            const parts = [];
                            ch.querySelectorAll(':scope > .column-part').forEach(part => {
                                const sections = Array.from(part.querySelectorAll(':scope > .section-group'));
                                parts.push(serializeSectionNodes(sections));
                            });
                            columnData.contentAreas.push({ splitParts: parts });
                        }
                    });
                    flush();
                }
                columns.push(columnData);
            });
            return { columns };
        } 
        
        function downloadTemplateAsFile(templateData) {
            const blob = new Blob([JSON.stringify(templateData, null, 2)], { type: 'application/json' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `${templateData.name.replace(/[^a-z0-9]/gi, '_')}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }
        
        function showLoadTemplateModal() {
            document.getElementById('loadTemplateModal').classList.add('show');
            updateTemplateList();
        }

        // Built-in templates
        const builtinTemplates = {
            organigram: {
                name: 'Organigramm',
                categories: {
                    mgmt: { name:'Management', color1:'#8B4513', color2:'#8B4513' },
                    eng:  { name:'Engineering', color1:'#667eea', color2:'#764ba2' },
                    sales:{ name:'Sales', color1:'#84fab0', color2:'#8fd3f4' },
                    ops:  { name:'Operations', color1:'#f093fb', color2:'#f5576c' },
                    hr:   { name:'HR', color1:'#f6d365', color2:'#fda085' }
                },
                layout: {
                    columns: [
                        { id: '1', title:'Organisation', width:'400px', splitState:'normal', splitParts:1, contentAreas:[
                            { sections:[ { title:'CEO', color:'#8B4513', boxes:[{ isImage:false, text:'Max Mustermann', type:'mgmt', width:'full-width', lines:'1'}] } ] },
                            { splitParts:[
                                { sections:[ { title:'Engineering', color:'#667eea', boxes:[{ isImage:false, text:'Team A', type:'eng', width:'full-width', lines:'1'},{ isImage:false, text:'Team B', type:'eng', width:'full-width', lines:'1'}] } ] },
                                { sections:[ { title:'Sales', color:'#84fab0', boxes:[{ isImage:false, text:'DACH', type:'sales', width:'full-width', lines:'1'},{ isImage:false, text:'EMEA', type:'sales', width:'full-width', lines:'1'}] } ] },
                                { sections:[ { title:'Operations', color:'#f093fb', boxes:[{ isImage:false, text:'IT Ops', type:'ops', width:'full-width', lines:'1'},{ isImage:false, text:'Finance Ops', type:'ops', width:'full-width', lines:'1'}] } ] }
                            ]},
                            { sections:[ { title:'HR', color:'#f6d365', boxes:[{ isImage:false, text:'Recruiting', type:'hr', width:'half-width', lines:'1'},{ isImage:false, text:'People & Culture', type:'hr', width:'half-width', lines:'1'}] } ] }
                        ]}
                    ]
                }
            },
            office: {
                name: 'Office Map',
                categories: {
                    space:{ name:'Space', color1:'#E0E0E0', color2:'#E0E0E0' },
                    room: { name:'Room',  color1:'#B0BEC5', color2:'#B0BEC5' },
                    desk: { name:'Desk',  color1:'#90CAF9', color2:'#90CAF9' }
                },
                layout: {
                    columns: [
                        { id:'1', title:'Etage 3', splitState:'normal', splitParts:1, contentAreas:[
                            { splitParts:[
                                { sections:[ { title:'Open Space', color:'#E0E0E0', boxes:[{ isImage:false, text:'Desk 1', type:'desk', width:'half-width', lines:'1'},{ isImage:false, text:'Desk 2', type:'desk', width:'half-width', lines:'1'},{ isImage:false, text:'Desk 3', type:'desk', width:'half-width', lines:'1'},{ isImage:false, text:'Desk 4', type:'desk', width:'half-width', lines:'1'}] } ] },
                                { sections:[ { title:'Meeting', color:'#B0BEC5', boxes:[{ isImage:false, text:'Room A', type:'room', width:'full-width', lines:'1'}] } ] }
                            ]},
                            { splitParts:[
                                { sections:[ { title:'Open Space', color:'#E0E0E0', boxes:[{ isImage:false, text:'Desk 5', type:'desk', width:'half-width', lines:'1'},{ isImage:false, text:'Desk 6', type:'desk', width:'half-width', lines:'1'}] } ] },
                                { sections:[ { title:'K√ºche', color:'#B0BEC5', boxes:[{ isImage:false, text:'Coffee', type:'room', width:'full-width', lines:'1'}] } ] }
                            ]}
                        ]}
                    ]
                }
            },
            kanban: {
                name: 'Kanban',
                categories: {
                    todo: { name:'To Do', color1:'#FFAB91', color2:'#FFAB91' },
                    doing:{ name:'Doing', color1:'#FFD54F', color2:'#FFD54F' },
                    done: { name:'Done',  color1:'#A5D6A7', color2:'#A5D6A7' }
                },
                layout: {
                    columns: [
                        { id:'1', title:'To Do', splitState:'normal', splitParts:1, contentAreas:[ { sections:[ { title:'Backlog', color:'#FFAB91', boxes:[{ isImage:false, text:'Task 1', type:'todo', width:'full-width', lines:'1'},{ isImage:false, text:'Task 2', type:'todo', width:'full-width', lines:'1'}] } ] } ] },
                        { id:'2', title:'Doing', splitState:'normal', splitParts:1, contentAreas:[ { sections:[ { title:'In Arbeit', color:'#FFD54F', boxes:[{ isImage:false, text:'Implement Feature', type:'doing', width:'full-width', lines:'1'}] } ] } ] },
                        { id:'3', title:'Done',  splitState:'normal', splitParts:1, contentAreas:[ { sections:[ { title:'Abgeschlossen', color:'#A5D6A7', boxes:[{ isImage:false, text:'Review OK', type:'done', width:'full-width', lines:'1'}] } ] } ] }
                    ]
                }
            }
        };

        function loadBuiltinTemplate(key){
            const tpl = builtinTemplates[key]; if(!tpl) return;
            categories = tpl.categories || categories;
            updateCategoryStyles(); updateCategoryDropdown(); updateLegend();
            applyLayoutData(tpl.layout);
            window.currentTemplateName = tpl.name || key;
            closeModal('loadTemplateModal');
        }
        
        function updateTemplateList() {
            const list = document.getElementById('templateList');
            const templates = getStoredTemplates();
            const t = translations[currentLanguage];
            list.innerHTML = '';
            
            if (Object.keys(templates).length === 0) {
                list.innerHTML = `<div style="text-align: center; color: #666; padding: 20px;">${t.noSavedTemplates}</div>`;
                return;
            }
            
            for (const [name, template] of Object.entries(templates)) {
                const item = document.createElement('div');
                item.className = 'template-item';
                item.innerHTML = `
                    <div class="template-info" onclick="loadTemplate('${name}')">
                        <div class="template-name">${template.name}</div>
                        <div class="template-date">${new Date(template.date).toLocaleString()}</div>
                    </div>
                    <div class="template-actions">
                        <button class="btn btn-primary small-btn" onclick="loadTemplate('${name}')">${t.loadTemplate.split(' ')[0]}</button>
                        <button class="btn btn-warning small-btn" onclick="downloadStoredTemplate('${name}')">Download</button>
                        <button class="btn btn-danger small-btn" onclick="deleteTemplate('${name}')">${t.delete}</button>
                    </div>`;
                list.appendChild(item);
            }
        }
        
        function loadTemplate(templateName) {
            const t = translations[currentLanguage];
            const templates = getStoredTemplates();
            const template = templates[templateName];
            if (!template) { alert(t.alertTemplateNotFound); return; }
            if (!confirm(t.confirmLoadTemplate.replace('{name}', templateName))) return;
            
            categories = template.categories || categories;
            updateCategoryStyles(); updateCategoryDropdown(); updateLegend();
            applyLayoutData(template.layout);
            window.currentTemplateName = template.name || templateName;
            
            closeModal('loadTemplateModal');
            // HINWEIS: Die Erfolgsmeldung wurde hier entfernt (auskommentiert).
            // alert(t.alertTemplateLoaded.replace('{name}', templateName)); 
        }
        
// Apply layout data
        function applyLayoutData(layoutData) {
            const container = document.getElementById('mainContainer');
            container.innerHTML = ''; // Leert den Container f√ºr das neue Layout
            const t = translations[currentLanguage];

            if (layoutData.columns) {
                layoutData.columns.forEach(columnData => {
                    const column = createColumnElement(columnData.title, columnData.id);
                    if(columnData.width) column.style.width = columnData.width;

                    const splitState = columnData.splitState || 'normal';
                    column.setAttribute('data-split-state', splitState);
                    const splitParts = parseInt((columnData.splitParts != null ? columnData.splitParts : (splitState==='split-2'?2:(splitState==='split-3'?3:1))), 10);
                    column.setAttribute('data-split-parts', String(splitParts));
                    
                    const contentWrapper = column.querySelector('.column-content');
                    contentWrapper.innerHTML = ''; // Leert den Standard-Inhalt, der von createColumnElement kommt

                    // Flexible builder: if contentAreas contains splitParts, render sequential blocks
                    const __areas = Array.isArray(columnData.contentAreas) ? columnData.contentAreas : [];
                    const __hasFlexible = __areas.some(a => a && Array.isArray(a.splitParts));
                    if (__hasFlexible) {
                        __areas.forEach(area => {
                            if (area && Array.isArray(area.splitParts)) {
                                const splitContainer = document.createElement('div');
                                splitContainer.className = 'column-split-content';
                                splitContainer.setAttribute('draggable', 'true');
                                area.splitParts.forEach(partArea => {
                                    const partDiv = document.createElement('div');
                                    partDiv.className = 'column-part';
                                    let sectionsHtml = '';
                                    (partArea.sections || []).forEach(sectionData => { sectionsHtml += buildSectionHtmlEx(sectionData, t); });
                                    partDiv.innerHTML = sectionsHtml;
                                    splitContainer.appendChild(partDiv);
                                });
                                contentWrapper.appendChild(splitContainer);
                            } else if (area && Array.isArray(area.sections)) {
                                let sectionsHtml = '';
                                area.sections.forEach(sectionData => { sectionsHtml += buildSectionHtmlEx(sectionData, t); });
                                contentWrapper.innerHTML += sectionsHtml;
                            }
                        });
                        contentWrapper.innerHTML += `<button class=\"add-section-btn\" onclick=\"addSection(this)\">+ ${t.newSection}</button>`;
                    } else {
                    // Baut die Spaltenstruktur (normal oder geteilt) auf
                    if (splitParts === 1 || splitState === 'normal') {
                        // F√ºr normale Spalten gibt es nur einen Inhaltsbereich
                        const areaData = columnData.contentAreas[0] || { sections: [] };
                        let sectionsHtml = '';
                        areaData.sections.forEach(sectionData => {
                            sectionsHtml += buildSectionHtmlEx(sectionData, t);
                        });
                        contentWrapper.innerHTML = sectionsHtml;
                    
                    } else {
                        // F√ºr geteilte Spalten wird die Split-Struktur erstellt
                        const parts = parseInt(columnData.splitParts || (splitState==='split-2'?2:(splitState==='split-3'?3:1)), 10);
                        const partClass = 'column-part';

                        const splitContainer = document.createElement('div');
                        splitContainer.className = 'column-split-content';
                        splitContainer.setAttribute('draggable', 'true');
                        // Optional Top-/Bottom-Bereiche um die Splits herum
                        const totalAreas = (columnData.contentAreas || []).length;
                        let startIdx = 0;
                        let endIdxOffset = 0;
                        if (totalAreas === parts + 2) { startIdx = 1; endIdxOffset = 1; }
                        else if (totalAreas === parts + 1) { startIdx = 1; endIdxOffset = 0; }
                        if (startIdx === 1) {
                            const topArea = columnData.contentAreas[0] || { sections: [] };
                            let topHtml = '';
                            topArea.sections.forEach(s => topHtml += buildSectionHtmlEx(s, t));
                            contentWrapper.innerHTML += topHtml;
                        }

                        for (let i = 0; i < parts; i++) {
                            const partDiv = document.createElement('div');
                            partDiv.className = partClass;

                            const areaData = columnData.contentAreas[i + (typeof startIdx !== 'undefined' ? startIdx : 0)] || { sections: [] };
                            let sectionsHtml = '';
                            areaData.sections.forEach(sectionData => {
                                sectionsHtml += buildSectionHtmlEx(sectionData, t);
                            });
                            partDiv.innerHTML = sectionsHtml;
                            splitContainer.appendChild(partDiv);
                        }
                        contentWrapper.appendChild(splitContainer);
                        if (typeof endIdxOffset !== 'undefined' && endIdxOffset === 1) {
                            const totalAreas2 = (columnData.contentAreas || []).length;
                            const bottomArea = columnData.contentAreas[totalAreas2 - 1] || { sections: [] };
                            let bottomHtml = '';
                            bottomArea.sections.forEach(s => bottomHtml += buildSectionHtmlEx(s, t));
                            contentWrapper.innerHTML += bottomHtml;
                        }
                    }
                    }
                    updateSplitCounterDisplay(column);
                    container.appendChild(column);
                });
            }
            // placeholders entfernt
            // F√ºgt am Ende den "+" Button f√ºr neue Spalten hinzu
            const addBtn = document.createElement('div');
            addBtn.className = 'add-column';
            addBtn.onclick = addNewColumn;
            addBtn.innerHTML = '<span>+</span>';
            container.appendChild(addBtn);
        }

// HELFER-FUNKTION: Baut das HTML f√ºr eine einzelne Sektion (wird von applyLayoutData genutzt)
        function buildSectionHtml(sectionData, t) {
            let boxesHtml = '';
            if (sectionData.boxes && Array.isArray(sectionData.boxes)) {
                sectionData.boxes.forEach(boxData => {
                    const lines = parseInt(boxData.lines, 10) || 1;
                    const minHeight = (lines * 26) + 12;
                    const dataLinesAttr = `data-lines="${lines}"`;

                    let styleString = `min-height: ${minHeight}px;`;
                    if (boxData.textColor) styleString += ` color: ${boxData.textColor};`;
                    const styleAttr = `style="${styleString}"`;

                    boxesHtml += `
                        <div class="app-box ${boxData.type || 'saas'} ${boxData.width || 'full-width'}" draggable="true" ${dataLinesAttr} ${styleAttr}>
                            ${boxData.text}
                            <button class="delete-btn" onclick="deleteBox(this)">√ó</button>
                            <button class="resize-btn" onclick="toggleBoxWidth(this)">‚Üî</button>
                        </div>`;
                });
            }
            const sectionColor = sectionData.color || '#8B4513';
            return `
                <div class="section-group" draggable="true">
                    <div class="section-title" style="background: ${sectionColor}" data-color="${sectionColor}">
                        ${sectionData.title}
                        <span class="section-delete" onclick="deleteSection(this)" title="${t.deleteSectionTooltip}">√ó</span>
                        <span class="section-menu" onclick="showSectionColorPicker(this)">üé®</span>
                    </div>
                    <div class="box-container">${boxesHtml}</div>
                </div>`;
        }  
        
        // Extended builder supporting image boxes in templates
        function buildSectionHtmlEx(sectionData, t) {
            let boxesHtml = '';
            if (sectionData.boxes && Array.isArray(sectionData.boxes)) {
                sectionData.boxes.forEach(boxData => {
                    if (boxData && boxData.isImage) {
                        boxesHtml += `
                            <div class="app-box image-box ${boxData.width || 'full-width'}" draggable="true">
                                <img src="${boxData.imageSrc || ''}" alt="image" />
                                <button class="delete-btn" onclick="deleteBox(this)">x</button>
                                <button class="resize-btn" onclick="toggleBoxWidth(this)">\u001d</button>
                            </div>`;
                    } else {
                        const lines = parseInt((boxData && boxData.lines) || '1', 10) || 1;
                        const minHeight = (lines * 26) + 12;
                        const dataLinesAttr = `data-lines="${lines}"`;
                        let styleString = `min-height: ${minHeight}px;`;
                        if (boxData && boxData.textColor) styleString += ` color: ${boxData.textColor};`;
                        const styleAttr = `style="${styleString}"`;
                        boxesHtml += `
                            <div class="app-box ${(boxData && boxData.type) || 'saas'} ${(boxData && boxData.width) || 'full-width'}" draggable="true" ${dataLinesAttr} ${styleAttr}>
                                ${(boxData && boxData.text) || ''}
                                <button class="delete-btn" onclick="deleteBox(this)">x</button>
                                <button class="resize-btn" onclick="toggleBoxWidth(this)">\u001d</button>
                            </div>`;
                    }
                });
            }
            const sectionColor = sectionData.color || '#8B4513';
            return `
                <div class="section-group" draggable="true">
                    <div class="section-title" style="background: ${sectionColor}" data-color="${sectionColor}">
                        ${sectionData.title}
                        <span class="section-delete" onclick="deleteSection(this)" title="${t.deleteSectionTooltip}">x</span>
                        <span class="section-menu" onclick="showSectionColorPicker(this)">?</span>
                    </div>
                    <div class="box-container">${boxesHtml}</div>
                </div>`;
        }
        
        function downloadStoredTemplate(templateName) {
            const template = getStoredTemplates()[templateName];
            if (template) downloadTemplateAsFile(template);
        }
        
        function deleteTemplate(templateName) {
            if (confirm(translations[currentLanguage].confirmDeleteCategory.replace('{name}', templateName))) {
                const templates = getStoredTemplates();
                delete templates[templateName];
            try {
                localStorage.setItem('architectureTemplates', JSON.stringify(templates));
            } catch(e) {
                console.warn('LocalStorage quota exceeded', e);
                // Keine Reduktion der Bilddaten ‚Äì volle Vorlage bleibt im Download erhalten
                alert((translations[currentLanguage] && translations[currentLanguage].alertTemplateSaved ? translations[currentLanguage].alertTemplateSaved : 'Template gespeichert und heruntergeladen!').replace('{name}', name) + "\n(Hinweis: Speicherung im Browser-Speicher ist fehlgeschlagen ‚Äì Limit √ºberschritten.)");
            }
                updateTemplateList();
            }
        }
        
        function loadTemplateFromFile() {
            const fileInput = document.getElementById('templateFileInput');
            const file = fileInput.files[0];
            const t = translations[currentLanguage];
            if (!file) { alert(t.alertChooseFile); return; }
            
            const reader = new FileReader();
            reader.onload = e => {
                try {
                    const templateData = JSON.parse(e.target.result);
                    if (!templateData.categories || !templateData.layout) throw new Error('Invalid format');
                    if (!confirm(t.confirmLoadFromFile.replace('{name}', templateData.name))) return;
                    
                    categories = templateData.categories;
                    updateCategoryStyles(); updateCategoryDropdown(); updateLegend();
                    applyLayoutData(templateData.layout);
                    window.currentTemplateName = templateData.name || '';
                    
                    closeModal('loadTemplateModal');
                    // HINWEIS: Die Erfolgsmeldung wurde hier entfernt (auskommentiert).
                    // alert(t.alertFileLoaded.replace('{name}', templateData.name));
                } catch (error) {
                    alert(t.alertFileLoadError + error.message);
                }
            };
            reader.readAsText(file);
        }    
        
        // === PNG EXPORT FUNCTIONS ===
        function exportToPNG() {
            const container = document.querySelector('.main-container');
            const t = translations[currentLanguage];
            
            const button = event.target;
            const originalText = button.textContent;
            button.textContent = t.exporting;
            button.disabled = true;
            
            hideExportUIElements();
            
            setTimeout(() => {
                html2canvas(container, {
                    scale: 2, backgroundColor: '#ffffff',
                    width: Math.max(container.scrollWidth, container.offsetWidth),
                    height: Math.max(container.scrollHeight, container.offsetHeight)
                }).then(canvas => {
                    showExportUIElements();
                    const a = document.createElement('a');
                    a.href = canvas.toDataURL('image/png', 0.95);
                    a.download = 'enterprise-architecture-' + new Date().toISOString().split('T')[0] + '.png';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    
                    button.textContent = originalText;
                    button.disabled = false;
                    alert(t.alertExportSuccess);
                }).catch(error => {
                    showExportUIElements();
                    button.textContent = originalText;
                    button.disabled = false;
                    alert(t.alertExportError + error.message);
                });
            }, 100);
        }
        
        function hideExportUIElements() {
            // Mark document for screenshot-specific CSS rules
            document.documentElement.setAttribute('data-screenshot', 'true');

            // Hide interactive UI for clean export
            document.querySelectorAll('.add-section-btn').forEach(el => el.style.display = 'none');
            document.querySelectorAll('.header-btn, .split-counter, .resize-handle').forEach(el => el.style.visibility = 'hidden');
            document.querySelectorAll('.section-delete, .section-menu').forEach(el => el.style.visibility = 'hidden');
            document.querySelectorAll('.column-color-picker, .section-color-picker').forEach(el => el.style.display = 'none');
            document.querySelectorAll('.section-group').forEach(section => { section.style.border = 'none'; section.style.background = 'transparent'; });
        }
        
        function showExportUIElements() {
            // Remove screenshot flag
            document.documentElement.removeAttribute('data-screenshot');

            // Restore interactive UI
            document.querySelectorAll('.add-section-btn').forEach(el => el.style.display = 'block');
            document.querySelectorAll('.header-btn').forEach(el => el.style.visibility = 'visible');
            document.querySelectorAll('.split-counter, .resize-handle').forEach(el => el.style.visibility = 'visible');
            document.querySelectorAll('.section-delete, .section-menu').forEach(el => el.style.visibility = 'visible');
            document.querySelectorAll('.section-group').forEach(section => { section.style.border = '2px dashed #999'; section.style.background = ''; });
        }
    </script>

<!-- Injected from Explainator2: Formatting Modal -->
<div class="modal" id="formattingModal" data-target="columns">
        <div class="modal-content">
            <div class="modal-header">üî† Schriftart anpassen</div>
            <div class="formatting-target-selector">
                <button class="btn active" onclick="switchFormattingTarget('columns', this)">Spalten</button>
                <button class="btn" onclick="switchFormattingTarget('sections', this)">Sections</button>
                <button class="btn" onclick="switchFormattingTarget('boxes', this)">Boxen</button>
            </div>
            <div class="modal-body">
                <label for="fontFamily">Schriftart:</label>
                <select id="fontFamily">
                    <option value="'Segoe UI', Arial, sans-serif">Segoe UI (Default)</option>
                    <option value="Arial, sans-serif">Arial</option>
                    <option value="'Times New Roman', Times, serif">Times New Roman</option>
                    <option value="'Courier New', Courier, monospace">Courier New</option>
                    <option value="Verdana, sans-serif">Verdana</option>
                    <option value="Georgia, serif">Georgia</option>
                </select>
                <label for="fontSize">Schriftgr√∂√üe (px):</label>
                <input type="number" id="fontSize" value="14" min="8" max="32">
                <div style="display: flex; gap: 20px; margin-top: 15px;">
                    <label class="checkbox-label"><input type="checkbox" id="fontBold"><strong>Fett</strong></label>
                    <label class="checkbox-label"><input type="checkbox" id="fontItalic"><em>Kursiv</em></label>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" onclick="saveCurrentFontStyle()">Anwenden & Schlie√üen</button>
                <button class="btn btn-danger" onclick="closeModal('formattingModal')">Abbrechen</button>
            </div>
        </div>
    </div>

<script>
(function(){
  var styleEl = document.getElementById('font-styles');
  if(!styleEl){ styleEl = document.createElement('style'); styleEl.id='font-styles'; document.head.appendChild(styleEl); }

  window.fontSettings = window.fontSettings || {
    columns: { family:"'Segoe UI', Arial, sans-serif", size:14, bold:true, italic:false },
    sections:{ family:"'Segoe UI', Arial, sans-serif", size:12, bold:true, italic:false },
    boxes:   { family:"'Segoe UI', Arial, sans-serif", size:11, bold:false, italic:false }
  };

  function toCss(cfg){
    return "font-family:"+cfg.family+" !important; font-size:"+cfg.size+"px !important; font-weight:"+(cfg.bold?'700':'400')+" !important; font-style:"+(cfg.italic?'italic':'normal')+" !important;";
  }

  window.applyAllFontStyles = function(){
    var css = ""
      + ".column .column-header, .column .column-header input { " + toCss(window.fontSettings.columns) + " }\n"
      + ".section-title, .section-title input { " + toCss(window.fontSettings.sections) + " }\n"
      + ".app-box { " + toCss(window.fontSettings.boxes) + " }\n";
    styleEl.textContent = css;
  };

  window.showFormattingModal = function(){
    var m=document.getElementById('formattingModal'); if(m){ m.classList.add('show'); }
    // Load current target's values if selector exists
    var t = (m && m.getAttribute('data-target')) || 'columns';
    var cfg = window.fontSettings[t];
    var fam=document.getElementById('fontFamily'), size=document.getElementById('fontSize'), b=document.getElementById('fontBold'), i=document.getElementById('fontItalic');
    if(fam) fam.value = cfg.family;
    if(size) size.value = cfg.size;
    if(b) b.checked = !!cfg.bold;
    if(i) i.checked = !!cfg.italic;
  };

  window.switchFormattingTarget = function(target, btn){
    var m=document.getElementById('formattingModal'); if(m){ m.setAttribute('data-target', target); }
    if(btn && btn.parentElement){ btn.parentElement.querySelectorAll('.btn').forEach(function(x){ x.classList.remove('active'); }); btn.classList.add('active'); }
    // sync form
    var cfg = window.fontSettings[target];
    var fam=document.getElementById('fontFamily'), size=document.getElementById('fontSize'), b=document.getElementById('fontBold'), i=document.getElementById('fontItalic');
    if(fam) fam.value = cfg.family;
    if(size) size.value = cfg.size;
    if(b) b.checked = !!cfg.bold;
    if(i) i.checked = !!cfg.italic;
  };

  window.saveCurrentFontStyle = function(){
    var m=document.getElementById('formattingModal'); var t=(m && m.getAttribute('data-target'))||'columns';
    var fam=document.getElementById('fontFamily'), size=document.getElementById('fontSize'), b=document.getElementById('fontBold'), i=document.getElementById('fontItalic');
    var cfg=window.fontSettings[t];
    if(fam) cfg.family=fam.value||cfg.family;
    if(size){ var v=parseInt(size.value,10); if(!isNaN(v)) cfg.size=v; }
    if(b) cfg.bold=!!b.checked; if(i) cfg.italic=!!i.checked;
    window.applyAllFontStyles();
    if(m) m.classList.remove('show');
  };

  // Apply once
  window.applyAllFontStyles();
})();
</script>


<script>
(function(){
  if (typeof window.applyHeaderColor !== 'function') {
    window.applyHeaderColor = function(header, color){
      if(!header) return;
      header.style.background = 'linear-gradient(to bottom,'+color+','+color+')';
      var col = header.closest('.column'); if(col) col.style.borderColor = color;
    };
  }
  // Delegated handler to ensure button always works for dynamic columns
  if (!window.__ea_color_delegate__) {
    window.__ea_color_delegate__ = true;
    document.addEventListener('click', function(e){
      var btn = e.target && e.target.closest && e.target.closest('.color-column-btn');
      if (!btn) return;
      e.preventDefault(); e.stopPropagation();
      try { if (typeof showColumnColorPicker === 'function') showColumnColorPicker(btn); } catch(err) { console.warn(err); }
    }, true);
  }
})();
</script>

<script>

window.showColumnColorPicker = function(btn){
  try{
    // Prevent header drag from swallowing events
    btn.setAttribute('draggable','false');
    btn.addEventListener('pointerdown', function(ev){ ev.stopPropagation(); ev.preventDefault(); }, { once:true });
  }catch(e){}

  // Close other pickers
  document.querySelectorAll('.column-color-picker').forEach(function(p){ p.remove(); });

  var header = btn.closest('.column-header');
  if(!header) return;
  header.style.position = header.style.position || 'relative';

  var p = document.createElement('div');
  p.className = 'column-color-picker';
  var headerColors = ['#8B4513','#A0522D','#CD853F','#D2691E','#FF9800','#FFC107','#FF5722',
                      '#2196F3','#1E88E5','#64B5F6','#00BCD4','#009688','#4CAF50','#8BC34A',
                      '#9C27B0','#AB47BC','#F44336','#E91E63','#607D8B','#455A64',
                      '#000000','#333333','#666666','#999999','#CCCCCC','#FFFFFF'];
  p.innerHTML = headerColors.map(function(c){return '<div class="swatch" data-c="'+c+'" style="background:'+c+'" title="'+c+'"></div>';}).join('')
    + '<div class="row" style="margin-top:8px;"><input type="color" id="col-custom" value="#8B4513" style="flex:0 0 40px;border:none;padding:0;"><button class="btn small-btn">√úbernehmen</button></div>';

  // Stop events inside picker from bubbling to global handlers
  ['mousedown','pointerdown','click'].forEach(function(evt){
    p.addEventListener(evt, function(e){ e.stopPropagation(); }, true);
    btn.addEventListener(evt, function(e){ e.stopPropagation(); }, true);
  });

  header.appendChild(p);
  requestAnimationFrame(function(){ p.classList.add('show'); });

  p.addEventListener('click', function(e){
    var sw = e.target.closest && e.target.closest('.swatch');
    if(sw){ applyHeaderColor(header, sw.getAttribute('data-c')); p.remove(); return; }
    if(e.target && e.target.tagName === 'BUTTON'){
      var c = p.querySelector('#col-custom').value; applyHeaderColor(header, c); p.remove(); return;
    }
  }, true);

  // Close on outside mousedown (but not if inside picker)
  function onDoc(ev){
    if(!p.contains(ev.target) && ev.target!==btn){
      p.remove(); document.removeEventListener('mousedown', onDoc, true);
    }
  }
  setTimeout(function(){ document.addEventListener('mousedown', onDoc, true); }, 0);
};

</script>

<script>
(function(){
  if(!window.__ea_color_delegate_v2__){
    window.__ea_color_delegate_v2__ = true;
    document.addEventListener('click', function(e){
      var b = e.target && e.target.closest && e.target.closest('.color-column-btn');
      if(!b) return;
      e.preventDefault(); e.stopPropagation();
      try{ (window.showColumnColorPicker||showColumnColorPicker)(b); }catch(err){ console.warn(err); }
    }, true);
    document.addEventListener('pointerdown', function(e){
      var b = e.target && e.target.closest && e.target.closest('.color-column-btn');
      if(b){ e.preventDefault(); e.stopPropagation(); }
    }, true);
  }
})();
</script>


<script>
(function(){
  function ensureColorButton(header){
    if(!header) return;
    if(header.querySelector('.color-column-btn')) return;
    var btn = document.createElement('span');
    btn.className = 'header-btn color-column-btn';
    btn.title = 'Header-Farbe √§ndern';
    btn.setAttribute('draggable','false');
    btn.textContent = 'üñåÔ∏è';
    // Guard: prevent drag handlers from eating click
    btn.addEventListener('pointerdown', function(ev){ ev.stopPropagation(); }, true);
    btn.addEventListener('click', function(e){
      e.preventDefault(); e.stopPropagation();
      try { (window.showColumnColorPicker||showColumnColorPicker)(btn); } catch(err){ console.warn(err); }
    }, true);
    header.appendChild(btn);
  }
  function ensureAll(){
    document.querySelectorAll('.column-header').forEach(ensureColorButton);
  }
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', ensureAll, { once:true });
  } else {
    ensureAll();
  }
  // Observe dynamic changes to re-add icon when columns are re-rendered
  try{
    var obs = new MutationObserver(function(muts){
      for (var i=0;i<muts.length;i++){
        var m = muts[i];
        for (var j=0;j<(m.addedNodes?m.addedNodes.length:0); j++){
          var n = m.addedNodes[j];
          if(n.nodeType===1){
            if (n.classList && n.classList.contains('column-header')) ensureColorButton(n);
            else if (n.querySelectorAll) n.querySelectorAll('.column-header').forEach(ensureColorButton);
          }
        }
      }
    });
    obs.observe(document.body, { childList:true, subtree:true });
  }catch(e){}
})();
</script>


<script>
window.enterScreenshotMode = function(){ document.body.classList.add('screenshot-mode'); };
window.exitScreenshotMode = function(){ document.body.classList.remove('screenshot-mode'); };
window.addEventListener('vc:screenshot:start', function(){ document.body.classList.add('screenshot-mode'); });
window.addEventListener('vc:screenshot:end', function(){ document.body.classList.remove('screenshot-mode'); });
</script>


<script>
(function(){
  if (window.__colorBrushGuardInstalled__) return;
  window.__colorBrushGuardInstalled__ = true;
  const stop = ev => { ev.stopPropagation(); };
  ['pointerdown','mousedown','dragstart'].forEach(evt => {
    document.addEventListener(evt, function(ev){
      if (ev.target && ev.target.closest && ev.target.closest('.color-column-btn, .column-color-picker')) {
        // prevent column header drag when interacting with the color UI
        ev.preventDefault();
        ev.stopPropagation();
      }
    }, true);
  });
})();
</script>

<script>
    // Erm√∂glicht das Bearbeiten von Box-Texten per Doppelklick
    document.getElementById('mainContainer').addEventListener('dblclick', function(e) {
        const box = e.target.closest('.app-box');
        if (!box) return;

        // Verhindern, dass ein Input-Feld in sich selbst erstellt wird
        if (e.target.tagName === 'INPUT') return;

        const currentText = box.childNodes[0].nodeValue.trim();
        
        // Tempor√§r die Buttons ausblenden f√ºr mehr Platz
        const deleteBtn = box.querySelector('.delete-btn');
        const resizeBtn = box.querySelector('.resize-btn');
        if(deleteBtn) deleteBtn.style.display = 'none';
        if(resizeBtn) resizeBtn.style.display = 'none';

        // Erstelle das Input-Feld
        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'app-box-editor';
        input.value = currentText;
        
        // Ersetze den Textknoten durch das Input-Feld
        box.childNodes[0].replaceWith(input);
        input.focus();
        input.select();

        // Funktion, um die Bearbeitung abzuschlie√üen
        const finishEditing = () => {
            const newText = input.value.trim() || currentText; // Fallback auf alten Text, wenn leer
            const newTextNode = document.createTextNode(newText);
            input.replaceWith(newTextNode);

            // Buttons wieder einblenden
            if(deleteBtn) deleteBtn.style.display = '';
            if(resizeBtn) resizeBtn.style.display = '';

            // Event Listener wieder entfernen, um Speicherlecks zu vermeiden
            input.removeEventListener('blur', finishEditing);
            input.removeEventListener('keypress', handleKeyPress);
        };
        
        const handleKeyPress = (e) => {
            if (e.key === 'Enter') {
                finishEditing();
            }
        };

        // Event Listener hinzuf√ºgen, um die Bearbeitung zu beenden
        input.addEventListener('blur', finishEditing);
        input.addEventListener('keypress', handleKeyPress);
    });
</script>


</body>
</html>















