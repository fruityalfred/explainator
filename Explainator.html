<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Explainator - Ultimate Edition</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            padding: 10px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 100%;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
        }
        
        h2 {
            text-align: center;
            margin-bottom: 20px;
            font-size: 28px;
            color: #2c3e50;
            font-weight: 600;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            align-items: center;
        }
        /* Hide legacy first controls bar if a second one is present */
        .container > .controls:first-of-type { display: none !important; }
        
        .btn {
            padding: 10px 18px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-success {
            background: linear-gradient(135deg, #84fab0 0%, #8fd3f4 100%);
            color: #1a1a1a;
        }
        
        .btn-warning {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
            color: #1a1a1a;
        }
        
        .btn-danger {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }
        
        .btn-info {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }
        
        .btn-secondary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .main-container {
            display: flex;
            gap: 10px;
            overflow-x: auto;
            padding-bottom: 20px;
            /* min-height: 600px; */ /* <-- Auskommentiert oder gelÃ¶scht */
        }
        
        .column {
            min-width: 200px;
            max-width: none; /* remove width cap */
            width: 400px; /* default width */
            background: white;
            border: 2px solid #8B4513;
            border-radius: 8px;
            position: relative;
            display: flex;
            flex-direction: column;
            transition: all 0.3s;
        }
        
        /* Split column layout */
        /* legacy split classes no longer used; kept for compatibility */
        /* .column.split-column, .column.split-column-3 { } */
        
        .column-split-content {
            display: flex;
                        gap: 10px;            /* horizontal gap between parts */
            flex: 0 0 auto;       /* do not grow; columns independent */
            padding: 0;      /* match .column-content horizontal padding */
            position: relative;
            margin: 0;            /* rely on parent gap for vertical spacing */
        }

        .column-part {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px; /* match vertical spacing with normal sections */
            border-right: 1px solid #e0e0e0;
            padding-right: 10px;
            margin-top: 0;
        }
        .column-part:last-child { border-right: none; padding-right: 0; padding-left: 0px; }
        
        /* removed legacy .column-half/.column-third; using .column-part only */
        
        .column:hover {
            box-shadow: 0 5px 20px rgba(139,69,19,0.2);
        }

        /* Do not cover bottom borders of sections; mask only the vertical divider ends */
        .column-split-content::after { display: none; }

        .column-part { position: relative; }
        .column-part::after {
            content: '';
            position: absolute;
            right: -1px; bottom: 0;
            width: 2px; height: 10px; /* hide last 10px of divider only */
            background: #fff; pointer-events: none;
        }
        .column-part:last-child::after { display: none; }
        
        .column-header {
            background: linear-gradient(to bottom, #8B4513, #A0522D);
            color: white;
            padding: 12px;
            text-align: center;
            font-weight: bold;
            font-size: 14px;
            border-radius: 6px 6px 0 0;
            position: relative;
            cursor: move;
            /* Reserve space for left counter to keep title visually centered */
            --header-left-pad: 80px;
            padding-left: var(--header-left-pad);
            padding-right: 96px; /* space for color + delete */
        }
        
        .column-header .delete-column {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.3s;
        }
        

        .split-counter {
            position: absolute;
            left: 0;
            right: auto;
            top: 50%;
            transform: translateY(-50%);
            display: inline-flex;
            align-items: center;
            gap: 4px;
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            border-radius: 12px;
            padding: 2px 6px;
            user-select: none;
            z-index: 1;
        }
        .split-counter button {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.4);
            background: rgba(255,255,255,0.25);
            color: white;
            cursor: pointer;
            line-height: 18px;
            font-weight: 700;
        }
        .split-counter .value { min-width: 16px; text-align: center; font-weight: 700; }
        
        .section-delete {
            position: absolute;
            right: 35px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255,0,0,0.7);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            transition: all 0.3s;
        }
        
        .section-delete:hover {
            background: rgba(255,0,0,0.9);
            transform: translateY(-50%) scale(1.1);
        }
        
        .column-header .delete-column:hover {
            background: rgba(255,0,0,0.5);
        }
        
        .resize-handle {
            position: absolute;
            right: -6px;
            top: 0;
            bottom: 0;
            width: 12px;
            cursor: ew-resize;
            background: transparent;
        }
        
        .resize-handle:hover {
            background: rgba(139,69,19,0.2);
        }
        
        .column-content {
            padding: 12px;
            flex: 1;
            /* Keine Scrollleisten in Spalten */
            overflow: visible;
            display: flex;
            flex-direction: column;
            gap: 8px; /* slightly tighter vertical spacing */
        }
        
        .section-group {
            border: 2px dashed #999;
            border-radius: 6px;
            padding: 10px;
            min-height: 80px;
            transition: all 0.3s;
            position: relative;
            cursor: move;
        }
        
        .section-group.drag-over {
            background: #e8f5e9;
            border-color: #4CAF50;
            border-style: solid;
        }
        
        .column-content.drag-over {
            background: rgba(76, 175, 80, 0.1);
            border: 2px dashed #4CAF50;
            border-radius: 8px;
        }
        
        .section-group.dragging {
            opacity: 0.7;
            transform: rotate(2deg);
            z-index: 1000;
        }
        
        .section-title {
            background: #8B4513;
            color: white;
            padding: 6px 12px;
            text-align: center;
            font-size: 12px;
            font-weight: bold;
            border-radius: 4px;
            margin-bottom: 10px;
            position: relative;
            cursor: pointer;
        }
        
        .section-title input {
            background: transparent;
            border: none;
            color: white;
            text-align: center;
            font-size: 12px;
            font-weight: bold;
            width: 100%;
        }
        
        .section-title .section-menu {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            cursor: pointer;
        }
        
        .section-title .section-menu:hover {
            background: rgba(255,255,255,0.4);
        }
        /* Section pipette icon */
        .section-title .section-pipette {
            position: absolute;
            right: 58px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            cursor: pointer;
        }
        .section-title .section-pipette:hover { background: rgba(255,255,255,0.4); }
        
        .add-section-btn {
            width: 100%;
            padding: 4px 8px;
            border: 2px dashed #ccc;
            background: #f9f9f9;
            color: #666;
            cursor: pointer;
            border-radius: 4px;
            text-align: center;
            transition: all 0.3s;
            font-size: 10px;
        }
        
        .add-section-btn:hover {
            background: #e8f5e9;
            border-color: #4CAF50;
            color: #2e7d32;
        }
        
        .box-container {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            min-height: 30px;
            /* keine Scrollleisten innerhalb von Sections */
            overflow: visible;
        }
        
        .app-box {
            padding: 8px 12px;
            text-align: center;
            font-size: 11px;
            border-radius: 4px;
            border: 1px solid #ccc;
            cursor: move;
            position: relative;
            min-height: 30px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            white-space: pre-line; /* preserve user line breaks */
            /* Avoid animating size to prevent wobble */
            transition: box-shadow 0.2s ease;
            flex: 0 0 auto;
            max-width: 100%;
            word-break: break-word; /* legacy */
            overflow-wrap: anywhere; /* ensure long words wrap */
            overflow: hidden; /* never show inner scrollbars */
        }
        
        .app-box.half-width {
            flex: 0 0 calc(50% - 3px);
        }
        
        .app-box.full-width {
            flex: 0 0 100%;
        }
        
        .app-box { will-change: box-shadow; }
        .app-box:hover {
            /* Avoid transform to prevent any perceived size change/jitter */
            box-shadow: 0 6px 12px rgba(0,0,0,0.2);
        }
        
        .app-box.dragging {
            opacity: 0.5;
        }

        /* Column dragging visual effect */
        .column.dragging {
            opacity: 0.7;
            transform: rotate(2deg);
            box-shadow: 0 12px 28px rgba(0,0,0,0.25);
            z-index: 1000;
        }
        
        .app-box .delete-btn {
            position: absolute;
            top: 4px;
            right: 4px;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            cursor: pointer;
            display: flex; /* always in flow for stability */
            align-items: center;
            justify-content: center;
            font-weight: bold;
            opacity: 0; visibility: hidden; transition: opacity .12s ease;
        }
        
        .app-box:hover .delete-btn { opacity: 1; visibility: visible; }
        
        .app-box .resize-btn {
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 10px;
            cursor: pointer;
            display: flex; /* always in flow for stability */
            align-items: center;
            justify-content: center;
            opacity: 0; visibility: hidden; transition: opacity .12s ease;
        }
        
        .app-box:hover .resize-btn { opacity: 1; visibility: visible; }
        
        /* Add Column Button */
        .add-column {
            min-width: 60px;
            background: #f0f0f0;
            border: 2px dashed #999;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
            padding: 20px;
        }
        
        .add-column:hover {
            background: #e8f5e9;
            border-color: #4CAF50;
        }
        
        .add-column span {
            font-size: 32px;
            color: #666;
        }
        
        /* Grid lines for better alignment */
        .grid-lines .section-group {
            border-bottom: 1px dashed #ccc;
            margin-bottom: 5px;
            padding-bottom: 5px;
        }
        
        .grid-lines .section-group:last-of-type {
            border-bottom: none;
        }
        
        /* removed grid-lines styling for legacy halves/thirds */
        
        .grid-lines .column-split-content {
            border-top: 1px dashed #ccc;
        }
        
        .grid-lines .column-content {
            position: relative;
        }
        
        .grid-lines .column-content::before {
            content: '';
            position: absolute;
            top: 0;
            bottom: 0;
            left: 50%;
            border-left: 1px dashed #eee;
            pointer-events: none;
            z-index: 1;
        }
        
        /* Legend */
        .legend {
            display: flex;
            gap: 20px;
            justify-content: flex-start;
            padding: 15px;
            background: #f9f9f9;
            border-radius: 8px;
            flex-wrap: wrap;
            margin-top: 20px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            padding: 5px 10px;
            border-radius: 4px;
            transition: all 0.3s;
        }
        
        .legend-item:hover {
            background: white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .legend-box {
            width: 30px;
            height: 20px;
            border-radius: 4px;
        }
        
        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        
        .modal.show {
            display: flex;
        }
        
        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 12px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        .modal-header {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 20px;
            color: #2c3e50;
        }
        
        .modal-body {
            margin-bottom: 20px;
        }
        
        .modal-body input, .modal-body select {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            margin-bottom: 10px;
        }
        
        .modal-footer {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        
        .category-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            border: 1px solid #ddd;
            margin-bottom: 10px;
            border-radius: 6px;
            background: #f9f9f9;
        }
        
        .category-preview {
            width: 40px;
            height: 30px;
            border-radius: 4px;
            flex-shrink: 0;
        }
        
        .category-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            flex: 1;
        }
        
        .category-controls input[type="text"] {
            flex: 1;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .category-controls input[type="color"] {
            width: 40px;
            height: 30px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .color-input-group {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .placeholder {
            background: #e8f5e9;
            border: 2px dashed #4CAF50;
            min-height: 30px;
        }
        
        .info-panel {
            background: #fffbf0;
            border: 2px solid #ffc107;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 15px;
            font-size: 13px;
        }
        
        .info-panel strong {
            color: #f57c00;
        }
        
        .small-btn {
            padding: 5px 10px;
            font-size: 12px;
        }
        
        .template-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 15px;
            margin-bottom: 10px;
            background: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .template-item:hover {
            background: #e8f5e9;
            border-color: #4CAF50;
        }
        
        .template-info {
            flex: 1;
        }
        
        .template-name {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .template-date {
            font-size: 12px;
            color: #666;
        }
        
        .template-actions {
            display: flex;
            gap: 10px;
        }
        
        #exportCanvas {
            position: fixed;
            top: -10000px;
            left: -10000px;
            pointer-events: none;
        }
        
        .section-color-picker {
            position: absolute;
            top: 25px;
            right: 0;
            background: white;
            border: 2px solid #ddd;
            border-radius: 6px;
            padding: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1000;
            display: none;
            min-width: 240px;
            max-width: 520px;
        }
        
        .section-color-picker.show { display: flex; flex-wrap: wrap; gap: 8px; }
        .section-color-picker .swatch { width: 22px; height: 22px; border-radius: 4px; border: 1px solid #bbb; cursor: pointer; }
        .section-color-picker .swatch:hover, .column-color-picker .swatch:hover { outline: 2px solid #888; }

        .column-visibility-menu {
            position: fixed;
            background: white;
            border: 2px solid #ddd;
            border-radius: 6px;
            padding: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 2000;
            min-width: 200px;
            display: none;
        }

        .column-visibility-menu.show { display: block; }

        .column-visibility-menu-item {
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            user-select: none;
        }

        .column-visibility-menu-item:hover {
            background: #f0f0f0;
        }

        .column-visibility-menu-item .checkbox {
            width: 16px;
            height: 16px;
            border: 2px solid #666;
            border-radius: 3px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        .column-visibility-menu-item .checkbox.checked {
            background: #4CAF50;
            border-color: #4CAF50;
            color: white;
        }
  </style>
  <style id="header-modes-css">
  /* Header visibility modes */
  .mode-columns-off .column-header{display:none!important}
  .mode-columns-off .column{border-color:transparent;box-shadow:inset 0 0 0 1px #ddd}
  .mode-columns-off .column-content{padding-top:8px}
  .mode-columns-off .section-group{border:1px solid #ddd}
  .mode-columns-off .app-box{border-color:#ddd}
  .mode-sections-off .section-title{display:none!important}
  .mode-sections-off .section-group{border:1px solid #ddd;padding-top:10px}
  .mode-columns-off.mode-sections-off .section-group{border:none;padding:0}
  /* Individual column header visibility */
  .column[data-hide-column-header="true"] > .column-header{display:none!important}
  .column[data-hide-column-header="true"]{border-color:transparent;box-shadow:inset 0 0 0 1px #ddd}
  .column[data-hide-column-header="true"] > .column-content{padding-top:8px}
  .column[data-hide-section-headers="true"] .section-title{display:none!important}
  .column[data-hide-section-headers="true"] .section-group{border:1px solid #ddd;padding-top:10px}
  </style>
  <style>
  /* Open Canvas Mode */
  .main-container.canvas-mode { display:block !important; position:relative; width:1920px; height:1080px; margin:0 auto; background-image: linear-gradient(transparent 39px, rgba(0,0,0,0.05) 40px), linear-gradient(90deg, transparent 39px, rgba(0,0,0,0.05) 40px); background-size: 40px 40px, 40px 40px; border: 2px dashed #bbb; }
  .main-container.canvas-mode .column { position:absolute !important; }
  .main-container.canvas-mode .column .column-header { cursor:grab; }
  .main-container.canvas-mode .column[data-hide-column-header="true"] { cursor:grab; }
  .main-container.canvas-mode .add-column { display:none !important; }
  /* SVG overlay for connectors */
  .canvas-connectors { position:absolute; left:0; top:0; width:100%; height:100%; pointer-events:none; overflow:visible; shape-rendering: geometricPrecision; }
  .canvas-connectors path { stroke:#1E88E5; stroke-width:2; fill:none; pointer-events:stroke; vector-effect: non-scaling-stroke; }
  .canvas-connectors path.conn-highlight { stroke:#EF6C00; stroke-width:3; }
  /* Visual feedback for active connector mode button */
  .controls [data-role="connector-toggle-btn"].is-active {
    outline: 2px solid #1E88E5;
    box-shadow: 0 0 0 2px rgba(30,136,229,0.15);
  }
  /* Anchor point selection overlay */
  .connector-anchor-overlay {
    position: absolute;
    pointer-events: none;
    z-index: 10000;
  }
  .connector-anchor-overlay.active {
    pointer-events: auto;
  }
  .anchor-point {
    position: absolute;
    width: 20px;
    height: 20px;
    background: #1E88E5;
    border: 3px solid white;
    border-radius: 50%;
    cursor: pointer;
    transform: translate(-50%, -50%);
    box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    transition: transform 0.15s, background 0.15s;
  }
  .anchor-point:hover {
    transform: translate(-50%, -50%) scale(1.3);
    background: #EF6C00;
  }
  .anchor-point.selected {
    background: #4CAF50;
    transform: translate(-50%, -50%) scale(1.2);
  }
  </style>

<style>
.column, .column-header { overflow: visible !important; }
.column-header .header-btn { position:absolute; top:50%; transform:translateY(-50%); background:rgba(255,255,255,0.15); border:1px solid rgba(255,255,255,0.3); color:#fff; width:24px; height:24px; border-radius:50%; cursor:pointer; display:flex; align-items:center; justify-content:center; font-size:12px; }
.column-header .delete-column { right:10px; font-size:16px; }
.column-header .color-column-btn { right:40px; }
.column-header .pipette-column-btn { right:70px; }
.column-header .insert-split-btn { right:100px; }
.column-color-picker { z-index:30000; position:absolute; top:110%; right:0; background:#fff; border:2px solid #ddd; border-radius:6px; padding:10px; box-shadow:0 4px 12px rgba(0,0,0,0.15); z-index:12000; display:none; min-width:240px; max-width:520px; }
.column-color-picker.show{ display:flex; flex-wrap: wrap; gap:8px; }
.column-color-picker .row{ display:flex; align-items:center; gap:8px; margin:0; width: calc(33.333% - 8px); }
.column-color-picker .row:last-child{ width:100%; margin-top:8px; }
.column-color-picker .swatch{ width:22px; height:22px; border-radius:4px; border:1px solid #bbb; cursor:pointer; }
        .column-color-picker .swatch{ width:30px; height:20px; border-radius:4px; border:1px solid #ccc; cursor:pointer; }
</style>

<style>.column-header{position:relative}</style>

<style>
/* Hide picker icon during screenshots/exports */
.screenshot-mode .color-column-btn,
[data-screenshot="true"] .color-column-btn,
.exporting .color-column-btn { display: none !important; }
/* Hide pipette icons during screenshots/exports */
.screenshot-mode .pipette-column-btn,
[data-screenshot="true"] .pipette-column-btn,
.exporting .pipette-column-btn,
.screenshot-mode .section-pipette,
[data-screenshot="true"] .section-pipette,
.exporting .section-pipette { display: none !important; }
/* During EyeDropper, remove modal dimming so picked color is accurate */
.eye-drop-mode .modal { background: transparent !important; }
</style>

<style>
/* Hide canvas grid/border during export */
[data-screenshot="true"] .main-container.canvas-mode { background-image: none !important; border: none !important; }
</style>

<style>
    /* Visuelles Feedback fÃ¼r das Ziehen von Elementen */
    .dragging-placeholder {
        background: rgba(0, 128, 0, 0.1);
        border: 2px dashed #4CAF50;
        border-radius: 6px;
        margin: 4px 0;
    }
    /* Visual cue when Alt enables full-width drop for split-origin sections */
    .dragging-placeholder.full-width-mode {
        background: rgba(33, 150, 243, 0.10);
        border-color: #2196F3;
    }
    .dragging {
        opacity: 0.5;
        transform: rotate(2deg);
    }
</style>

<style>
/* Original wÃ¤hrend Ctrl-Klon nicht dimmen */
.app-box[data-no-dim="1"],
.app-box[data-no-dim="1"].dragging {
  opacity: 1 !important;
  filter: none !important;
}
.app-box.selected { outline: 2px solid #2196F3; box-shadow: 0 0 0 2px rgba(33,150,243,0.15) inset; }
</style>

<style>
    /* Styling fÃ¼r das Bearbeitungs-Eingabefeld in einer App-Box */
    .app-box-editor {
        width: 100%;
        height: 100%;
        border: none;
        background-color: rgba(255, 255, 255, 0.8);
        font-family: inherit;
        font-size: inherit;
        text-align: center;
        padding: 2px;
        box-sizing: border-box;
    }
    .app-box-editor:focus {
        outline: 2px solid #007bff;
        box-shadow: 0 0 5px rgba(0,123,255,0.5);
    }
</style>

<style>
.column-color-picker { max-width: 260px; }
.header-btn.color-column-btn { user-select: none; }
.column-header { overflow: visible; }
</style>

<style>
/* Image boxes */
.app-box.image-box {
    padding: 6px;
    border: 1px solid #ccc;
    background: #fff;
}
.app-box.image-box img {
    display: block;
    max-width: 100%; /* constrain but do not upscale */
    width: auto;      /* keep intrinsic width to avoid stretching */
    height: auto;
    max-height: 270px; /* 3 x (3 lines) ~ 270px */
    object-fit: contain;
    margin: 0 auto;   /* center if narrower than container */
    border-radius: 4px;
}

/* Modal dropzone for images */
.image-dropzone {
    width: 100%;
    min-height: 80px;
    border: 2px dashed #999;
    border-radius: 6px;
    background: #f9f9f9;
    color: #666;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
    padding: 10px;
    user-select: none;
}
.image-dropzone.dragover { border-color: #4CAF50; background: #e8f5e9; color: #2e7d32; }
.image-preview img { max-width: 100%; height: auto; max-height: 200px; display: block; border-radius: 4px; }
</style>

</head>
<body>
    <div class="container">
        <h2 data-translate="mainTitle">ð¢ Explainator - Ultimate Edition</h2>
        
        <div class="controls">
            <button class="btn btn-success" onclick="showAddBoxModal()" data-translate="addBox">Neue Box</button>
            <button class="btn btn-info" onclick="showCategoryModal()" data-translate="manageCategories">Kategorien verwalten</button>
            <button class="btn btn-secondary" onclick="showFormattingModal()" data-translate="formatting">Formatierung</button>
            <button class="btn btn-warning" onclick="exportToPNG()" data-translate="exportPNG">Als PNG exportieren</button>
            <button class="btn btn-info" onclick="saveTemplate()" data-translate="saveTemplate">Template speichern</button>
            <button class="btn btn-success" onclick="showLoadTemplateModal()" data-translate="loadTemplate">Template laden</button>
            <button class="btn btn-warning" onclick="resetLayout()" data-translate="resetLayout">Layout zurÃ¼cksetzen</button>
            <button class="btn btn-danger" onclick="clearAll()" data-translate="clearAll">Alles lÃ¶schen</button>
            <button class="btn btn-secondary" onclick="showHelpModal()" data-translate="help">Hilfe</button>
            <button id="langSwitchBtn" class="btn btn-info" onclick="toggleLanguage()">EN</button>
        </div>

        <!-- Unified static controls bar -->
        <div class="controls">
            <button class="btn btn-success" onclick="showAddBoxModal()" data-translate="addBox">Neue Box</button>
            <button class="btn btn-secondary" onclick="showAddLineModal()" data-translate="addLine">Linien</button>
            <button class="btn btn-secondary" onclick="showFormattingModal()" data-translate="formatting">Formatierung</button>
            <button class="btn btn-info" onclick="showCategoryModal()" data-translate="manageCategories">Kategorien verwalten</button>
            <button class="btn btn-secondary" onclick="showBatchImportModal()" data-translate="batchImport">Batch Import</button>
            <button class="btn btn-info" onclick="exportToExcel()">Excel</button>
            <button class="btn btn-warning" onclick="exportToPNG()" data-translate="exportPNG">Als PNG exportieren</button>
            <button class="btn btn-info" onclick="saveTemplate()" data-translate="saveTemplate">Template speichern</button>
            <button class="btn btn-success" onclick="showLoadTemplateModal()" data-translate="loadTemplate">Template laden</button>
            <button class="btn btn-secondary" data-role="canvas-toggle-btn" onclick="toggleCanvasMode()" title="Open Canvas Mode ein/aus">Canvas</button>
            <select class="btn" data-role="canvas-res-select" style="padding:6px 8px" title="Canvas AuflÃ¶sung" onchange="(function(s){var v=s.value.split('x'); setCanvasSize(parseInt(v[0],10), parseInt(v[1],10));})(this)">
                <option value="1280x720">HD 1280Ã720</option>
                <option value="1920x1080" selected>Full HD 1920Ã1080</option>
            </select>
            <button class="btn btn-info" data-role="connector-toggle-btn" onclick="toggleConnectorMode()" title="Connector-Modus ein/aus" aria-pressed="false">Verbindungen</button>
            <button class="btn btn-secondary" id="columnsModeBtn" onclick="toggleColumnsMode(this)" title="Spalten-Header ein/aus">Spalten: An</button>
            <button class="btn btn-secondary" id="sectionsModeBtn" onclick="toggleSectionsMode(this)" title="Section-Header ein/aus">Sections: An</button>
            <button class="btn btn-warning" onclick="resetLayout()" data-translate="resetLayout">Layout zurÃ¼cksetzen</button>
            <button class="btn btn-danger" onclick="clearAll()" data-translate="clearAll"> Alles lÃ¶schen</button>
            <button class="btn btn-secondary" onclick="showHelpModal()" data-translate="help">Hilfe</button>
            <button id="langSwitchBtn" class="btn btn-info" onclick="toggleLanguage()">EN</button>
        </div>
        
        <div class="main-container" id="mainContainer">
            </div>
        
        <div class="legend" id="legend">
            </div>
    </div>
        
    <div class="modal" id="addBoxModal">
        <div class="modal-content">
            <div class="modal-header" data-translate="addBoxModalTitle">Neue Box hinzufÃ¼gen</div>
            <div class="modal-body">
                <input type="text" id="boxName" placeholder="Box Name" data-translate="boxNamePlaceholder">
                <select id="boxType"></select>
                <select id="boxWidth">
                    <option value="full-width" data-translate="fullWidth">Volle Breite</option>
                    <option value="half-width" data-translate="halfWidth">Halbe Breite</option>
                </select>
                <label for="boxLines" id="boxLinesLabel" style="display:block;margin-top:8px;" data-translate="boxHeightLabel">HÃ¶he (Zeilen)</label>
                <select id="boxLines">
                    <option value="1" selected data-translate="boxHeight1">1 Zeile (Standard)</option>
                    <option value="2" data-translate="boxHeight2">2 Zeilen</option>
                    <option value="3" data-translate="boxHeight3">3 Zeilen</option>
                </select>
                
                <div id="textOptions" style="display: flex; gap: 20px; margin-top: 15px; align-items: center;">
                    <label><span data-translate="textColorLabel">Text:</span> <input type="color" id="boxTextColor" value="#000000"></label>
                </div>

                <hr style="margin:14px 0;">
                <label style="display:flex; align-items:center; gap:8px; cursor:pointer;">
                    <input type="checkbox" id="boxIsImage" />
                    <span data-translate="imageMode">Bild statt Text</span>
                </label>
                
                <div id="imageOptions" style="display:none; margin-top:10px;">
                    <div id="imageDropzone" class="image-dropzone" data-translate="imageSelectOrDrop" title="JPG oder PNG">
                        Bild auswÃ¤hlen oder hierher ziehen (JPG/PNG)
                    </div>
                    <input type="file" id="boxImageFile" accept="image/png, image/jpeg" style="margin-top:8px; width:100%;" />
                    <div id="imagePreview" class="image-preview" style="margin-top:8px; display:none;"></div>
                    <div style="font-size:12px; color:#666; margin-top:6px;" data-translate="imageMaxHeightHint">Maximale HÃ¶he: 3 Ã 3âZeilen Boxen</div>
                </div>

            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" onclick="addBoxNew()" data-translate="add">HinzufÃ¼gen</button>
                <button class="btn btn-danger" onclick="closeModal('addBoxModal')" data-translate="cancel">Abbrechen</button>
            </div>
        </div>
    </div>

    <!-- Layout Builder Modal -->
    <div class="modal" id="layoutBuilderModal">
        <div class="modal-content">
            <div class="modal-header">Layout Builder</div>
            <div class="modal-body">
                <div style="display:flex; gap:12px; align-items:center; margin-bottom:12px;">
                    <label>Spalten:</label>
                    <input type="number" id="lbColumns" min="1" max="8" value="2" style="width:80px;">
                    <button class="btn btn-secondary" onclick="renderLayoutBuilderGrid()">Aktualisieren</button>
                </div>
                <div id="lbGrid" style="display:flex; flex-direction:column; gap:8px;"></div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" onclick="applyLayoutBuilder()">Erstellen</button>
                <button class="btn btn-danger" onclick="closeModal('layoutBuilderModal')">Abbrechen</button>
            </div>
        </div>
    </div>
    
    <div class="modal" id="categoryModal">
        <div class="modal-content">
            <div class="modal-header" data-translate="manageCategories">ð¨ Kategorien verwalten</div>
            <div class="modal-body">
                <div style="margin-bottom: 30px; padding: 20px; background: #f0f8ff; border-radius: 8px;">
                    <h4 style="margin-bottom: 15px;" data-translate="addNewCategoryTitle">Neue Kategorie hinzufÃ¼gen:</h4>
                    <input type="text" id="categoryName" placeholder="Kategorie Name (z.B. Cloud Services)">
                    <div class="color-input-group" id="catColorGroup">
                        <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px; flex-wrap:wrap;">
                            <label style="min-width: 60px;" data-translate="color1">Box-Farbe:</label>
                            <input type="color" id="categoryColor1" value="#8B4513" style="flex:0 0 40px; border:none; padding:0;">
                            <button class="btn small-btn" type="button" onclick="pickEyeDropper('categoryColor1')">Pipette</button>
                            <label style="margin-left:16px; display:flex; align-items:center; gap:6px;">
                                <input type="checkbox" id="useGradient" onchange="toggleGradient()"> Verlauf verwenden
                            </label>
                        </div>
                        <div id="catSwatches1" style="display:flex; flex-wrap:wrap; gap:6px; margin-bottom:10px;"></div>
                        <div id="gradientRow" style="display:none; align-items:center; gap:8px; margin:6px 0 10px 0; flex-wrap:wrap;">
                            <label style="min-width: 60px;">Farbe 2:</label>
                            <input type="color" id="categoryColor2" value="#8B4513" style="flex:0 0 40px; border:none; padding:0;">
                            <button class="btn small-btn" type="button" onclick="pickEyeDropper('categoryColor2')">Pipette</button>
                        </div>
                        <div id="catSwatches2" style="display:none; flex-wrap:wrap; gap:6px; margin-bottom:10px;"></div>
                        <div style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <label style="min-width: 60px;">Text-Farbe:</label>
                            <input type="color" id="categoryTextColor" value="#ffffff" style="flex:0 0 40px; border:none; padding:0;">
                            <button class="btn small-btn" type="button" onclick="pickEyeDropper('categoryTextColor')">Pipette</button>
                        </div>
                        <div id="colorPreview" style="display:inline-flex; align-items:center; justify-content:center; width: 180px; height: 36px; border-radius: 6px; background: linear-gradient(135deg, #8B4513 0%, #8B4513 100%); color:#ffffff; font-weight:600; border:1px solid #ddd;">Vorschau</div>
                    </div>
                    <button class="btn btn-success" onclick="addCategory()" data-translate="addCategory">â Kategorie hinzufÃ¼gen</button>
                </div>
                
                <div>
                    <h4 style="margin-bottom: 15px;" data-translate="existingCategories">Vorhandene Kategorien:</h4>
                    <div id="categoryList">
                        </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" onclick="closeModal('categoryModal')" data-translate="done">Fertig</button>
            </div>
        </div>
    </div>
    
    <div class="modal" id="loadTemplateModal">
        <div class="modal-content">
            <div class="modal-header" data-translate="loadTemplate">ð Template laden</div>
            <div class="modal-body">
                <div style="margin-bottom: 20px;">
                    <h4 style="margin-bottom: 10px;">Vorlagen:</h4>
                    <div id="builtinTemplateList" style="display:flex; gap:10px; flex-wrap:wrap; margin-bottom:10px;">
                        <button class="btn btn-secondary small-btn" onclick="loadBuiltinTemplate('organigram')">Organigramm</button>
                        <button class="btn btn-secondary small-btn" onclick="loadBuiltinTemplate('office')">Office Map</button>
                        <button class="btn btn-secondary small-btn" onclick="loadBuiltinTemplate('kanban')">Kanban</button>
                    </div>
                </div>
                <div style="margin-bottom: 20px;">
                    <h4 style="margin-bottom: 10px;" data-translate="savedTemplates">Gespeicherte Templates:</h4>
                    <div id="templateList" style="max-height: 300px; overflow-y: auto;">
                        </div>
                </div>
                
                <div style="border-top: 2px solid #eee; padding-top: 20px;">
                    <h4 style="margin-bottom: 10px;" data-translate="loadTemplateFromFileTitle">Template aus Datei laden:</h4>
                    <input type="file" id="templateFileInput" accept=".json" style="margin-bottom: 10px;">
                    <button class="btn btn-primary" onclick="loadTemplateFromFile()" data-translate="loadFile">ð Datei laden</button>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-danger" onclick="closeModal('loadTemplateModal')" data-translate="close">SchlieÃen</button>
            </div>
        </div>
    </div>
    
    <div class="modal" id="helpModal">
        <div class="modal-content" style="max-width: 900px;">
            <div class="modal-header" data-translate="helpTitle">â Hilfe</div>
            <div class="modal-body" style="max-height: 70vh; overflow-y: auto;">
                <div class="help-content help-de">
<h2>Benutzerhandbuch (Deutsch)</h2>
<h4 style="margin-top: 20px; border-bottom: 1px solid #eee; padding-bottom: 5px;">1. EinfÃ¼hrung</h4>
<p>Explainator ist eine webbasierte Anwendung zur Erstellung und Bearbeitung visueller Layouts. Sie unterstÃ¼tzt:</p>
<ul style="margin-left: 20px;">
<li><strong>Organigramme</strong> (Hierarchische Strukturen, z. B. Firmenorganisationen).</li>
<li><strong>Office-Maps</strong> (RaumplÃ¤ne oder BÃ¼rolayouts).</li>
<li><strong>Kanban-Boards</strong> (Aufgabenverwaltung mit Spalten).</li>
<li><strong>Weitere Canvas-basierte Inhalte</strong> (z. B. benutzerdefinierte Boards).</li>
</ul>
<p>Die App ist multilingual (Deutsch und Englisch) und bietet eine intuitive Drag-and-Drop-OberflÃ¤che. Mit dieser App kÃ¶nnen Sie fast alles einfach und sichtbar erklÃ¤ren. Die einzige Grenze sind Sie selbst. Sie lÃ¤dt keine externen Ressourcen (auÃer potenziell Benutzerbilder) und speichert Daten lokal oder als JSON-Dateien.</p>
<p><strong>Systemvoraussetzungen</strong>:</p>
<ul style="margin-left: 20px;">
<li>Moderner Webbrowser (z. B. Chrome, Firefox).</li>
<li>Keine Internetverbindung erforderlich (auÃer fÃ¼r lokale Datei-Uploads).</li>
<li>UnterstÃ¼tzte Dateiformate: JPG/PNG fÃ¼r Bilder, JSON fÃ¼r Templates.</li>
</ul>
<p><strong>Starten der App</strong>:</p>
<ul style="margin-left: 20px;">
<li>Ãffnen Sie die HTML-Datei in einem Browser. Die OberflÃ¤che lÃ¤dt automatisch mit einem Header-MenÃ¼ und einem Canvas-Bereich.</li>
</ul>
<h4 style="margin-top: 20px; border-bottom: 1px solid #eee; padding-bottom: 5px;">2. OberflÃ¤che und Navigation</h4>
<p>Die HauptoberflÃ¤che besteht aus:</p>
<ul style="margin-left: 20px;">
<li><strong>Header-MenÃ¼</strong> (oben): EnthÃ¤lt Icons und Buttons fÃ¼r Kernfunktionen.</li>
<ul style="margin-left: 20px;">
<li>ð¢ <strong>Explainator - Ultimate Edition</strong>: Titel der App.</li>
<li><strong>Sprachauswahl</strong>: "EN" fÃ¼r Englisch (wechselt zwischen DE/EN).</li>
<li><strong>MenÃ¼-Optionen</strong>:</li>
<ul style="margin-left: 20px;">
<li><strong>Neue Box</strong>: Ãffnet den Dialog zum HinzufÃ¼gen einer neuen Box.</li>
<li><strong>Kategorien verwalten</strong>: Ãffnet den Kategorien-Manager.</li>
<li><strong>Formatierung</strong>: Ãffnet den Schriftart-Anpassungsdialog (siehe unten).</li>
<li><strong>Als PNG exportieren</strong>: Exportiert das Canvas als PNG-Bild.</li>
<li><strong>Template speichern</strong>: Speichert das aktuelle Layout als Template.</li>
<li><strong>Template laden</strong>: LÃ¤dt ein gespeichertes oder vordefiniertes Template.</li>
<li><strong>Layout zurÃ¼cksetzen</strong>: Setzt das Layout auf Standard zurÃ¼ck.</li>
<li><strong>Alles lÃ¶schen</strong>: LÃ¶scht den gesamten Inhalt.</li>
<li><strong>Hilfe</strong>: Ãffnet den Hilfe-Dialog.</li>
</ul>
</ul>
<li><strong>Canvas-Bereich</strong>: Der Hauptarbeitsbereich, wo Spalten, Sections und Boxen platziert werden. UnterstÃ¼tzt Drag-and-Drop fÃ¼r Verschieben und Neuanordnen.</li>
<li><strong>Modals/Dialoge</strong>: Ãberlagernde Fenster fÃ¼r spezifische Aktionen (z. B. "Neue Box hinzufÃ¼gen"). Jeder Modal hat Buttons wie "HinzufÃ¼gen", "Abbrechen" oder "Fertig".</li>
</ul>
<p><strong>Navigationstipps</strong>:</p>
<ul style="margin-left: 20px;">
<li>Klicken Sie auf Header-Icons, um Modals zu Ã¶ffnen.</li>
<li>Ziehen Sie Elemente (Boxen/Sections) mit der Maus, um sie zu verschieben.</li>
<li>Halten Sie Tastenkombinationen fÃ¼r erweiterte Aktionen (siehe Abschnitt 5).</li>
</ul>
<h4 style="margin-top: 20px; border-bottom: 1px solid #eee; padding-bottom: 5px;">3. Hauptfunktionen</h4>
<p>Hier eine schritt-fÃ¼r-schritt-Beschreibung der Kernfeatures.</p>
<h5 style="margin-top: 15px; margin-bottom: 5px;">3.1 Neue Box hinzufÃ¼gen (ð¦)</h5>
<ul style="margin-left: 20px;">
<li><strong>Ãffnen</strong>: Klicken auf "Neue Box" im Header.</li>
<li><strong>Dialog-Elemente</strong>:</li>
<ul style="margin-left: 20px;">
<li><strong>Breite</strong>: WÃ¤hlen Sie "Volle Breite" oder "Halbe Breite".</li>
<li><strong>HÃ¶he (Zeilen)</strong>: 1 Zeile (Standard), 2 Zeilen oder 3 Zeilen.</li>
<li><strong>Text</strong>: Eingabefeld fÃ¼r den Box-Inhalt.</li>
<li><strong>Bild statt Text</strong>: Checkbox zum Ersetzen des Texts durch ein Bild.</li>
<ul style="margin-left: 20px;">
<li><strong>Bild auswÃ¤hlen</strong>: Datei-Upload (JPG/PNG) oder Drag-and-Drop.</li>
<li><strong>Maximale HÃ¶he</strong>: Bis zu 3 Ã 3-Zeilen-Boxen.</li>
</ul>
</ul>
<li><strong>Aktionen</strong>:</li>
<ul style="margin-left: 20px;">
<li>1. FÃ¼llen Sie die Felder aus.</li>
<li>2. Klicken Sie auf "HinzufÃ¼gen" â die Box erscheint im Canvas.</li>
<li>3. Oder "Abbrechen" zum Verwerfen.</li>
</ul>
<li><strong>Tipps</strong>: Boxen kÃ¶nnen spÃ¤ter per Drag-and-Drop verschoben werden. In gesplitteten Spalten passen halbe Breiten perfekt.</li>
</ul>
<h5 style="margin-top: 15px; margin-bottom: 5px;">3.2 Layout Builder</h5>
<ul style="margin-left: 20px;">
<li><strong>Ãffnen</strong>: Implizit Ã¼ber "Neue Spalte" (nicht direkt im HTML sichtbar, aber im Hilfe-Text erwÃ¤hnt).</li>
<li><strong>Dialog-Elemente</strong>:</li>
<ul style="margin-left: 20px;">
<li><strong>Spalten</strong>: Eingabefeld fÃ¼r die Anzahl der Spalten.</li>
<li><strong>Aktualisieren</strong>: Button zum Anwenden.</li>
</ul>
<li><strong>Aktionen</strong>:</li>
<ul style="margin-left: 20px;">
<li>1. Geben Sie die Spaltenanzahl ein.</li>
<li>2. Klicken Sie auf "Erstellen" â erstellt neue Spalten im Canvas.</li>
<li>3. Oder "Abbrechen".</li>
</ul>
<li><strong>Erweiterung</strong>: Spalten kÃ¶nnen gesplittet werden (2â3 Teile) via Split-ZÃ¤hler in der Spaltenleiste.</li>
</ul>
<h5 style="margin-top: 15px; margin-bottom: 5px;">3.3 Kategorien verwalten (ð¨)</h5>
<ul style="margin-left: 20px;">
<li><strong>Ãffnen</strong>: Klicken auf "Kategorien verwalten".</li>
<li><strong>Dialog-Elemente</strong>:</li>
<ul style="margin-left: 20px;">
<li><strong>Neue Kategorie hinzufÃ¼gen</strong>:</li>
<ul style="margin-left: 20px;">
<li>Name: Eingabefeld.</li>
<li><strong>Box-Farbe</strong>: FarbwÃ¤hler mit Pipette; Checkbox fÃ¼r Verlauf.</li>
<li><strong>Farbe 2</strong>: Zweite Farbe fÃ¼r Verlauf.</li>
<li><strong>Text-Farbe</strong>: FarbwÃ¤hler mit Pipette.</li>
<li><strong>Vorschau</strong>: Zeigt eine Live-Vorschau.</li>
<li><strong>Kategorie hinzufÃ¼gen</strong>: FÃ¼gt die Kategorie hinzu.</li>
</ul>
<li><strong>Vorhandene Kategorien</strong>: Liste mit Bearbeitungsoptionen.</li>
</ul>
<li><strong>Aktionen</strong>:</li>
<ul style="margin-left: 20px;">
<li>1. Erstellen Sie eine neue Kategorie und wÃ¤hlen Farben.</li>
<li>2. Klicken Sie auf "Fertig" zum SchlieÃen.</li>
</ul>
<li><strong>Anwendung</strong>: Kategorien werden auf Sections/Boxen angewendet via â/ð¨ im Section-Header.</li>
</ul>
<h5 style="margin-top: 15px; margin-bottom: 5px;">3.4 Schriftart anpassen (ð )</h5>
<ul style="margin-left: 20px;">
<li><strong>Ãffnen</strong>: Klicken auf "Formatierung".</li>
<li><strong>Dialog-Elemente</strong>:</li>
<ul style="margin-left: 20px;">
<li><strong>Bereich auswÃ¤hlen</strong>: Spalten, Sections oder Boxen.</li>
<li><strong>Schriftart</strong>: Dropdown (Segoe UI (Default), Arial, Times New Roman, Courier New, Verdana, Georgia).</li>
<li><strong>SchriftgrÃ¶Ãe (px)</strong>: Eingabefeld.</li>
<li><strong>Formatierungen</strong>: Checkboxen fÃ¼r Fett (Bold) und Kursiv (Italic).</li>
</ul>
<li><strong>Aktionen</strong>:</li>
<ul style="margin-left: 20px;">
<li>1. WÃ¤hlen Sie den Bereich und Einstellungen.</li>
<li>2. Klicken Sie auf "Anwenden & SchlieÃen".</li>
<li>3. Oder "Abbrechen".</li>
</ul>
</ul>
<h5 style="margin-top: 15px; margin-bottom: 5px;">3.5 Template speichern/laden (ð¾ / ð)</h5>
<ul style="margin-left: 20px;">
<li><strong>Speichern</strong>:</li>
<ul style="margin-left: 20px;">
<li>Ãffnet Dialog zum Speichern in Liste und Download als JSON.</li>
</ul>
<li><strong>Laden</strong>:</li>
<ul style="margin-left: 20px;">
<li><strong>Vorlagen</strong>: Vordefinierte (Organigramm, Office Map, Kanban).</li>
<li><strong>Gespeicherte Templates</strong>: Liste lokaler Speicherungen.</li>
<li><strong>Template aus Datei laden</strong>: Upload einer JSON-Datei.</li>
</ul>
<li><strong>Aktionen</strong>:</li>
<ul style="margin-left: 20px;">
<li>1. WÃ¤hlen Sie ein Template.</li>
<li>2. Klicken Sie auf "SchlieÃen" nach dem Laden.</li>
</ul>
</ul>
<h4 style="margin-top: 20px; border-bottom: 1px solid #eee; padding-bottom: 5px;">4. Erweiterte Features</h4>
<ul style="margin-left: 20px;">
<li><strong>Splitten von Spalten</strong>: Nutzen Sie den Split-ZÃ¤hler (2â3 Teile). Beim Ziehen einer Split-Section: Halten Sie Alt, um als volle Breite abzulegen.</li>
<li><strong>Farben und Raster</strong>: â/ð¨ fÃ¼r Farben; "Hilfslinien" zeigt Grid-Linien.</li>
<li><strong>Bilder</strong>: Nur in Boxen, maximale GrÃ¶Ãe beachten.</li>
<li><strong>Hilfe-Dialog (â)</strong>: EnthÃ¤lt detaillierte Grundlagen, Speichern/Laden, Export und Tastatur-Tipps (auf DE/EN).</li>
</ul>
<h4 style="margin-top: 20px; border-bottom: 1px solid #eee; padding-bottom: 5px;">5. TastaturkÃ¼rzel und Tipps</h4>
<ul style="margin-left: 20px;">
<li><strong>Alt + Drop</strong>: Split-Section als volle Breite einfÃ¼gen.</li>
<li><strong>Ctrl + Ziehen</strong>: Duplizieren (falls aktiviert).</li>
<li><strong>Allgemein</strong>: Drag-and-Drop fÃ¼r alle Elemente; "Neue Spalte" im Kopfbereich fÃ¼r Erweiterung.</li>
<li><strong>Tipps aus Hilfe</strong>: Nutzen Sie Raster fÃ¼r Ausrichtung; Export bereinigt Rahmen/Icons.</li>
</ul>
                </div>
                <div class="help-content help-en" style="display:none;">
<h2>User Manual (English)</h2>
<h4 style="margin-top: 20px; border-bottom: 1px solid #eee; padding-bottom: 5px;">1. Introduction</h4>
<p>Explainator is a web-based application for creating and editing visual layouts. It supports:</p>
<ul style="margin-left: 20px;">
<li><strong>Organizational Charts</strong> (Hierarchical structures, e.g., company organizations).</li>
<li><strong>Office Maps</strong> (Floor plans or office layouts).</li>
<li><strong>Kanban Boards</strong> (Task management with columns).</li>
<li><strong>Other Canvas-Based Content</strong> (e.g., custom boards).</li>
</ul>
<p>The app is multilingual (German and English) and features an intuitive drag-and-drop interface. You can explain mostly everything easy and visible using this App. The only limit is you. It does not load external resources (except potentially user images) and saves data locally or as JSON files.</p>
<p><strong>System Requirements</strong>:</p>
<ul style="margin-left: 20px;">
<li>Modern web browser (e.g., Chrome, Firefox).</li>
<li>No internet connection required (except for local file uploads).</li>
<li>Supported file formats: JPG/PNG for images, JSON for templates.</li>
</ul>
<p><strong>Starting the App</strong>:</p>
<ul style="margin-left: 20px;">
<li>Open the HTML file in a browser. The interface loads automatically with a header menu and a canvas area.</li>
</ul>
<h4 style="margin-top: 20px; border-bottom: 1px solid #eee; padding-bottom: 5px;">2. Interface and Navigation</h4>
<p>The main interface consists of:</p>
<ul style="margin-left: 20px;">
<li><strong>Header Menu</strong> (top): Contains icons and buttons for core functions.</li>
<ul style="margin-left: 20px;">
<li>ð¢ <strong>Explainator - Ultimate Edition</strong>: Title of the app.</li>
<li><strong>Language Selection</strong>: "EN" for English (switches between DE/EN).</li>
<li><strong>Menu Options</strong>:</li>
<ul style="margin-left: 20px;">
<li><strong>New Box</strong>: Opens the dialog to add a new box.</li>
<li><strong>Manage Categories</strong>: Opens the category manager.</li>
<li><strong>Formatting</strong>: Opens the font customization dialog (see below).</li>
<li><strong>Export as PNG</strong>: Exports the canvas as a PNG image.</li>
<li><strong>Save Template</strong>: Saves the current layout as a template.</li>
<li><strong>Load Template</strong>: Loads a saved or predefined template.</li>
<li><strong>Reset Layout</strong>: Resets the layout to default.</li>
<li><strong>Clear All</strong>: Deletes all content.</li>
<li><strong>Help</strong>: Opens the help dialog.</li>
</ul>
</ul>
<li><strong>Canvas Area</strong>: The main workspace where columns, sections, and boxes are placed. Supports drag-and-drop for moving and rearranging.</li>
<li><strong>Modals/Dialogs</strong>: Overlay windows for specific actions (e.g., "Add New Box"). Each modal has buttons like "Add", "Cancel", or "Done".</li>
</ul>
<p><strong>Navigation Tips</strong>:</p>
<ul style="margin-left: 20px;">
<li>Click on header icons to open modals.</li>
<li>Drag elements (boxes/sections) with the mouse to move them.</li>
<li>Hold down key combinations for advanced actions (see section 5).</li>
</ul>
<h4 style="margin-top: 20px; border-bottom: 1px solid #eee; padding-bottom: 5px;">3. Main Features</h4>
<p>Here is a step-by-step description of the core features.</p>
<h5 style="margin-top: 15px; margin-bottom: 5px;">3.1 Add New Box (ð¦)</h5>
<ul style="margin-left: 20px;">
<li><strong>Open</strong>: Click on "New Box" in the header.</li>
<li><strong>Dialog Elements</strong>:</li>
<ul style="margin-left: 20px;">
<li><strong>Width</strong>: Choose "Full Width" or "Half Width".</li>
<li><strong>Height (Lines)</strong>: 1 line (default), 2 lines, or 3 lines.</li>
<li><strong>Text</strong>: Input field for the box content.</li>
<li><strong>Image instead of Text</strong>: Checkbox to replace text with an image.</li>
<ul style="margin-left: 20px;">
<li><strong>Select Image</strong>: File upload (JPG/PNG) or drag-and-drop.</li>
<li><strong>Maximum Height</strong>: Up to 3 Ã 3-line boxes.</li>
</ul>
</ul>
<li><strong>Actions</strong>:</li>
<ul style="margin-left: 20px;">
<li>1. Fill in the fields.</li>
<li>2. Click "Add" â the box appears on the canvas.</li>
<li>3. Or "Cancel" to discard.</li>
</ul>
<li><strong>Tips</strong>: Boxes can be moved later via drag-and-drop. In split columns, half-widths fit perfectly.</li>
</ul>
<h5 style="margin-top: 15px; margin-bottom: 5px;">3.2 Layout Builder</h5>
<ul style="margin-left: 20px;">
<li><strong>Open</strong>: Implicitly via "New Column" (not directly visible in HTML, but mentioned in the help text).</li>
<li><strong>Dialog Elements</strong>:</li>
<ul style="margin-left: 20px;">
<li><strong>Columns</strong>: Input field for the number of columns.</li>
<li><strong>Update</strong>: Button to apply.</li>
</ul>
<li><strong>Actions</strong>:</li>
<ul style="margin-left: 20px;">
<li>1. Enter the number of columns.</li>
<li>2. Click "Create" â creates new columns on the canvas.</li>
<li>3. Or "Cancel".</li>
</ul>
<li><strong>Extension</strong>: Columns can be split (2â3 parts) via the split counter in the column bar.</li>
</ul>
<h5 style="margin-top: 15px; margin-bottom: 5px;">3.3 Manage Categories (ð¨)</h5>
<ul style="margin-left: 20px;">
<li><strong>Open</strong>: Click on "Manage Categories".</li>
<li><strong>Dialog Elements</strong>:</li>
<ul style="margin-left: 20px;">
<li><strong>Add New Category</strong>:</li>
<ul style="margin-left: 20px;">
<li>Name: Input field.</li>
<li><strong>Box Color</strong>: Color picker with eyedropper; checkbox for gradient.</li>
<li><strong>Color 2</strong>: Second color for gradient.</li>
<li><strong>Text Color</strong>: Color picker with eyedropper.</li>
<li><strong>Preview</strong>: Shows a live preview.</li>
<li>â <strong>Add Category</strong>: Adds the category.</li>
</ul>
<li><strong>Existing Categories</strong>: List with editing options.</li>
</ul>
<li><strong>Actions</strong>:</li>
<ul style="margin-left: 20px;">
<li>1. Create a new category and choose colors.</li>
<li>2. Click "Done" to close.</li>
</ul>
<li><strong>Application</strong>: Categories are applied to sections/boxes via â/ð¨ in the section header.</li>
</ul>
<h5 style="margin-top: 15px; margin-bottom: 5px;">3.4 Customize Font (ð )</h5>
<ul style="margin-left: 20px;">
<li><strong>Open</strong>: Click on "Formatting".</li>
<li><strong>Dialog Elements</strong>:</li>
<ul style="margin-left: 20px;">
<li><strong>Select Area</strong>: Columns, Sections, or Boxes.</li>
<li><strong>Font</strong>: Dropdown (Segoe UI (Default), Arial, Times New Roman, Courier New, Verdana, Georgia).</li>
<li><strong>Font Size (px)</strong>: Input field.</li>
<li><strong>Formatting</strong>: Checkboxes for Bold and Italic.</li>
</ul>
<li><strong>Aktionen</strong>:</li>
<ul style="margin-left: 20px;">
<li>1. Select the area and settings.</li>
<li>2. Click "Apply & Close".</li>
<li>3. Or "Cancel".</li>
</ul>
</ul>
<h5 style="margin-top: 15px; margin-bottom: 5px;">3.5 Save/Load Template (ð¾ / ð)</h5>
<ul style="margin-left: 20px;">
<li><strong>Save</strong>:</li>
<ul style="margin-left: 20px;">
<li>Opens a dialog to save to a list and download as JSON.</li>
</ul>
<li><strong>Load</strong>:</li>
<ul style="margin-left: 20px;">
<li><strong>Templates</strong>: Predefined (Organizational Chart, Office Map, Kanban).</li>
<li><strong>Saved Templates</strong>: List of local saves.</li>
<li><strong>Load Template from File</strong>: Upload a JSON file.</li>
</ul>
<li><strong>Actions</strong>:</li>
<ul style="margin-left: 20px;">
<li>1. Select a template.</li>
<li>2. Click "Close" after loading.</li>
</ul>
</ul>
<h4 style="margin-top: 20px; border-bottom: 1px solid #eee; padding-bottom: 5px;">4. Advanced Features</h4>
<ul style="margin-left: 20px;">
<li><strong>Splitting Columns</strong>: Use the split counter (2â3 parts). When dragging a split section: Hold Alt to drop it as full-width.</li>
<li><strong>Colors and Grid</strong>: â/ð¨ for colors; "Grid Lines" shows grid lines.</li>
<li><strong>Images</strong>: Only in boxes, note the maximum size.</li>
<li><strong>Help Dialog (â)</strong>: Contains detailed basics, save/load, export, and keyboard tips (in DE/EN).</li>
</ul>
<h4 style="margin-top: 20px; border-bottom: 1px solid #eee; padding-bottom: 5px;">5. Keyboard Shortcuts and Tips</h4>
<ul style="margin-left: 20px;">
<li><strong>Alt + Drop</strong>: Insert a split section as full-width.</li>
<li><strong>Ctrl + Drag</strong>: Duplicate (if enabled).</li>
<li><strong>General</strong>: Drag-and-drop for all elements; "New Column" in the header for expansion.</li>
<li><strong>Tips from Help</strong>: Use the grid for alignment; export cleans up borders/icons.</li>
</ul>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-danger" onclick="closeModal('helpModal')" data-translate="close">SchlieÃen</button>
            </div>
        </div>
    </div>
    
    <canvas id="exportCanvas" style="position: fixed; top: -10000px; left: -10000px; pointer-events: none;"></canvas>
    
    <script>
        // === LANGUAGE SWITCHER & TRANSLATIONS ===
        let currentLanguage = 'de';

        const translations = {
            de: {
                mainTitle: "ð¢ Explainator - Ultimate Edition",
                infoPanelTitle: "VollstÃ¤ndige Kontrolle:",
                infoPanelFeatures: "â Templates speichern & laden | â PNG Export | â Section-Farben anpassbar | â Sections innerhalb & zwischen Spalten verschiebbar | â Kategorien mit eigenen Farben verwalten | â Spalten verschieben & resize | â Drag & Drop Ã¼berall | â Stabile Section-FunktionalitÃ¤t | â 3-Spalten Split mÃ¶glich",
                formatting: "Formatierung",
                addColumn: "Neue Spalte",
                addBox: "Neue Box",
                manageCategories: "Kategorien verwalten",
                exportPNG: "Als PNG exportieren",
                gridLines: "Hilfslinien",
                gridLinesHide: "Hilfslinien aus",
                saveTemplate: "Template speichern",
                loadTemplate: "Template laden",
                resetLayout: "Layout zurÃ¼cksetzen",
                clearAll: "Alles lÃ¶schen",
                addBoxModalTitle: "Neue Box hinzufÃ¼gen",
                boxNamePlaceholder: "Box Name",
                newApplicationName: "Neue Anwendung",
                fullWidth: "Volle Breite",
                halfWidth: "Halbe Breite",
                boxHeightLabel: "HÃ¶he (Zeilen)",
                boxHeight1: "1 Zeile (Standard)",
                boxHeight2: "2 Zeilen",
                boxHeight3: "3 Zeilen",
                add: "HinzufÃ¼gen",
                cancel: "Abbrechen",
                textColorLabel: "Text:",
                imageMode: "Bild statt Text",
                imageSelectOrDrop: "Bild auswÃ¤hlen oder hierher ziehen (JPG/PNG)",
                imageMaxHeightHint: "Maximale HÃ¶he: 3 Ã 3âZeilen Boxen",
                alertChooseImage: "Bitte ein Bild (JPG/PNG) auswÃ¤hlen oder hineinziehen.",
                addNewCategoryTitle: "Neue Kategorie hinzufÃ¼gen:",
                categoryNamePlaceholder: "Kategorie Name (z.B. Cloud Services)",
                color1: "Farbe 1:",
                color2: "Farbe 2:",
                addCategory: "Kategorie hinzufÃ¼gen",
                existingCategories: "Vorhandene Kategorien:",
                delete: "LÃ¶schen",
                done: "Fertig",
                savedTemplates: "Gespeicherte Templates:",
                noSavedTemplates: "Keine gespeicherten Templates gefunden",
                loadTemplateFromFileTitle: "Template aus Datei laden:",
                loadFile: "Datei laden",
                close: "SchlieÃen",
                legendTitle: "Kategorien:",
                newColumn: "Neue Spalte",
                newSection: "Neue Section",
                confirmDeleteColumn: "Spalte wirklich lÃ¶schen?",
                confirmDeleteSection: "Section wirklich lÃ¶schen?",
                confirmResetLayout: "Layout wirklich zurÃ¼cksetzen?",
                confirmClearAll: "Wirklich alles lÃ¶schen?",
                alertEnterName: "Bitte geben Sie einen Namen ein!",
                alertCategoryAdded: "Kategorie \"{name}\" wurde hinzugefÃ¼gt!",
                alertOneCategoryNeeded: "Mindestens eine Kategorie muss vorhanden sein!",
                confirmDeleteCategory: "Kategorie \"{name}\" wirklich lÃ¶schen?",
                promptTemplateName: "Template Name eingeben:",
                defaultTemplateName: "Mein Template",
                alertTemplateSaved: "Template \"{name}\" gespeichert und heruntergeladen!",
                alertTemplateNotFound: "Template nicht gefunden!",
                confirmLoadTemplate: "Template \"{name}\" laden? Das aktuelle Layout wird Ã¼berschrieben.",
                alertTemplateLoaded: "Template \"{name}\" erfolgreich geladen!",
                alertChooseFile: "Bitte wÃ¤hlen Sie eine Datei aus!",
                confirmLoadFromFile: "Template \"{name}\" aus Datei laden? Das aktuelle Layout wird Ã¼berschrieben.",
                alertFileLoadError: "Fehler beim Laden der Template-Datei: ",
                alertFileLoaded: "Template \"{name}\" erfolgreich aus Datei geladen!",
                exporting: "Exportiere...",
                alertExportSuccess: "Sauberes PNG erfolgreich exportiert!",
                alertExportError: "Fehler beim Export: ",
                initialColumn1: "Spalte 1",
                initialColumn2: "Spalte 2",
                sectionColor: "Section-Farbe",
                columnColor: "Header-Farbe",
                splitColumnTooltip: "Spalte in 2-3 Teile teilen/zusammenfÃ¼hren",
                deleteSectionTooltip: "Section loeschen",
                help: "Hilfe",
                helpTitle: "Hilfe"
            },
            en: {
                mainTitle: "ð¢ Explainator - Ultimate Edition",
                infoPanelTitle: "Full Control:",
                infoPanelFeatures: "â Save & Load Templates | â PNG Export | â Adjustable Section Colors | â Move Sections within & between Columns | â Manage Categories with Custom Colors | â Move & Resize Columns | â Drag & Drop Everywhere | â Stable Section Functionality | â 3-Column Split Possible",
                formatting: "Formatting",
                addColumn: "New Column",
                addBox: "New Box",
                manageCategories: "Manage Categories",
                exportPNG: "Export as PNG",
                gridLines: "Grid Lines",
                gridLinesHide: " Hide Grid Lines",
                saveTemplate: "Save Template",
                loadTemplate: "Load Template",
                resetLayout: "Reset Layout",
                clearAll: "Clear All",
                addBoxModalTitle: "Add New Box",
                boxNamePlaceholder: "Box Name",
                newApplicationName: "New Application",
                fullWidth: "Full Width",
                halfWidth: "Half Width",
                boxHeightLabel: "Height (lines)",
                boxHeight1: "1 line (default)",
                boxHeight2: "2 lines",
                boxHeight3: "3 lines",
                add: "Add",
                cancel: "Cancel",
                textColorLabel: "Text:",
                imageMode: "Image instead of text",
                imageSelectOrDrop: "Select or drop an image (JPG/PNG)",
                imageMaxHeightHint: "Max height: 3 Ã 3âline boxes",
                alertChooseImage: "Please select or drop an image (JPG/PNG).",
                addNewCategoryTitle: "Add New Category:",
                categoryNamePlaceholder: "Category Name (e.g., Cloud Services)",
                color1: "Color 1:",
                color2: "Color 2:",
                addCategory: "Add Category",
                existingCategories: "Existing Categories:",
                delete: "Delete",
                done: "Done",
                savedTemplates: "Saved Templates:",
                noSavedTemplates: "No saved templates found",
                loadTemplateFromFileTitle: "Load Template from File:",
                loadFile: "Load File",
                close: "Close",
                legendTitle: "Categories:",
                newColumn: "New Column",
                newSection: "New Section",
                confirmDeleteColumn: "Really delete column?",
                confirmDeleteSection: "Really delete section?",
                confirmResetLayout: "Really reset layout?",
                confirmClearAll: "Really delete everything?",
                alertEnterName: "Please enter a name!",
                alertCategoryAdded: "Category \"{name}\" has been added!",
                alertOneCategoryNeeded: "At least one category must exist!",
                confirmDeleteCategory: "Really delete category \"{name}\"?",
                promptTemplateName: "Enter Template Name:",
                defaultTemplateName: "My Template",
                alertTemplateSaved: "Template \"{name}\" saved and downloaded!",
                alertTemplateNotFound: "Template not found!",
                confirmLoadTemplate: "Load template \"{name}\"? The current layout will be overwritten.",
                alertTemplateLoaded: "Template \"{name}\" loaded successfully!",
                alertChooseFile: "Please select a file!",
                confirmLoadFromFile: "Load template \"{name}\" from file? The current layout will be overwritten.",
                alertFileLoadError: "Error loading template file: ",
                alertFileLoaded: "Template \"{name}\" successfully loaded from file!",
                exporting: "Exporting...",
                alertExportSuccess: "Clean PNG exported successfully!",
                alertExportError: "Error during export: ",
                initialColumn1: "Column 1",
                initialColumn2: "Column 2",
                sectionColor: "Section Color",
                columnColor: "Header Color",
                splitColumnTooltip: "Split/merge column into 2-3 parts",
                deleteSectionTooltip: "Delete section",
                help: "Help",
                helpTitle: "Help"
            }
        };

        function setLanguage(lang) {
            currentLanguage = lang;
            document.documentElement.lang = lang;
            localStorage.setItem('ea_language', lang);

            const langSwitchBtn = document.getElementById('langSwitchBtn');
            if(langSwitchBtn) langSwitchBtn.textContent = lang === 'de' ? 'EN' : 'DE';

            const t = translations[lang];

            document.querySelectorAll('[data-translate]').forEach(el => {
                const key = el.dataset.translate;
                if (t[key]) {
                    el.innerHTML = t[key];
                }
            });

            // If help is open, switch language content
            const hm = document.getElementById('helpModal');
            if (hm && hm.classList.contains('show')) {
                const de = hm.querySelector('.help-de');
                const en = hm.querySelector('.help-en');
                if(de && en){
                    if(lang === 'de'){ de.style.display='block'; en.style.display='none'; }
                    else { de.style.display='none'; en.style.display='block'; }
                }
            }
            
            // Special handling for placeholders
            const boxNameInput = document.getElementById('boxName');
            if(boxNameInput) boxNameInput.placeholder = t.boxNamePlaceholder;

            const categoryNameInput = document.getElementById('categoryName');
            if(categoryNameInput) categoryNameInput.placeholder = t.categoryNamePlaceholder;

            // Update dynamically created elements like buttons
            document.querySelectorAll('.add-section-btn').forEach(btn => btn.textContent = `+ ${t.newSection}`);

            // Update legend title
            updateLegend();
            // Equalize header heights after text changes
            requestAnimationFrame(equalizeHeaderHeights);
        }

        function toggleLanguage() {
            const newLang = currentLanguage === 'de' ? 'en' : 'de';
            setLanguage(newLang);
        }

        // Global variables
        let draggedElement = null;
        let columnIdCounter = 1;
        try { window.columnIdCounter = columnIdCounter; } catch(_) {}
        let isResizing = false;
        let currentResizeColumn = null;
        let startX = 0;
        let startWidth = 0;

        let sectionColorPalette = [
            { name: 'Standard', color: '#8B4513' }, { name: 'Blau', color: '#2196F3' }, { name: 'GrÃ¼n', color: '#4CAF50' },
            { name: 'Orange', color: '#FF9800' }, { name: 'Lila', color: '#9C27B0' }, { name: 'Rot', color: '#F44336' },
            { name: 'Grau', color: '#607D8B' }, { name: 'Teal', color: '#009688' }, { name: 'Grau 0%', color: '#000000' },
            { name: 'Grau 10%', color: '#1A1A1A' }, { name: 'Grau 20%', color: '#333333' }, { name: 'Grau 30%', color: '#4D4D4D' },
            { name: 'Grau 40%', color: '#666666' }, { name: 'Grau 50%', color: '#808080' }, { name: 'Grau 60%', color: '#999999' },
            { name: 'Grau 70%', color: '#B3B3B3' }, { name: 'Grau 80%', color: '#CCCCCC' }, { name: 'Grau 90%', color: '#E6E6E6' },
            { name: 'Grau 100%', color: '#FFFFFF' }
        ];
        
        // Category management - Start with default categories
        let categories = {
            'cat1': { name: 'Cat. 1', color1: '#667eea', color2: '#764ba2', textColor: '#ffffff' },
            'cat2': { name: 'Cat. 2', color1: '#f093fb', color2: '#f5576c', textColor: '#ffffff' },
            'cat3': { name: 'Cat. 3', color1: '#fa709a', color2: '#fee140', textColor: '#1a1a1a' },
            'cat4': { name: 'Cat. 4', color1: '#84fab0', color2: '#8fd3f4', textColor: '#1a1a1a' },
            'cat5': { name: 'Cat. 5', color1: '#a8edea', color2: '#fed6e3', textColor: '#1a1a1a' }
        };
        
        // Image modal state + last focused section box-container
        let pendingImageDataUrl = null;
        let lastFocusedBoxContainer = null;

        // Initialize on load
        document.addEventListener('DOMContentLoaded', function() {
            const savedLang = localStorage.getItem('ea_language') || 'de';
            setLanguage(savedLang);

            initializeDragAndDrop();
            initializeResize();
            initializeColumnDrag();
            updateCategoryStyles();
            updateCategoryDropdown();
            updateLegend();
            initializeDefaultLayout();
            setupImageModal();
            setupLastFocusTracking();
            normalizeDeleteIcons(document);
            setupDeleteIconObserver();
            equalizeHeaderHeights();
            window.addEventListener('resize', () => equalizeHeaderHeights());

            document.getElementById('categoryColor1').addEventListener('input', updateColorPreview);
            document.getElementById('categoryColor2').addEventListener('input', updateColorPreview);
            var tci = document.getElementById('categoryTextColor');
            if (tci) tci.addEventListener('input', updateColorPreview);

            // Ensure initial box heights reflect their line count
            try { applyBoxLayoutAll(document); } catch(_){}
        });

        function equalizeHeaderHeights() {
            try {
                const headers = Array.from(document.querySelectorAll('.column-header'));
                if (!headers.length) return;
                // Reset heights first to measure natural single-line heights
                headers.forEach(h => h.style.minHeight = '');
                const heights = headers.map(h => h.scrollHeight);
                const minH = Math.min(...heights);
                const maxH = Math.max(...heights);
                const wrapDetected = (maxH - minH) > 6; // tolerance
                if (!wrapDetected) {
                    headers.forEach(h => h.style.minHeight = maxH + 'px');
                } else {
                    headers.forEach(h => h.style.minHeight = '');
                }
            } catch(e) {}
        }

        function setupImageModal() {
            const chk = document.getElementById('boxIsImage');
            const textOpts = document.getElementById('textOptions');
            const linesLabel = document.getElementById('boxLinesLabel');
            const linesSel = document.getElementById('boxLines');
            const imgOpts = document.getElementById('imageOptions');
            const fileInput = document.getElementById('boxImageFile');
            const dz = document.getElementById('imageDropzone');
            const t = translations[currentLanguage];

            if (dz) dz.textContent = t.imageSelectOrDrop || dz.textContent;

            if (chk) {
                chk.addEventListener('change', () => {
                    const on = chk.checked;
                    if (textOpts) textOpts.style.display = on ? 'none' : 'flex';
                    if (linesLabel) linesLabel.style.display = on ? 'none' : 'block';
                    if (linesSel) linesSel.style.display = on ? 'none' : 'block';
                    if (imgOpts) imgOpts.style.display = on ? 'block' : 'none';
                });
            }

            if (fileInput) {
                fileInput.addEventListener('change', (e) => {
                    if (e.target.files && e.target.files.length) {
                        handleImageFiles(e.target.files);
                    }
                });
            }

            if (dz) {
                ;['dragenter','dragover'].forEach(evt => dz.addEventListener(evt, (e) => {
                    e.preventDefault(); e.stopPropagation(); dz.classList.add('dragover');
                }));
                ;['dragleave','dragend','drop'].forEach(evt => dz.addEventListener(evt, (e) => {
                    dz.classList.remove('dragover');
                }));
                dz.addEventListener('drop', (e) => {
                    e.preventDefault(); e.stopPropagation();
                    const files = e.dataTransfer && e.dataTransfer.files ? e.dataTransfer.files : null;
                    if (files && files.length) handleImageFiles(files);
                });
            }
        }

        function handleImageFiles(fileList) {
            const file = Array.from(fileList).find(f => /image\/(png|jpeg)/i.test(f.type));
            if (!file) { alert(translations[currentLanguage].alertChooseImage); return; }
            const reader = new FileReader();
            reader.onload = () => { setImagePreview(reader.result); };
            reader.readAsDataURL(file);
        }

        function setImagePreview(dataUrl) {
            pendingImageDataUrl = dataUrl;
            const prev = document.getElementById('imagePreview');
            if (prev) {
                prev.innerHTML = `<img src="${dataUrl}" alt="preview" />`;
                prev.style.display = 'block';
            }
        }

        function setupLastFocusTracking() {
            document.addEventListener('click', (e) => {
                const bc = e.target.closest && e.target.closest('.box-container');
                if (bc) { lastFocusedBoxContainer = bc; return; }
                const sg = e.target.closest && e.target.closest('.section-group');
                if (sg) {
                    const inner = sg.querySelector(':scope > .box-container');
                    if (inner) lastFocusedBoxContainer = inner;
                }
            }, true);
        }

        function getTargetBoxContainer() {
            if (lastFocusedBoxContainer && document.body.contains(lastFocusedBoxContainer)) return lastFocusedBoxContainer;
            return document.querySelector('.box-container');
        }

        function normalizeDeleteIcons(root) {
            const scope = root || document;
            scope.querySelectorAll('.delete-btn, .section-delete, .delete-column').forEach(el => { el.textContent = 'x'; });
        }

        function setupDeleteIconObserver() {
            try {
                const mo = new MutationObserver((mutations) => {
                    for (const m of mutations) {
                        m.addedNodes && m.addedNodes.forEach(node => {
                            if (!(node instanceof Element)) return;
                            normalizeDeleteIcons(node);
                        });
                    }
                });
                mo.observe(document.body, { childList: true, subtree: true });
            } catch(e) {}
        }
        
        function initializeDefaultLayout() {
            const container = document.getElementById('mainContainer');
            const t = translations[currentLanguage];
            
            const column1 = createColumnElement(t.initialColumn1, columnIdCounter++);
            const column2 = createColumnElement(t.initialColumn2, columnIdCounter++);
            
            container.innerHTML = '';
            container.appendChild(column1);
            container.appendChild(column2);
            
            const addBtn = document.createElement('div');
            addBtn.className = 'add-column';
            addBtn.onclick = addNewColumn;
            addBtn.innerHTML = '<span>+</span>';
            container.appendChild(addBtn);
            try { window.columnIdCounter = Math.max(window.columnIdCounter||0, columnIdCounter); } catch(_) {}
        }

        
        
        function createColumnElement(title, id) {
            const column = document.createElement('div');
            const t = translations[currentLanguage];
            column.className = 'column';
            column.setAttribute('data-column-id', id);
            column.setAttribute('data-split-state', 'normal');
            column.innerHTML = `
                <div class="column-header" draggable="true">
                     ${title} 
                    <span class="header-btn color-column-btn" title="${t.columnColor}" draggable="false" onmousedown="event.stopPropagation();event.preventDefault();" onpointerdown="event.stopPropagation();event.preventDefault();" onclick="showColumnColorPicker(this)">ðï¸</span>


                    <span class="header-btn delete-column" onclick="deleteColumn(this)">Ã</span>
                </div>
                <div class="resize-handle"></div>
                <div class="column-content">
                    <div class="section-group" draggable="true">
                        <div class="section-title">
                            ${t.newSection}
                            <span class="section-delete" onclick="deleteSection(this)" title="${t.deleteSectionTooltip}">Ã</span>
                            <span class="section-menu" onclick="showSectionColorPicker(this)">ð¨</span>
                        </div>
                        <div class="box-container"></div>
                    </div>
                </div>
            `;
            // Ensure split counter exists and reflects current parts
            try {
                const del1 = column.querySelector('.delete-column'); if (del1) del1.textContent = 'x';
                const del2 = column.querySelector('.section-delete'); if (del2) del2.textContent = 'x';
                const header = column.querySelector('.column-header');
                const del = header.querySelector('.delete-column');
                let counter = header.querySelector('.split-counter');
                if (!counter) {
                    counter = document.createElement('span');
                    counter.className = 'split-counter';
                    counter.setAttribute('title', t.splitColumnTooltip);
                    counter.innerHTML = '\n                        <button onclick="decrementSplit(this); event.stopPropagation();" onmousedown="event.stopPropagation();">-</button>\n                        <span class="value">1</span>\n                        <button onclick="incrementSplit(this); event.stopPropagation();" onmousedown="event.stopPropagation();">+</button>\n                    ';
                    header.insertBefore(counter, del);
                }
                if (!column.hasAttribute('data-split-parts')) column.setAttribute('data-split-parts', '1');
                updateSplitCounterDisplay(column);
            } catch(e) {}
            // Ensure consistent header height alignment
            requestAnimationFrame(equalizeHeaderHeights);
            return column;
        }

        function splitColumn(column, parts) {
            const content = column.querySelector('.column-content');
            const sections = Array.from(content.querySelectorAll('.section-group'));
            
            column.classList.remove('split-column', 'split-column-3');
            
            const splitContainer = document.createElement('div');
            splitContainer.className = 'column-split-content';
            
            for (let i = 0; i < parts; i++) {
                const partDiv = document.createElement('div');
                partDiv.className = 'column-part';
                
                const sectionsPerSplit = Math.ceil(sections.length / parts);
                const startIndex = i * sectionsPerSplit;
                const endIndex = Math.min((i + 1) * sectionsPerSplit, sections.length);
                
                for (let j = startIndex; j < endIndex; j++) {
                    if (sections[j]) partDiv.appendChild(sections[j]);
                }
                
                splitContainer.appendChild(partDiv);
            }
            
            content.innerHTML = '';
            content.appendChild(splitContainer);
            // Do not force width on split; user controls size by dragging
        }

        function unsplitColumn(column) {
            const content = column.querySelector('.column-content');
            const splitContainer = content.querySelector('.column-split-content');
            
            if (splitContainer) {
                const allSections = Array.from(splitContainer.querySelectorAll('.section-group'));
                column.classList.remove('split-column', 'split-column-3');
                content.innerHTML = '';
                allSections.forEach(section => content.appendChild(section));
            }
        }

        function updateSplitCounterDisplay(column) {
            const valueSpan = column.querySelector('.split-counter .value');
            if (!valueSpan) return;
            const p = parseInt(column.getAttribute('data-split-parts') || '1', 10) || 1;
            valueSpan.textContent = String(p);
        }

        function applySplit(column, parts) {
            const p = Math.max(1, parseInt(parts, 10) || 1);
            column.setAttribute('data-split-parts', String(p));
            updateSplitCounterDisplay(column);
            if (p === 1) {
                unsplitColumn(column);
                column.setAttribute('data-split-state', 'normal');
            } else {
                splitColumn(column, p);
                column.setAttribute('data-split-state', p === 2 ? 'split-2' : (p === 3 ? 'split-3' : 'split-n'));
            }
            requestAnimationFrame(equalizeHeaderHeights);
        }

        function incrementSplit(btn) {
            const column = btn.closest('.column');
            const parts = parseInt(column.getAttribute('data-split-parts') || '1', 10);
            applySplit(column, parts + 1);
        }

        function decrementSplit(btn) {
            const column = btn.closest('.column');
            const parts = parseInt(column.getAttribute('data-split-parts') || '1', 10);
            applySplit(column, Math.max(1, parts - 1));
        }

        function cloneColumn(btn){
            const orig = btn.closest('.column');
            if (!orig) return;
            const parent = orig.parentElement;
            const clone = orig.cloneNode(true);
            clone.setAttribute('data-column-id', ++columnIdCounter);
            try { window.columnIdCounter = Math.max(window.columnIdCounter||0, columnIdCounter); } catch(_) {}
            // remove any open pickers within clone
            clone.querySelectorAll('.column-color-picker, .section-color-picker').forEach(el => el.remove());
            // keep split parts attribute/state
            const parts = parseInt(orig.getAttribute('data-split-parts') || '1', 10);
            clone.setAttribute('data-split-parts', String(parts));
            // insert after original
            parent.insertBefore(clone, orig.nextSibling);
            // placeholders entfernt
            // Harden interactive buttons on the clone so clicks are not swallowed by drag
            try {
                const harden = (root) => {
                    root.querySelectorAll('.color-column-btn, .section-menu, .pipette-column-btn, .section-pipette').forEach(btnEl => {
                        btnEl.setAttribute('draggable','false');
                        ['pointerdown','mousedown','dragstart'].forEach(evt => {
                            btnEl.addEventListener(evt, (ev) => { ev.stopPropagation(); ev.preventDefault(); }, true);
                        });
                    });
                };
                harden(clone);
            } catch(_) {}
            // Trigger observers to (re)attach any dynamic icons (pipette etc.)
            try { requestAnimationFrame(() => { /* no-op to allow MutationObservers to run */ }); } catch(_){}
        }
        
        function updateColorPreview() {
            const color1 = document.getElementById('categoryColor1').value;
            const useGrad = document.getElementById('useGradient') && document.getElementById('useGradient').checked;
            const color2 = useGrad ? (document.getElementById('categoryColor2').value || color1) : color1;
            const textColor = (document.getElementById('categoryTextColor') && document.getElementById('categoryTextColor').value) || '#ffffff';
            const prev = document.getElementById('colorPreview');
            prev.style.background = `linear-gradient(135deg, ${color1} 0%, ${color2} 100%)`;
            prev.style.color = textColor;
        }
        
        function updateCategoryStyles() {
            let styleEl = document.getElementById('dynamic-styles');
            if (!styleEl) {
                styleEl = document.createElement('style');
                styleEl.id = 'dynamic-styles';
                document.head.appendChild(styleEl);
            }
            let styles = '';
            for (const [key, cat] of Object.entries(categories)) {
                const c1 = cat.color1; const c2 = cat.color2 || cat.color1;
                const tc = cat.textColor ? cat.textColor : (isLightColor(c1) ? '#1a1a1a' : 'white');
                styles += `.${key} { background: linear-gradient(135deg, ${c1} 0%, ${c2} 100%); color: ${tc}; border: none; }`;
            }
            styleEl.innerHTML = styles;
        }
        
        function isLightColor(color) {
            const hex = color.replace('#', '');
            const r = parseInt(hex.substr(0, 2), 16);
            const g = parseInt(hex.substr(2, 2), 16);
            const b = parseInt(hex.substr(4, 2), 16);
            return ((r * 299) + (g * 587) + (b * 114)) / 1000 > 155;
        }
        
        function updateCategoryDropdown() {
            const select = document.getElementById('boxType');
            select.innerHTML = '';
            for (const [key, cat] of Object.entries(categories)) {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = cat.name;
                select.appendChild(option);
            }
        }
        
        function updateLegend() {
            const legend = document.getElementById('legend');
            const t = translations[currentLanguage];
            legend.innerHTML = `<strong style="margin-right: 20px;">${t.legendTitle}</strong>`;
            for (const [key, cat] of Object.entries(categories)) {
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.onclick = () => filterByCategory(key);
                item.innerHTML = `<div class="legend-box" style="background: linear-gradient(135deg, ${cat.color1} 0%, ${cat.color2} 100%)"></div><span>${cat.name}</span>`;
                legend.appendChild(item);
            }
        }

        // ============ Box height model (base-lines + dynamic) ============
        const ROW_HEIGHT = 30;
        function getBaseLines(box){
            return parseInt(box.getAttribute('data-base-lines') || box.getAttribute('data-lines') || box.dataset.lines || '1', 10) || 1;
        }
        function setBaseLines(box, ln){
            box.setAttribute('data-base-lines', String(ln));
            box.setAttribute('data-lines', String(ln)); // backward compatibility
        }
        function setDynamic(box, dyn){ box.setAttribute('data-dynamic', dyn ? '1' : '0'); }
        function isDynamic(box){ return (box.getAttribute('data-dynamic') || '0') === '1'; }
        function applyBoxLayout(box){
            const ln = getBaseLines(box);
            const base = (ln * ROW_HEIGHT) + 'px';
            box.style.minHeight = base;
            // Image boxes: never fix height; allow image CSS to control size
            if (box.classList && box.classList.contains('image-box')) {
                box.style.height = '';
                return;
            }
            // Line boxes: keep their own thin height/border rendering; do not alter
            if (box.classList && box.classList.contains('line-box')) {
                return;
            }
            // If user resized via handle, preserve explicit height
            if (box.dataset && box.dataset.resized === '1') {
                return;
            }
            if (!isDynamic(box)) {
                // fixed-height box
                box.style.height = base;
            } else {
                // dynamic box grows with content
                box.style.height = '';
            }
        }
        function enforceBoxHeights(root){
            const scope = root || document;
            scope.querySelectorAll('.app-box').forEach(applyBoxLayout);
        }
        function applyBoxLayoutAll(root){
            const scope = root || document;
            enforceBoxHeights(scope);
            scope.querySelectorAll('.app-box').forEach(checkOverflowAndToggle);
        }
        function checkOverflowAndToggle(box){
            // Never auto-toggle for special/resized boxes
            if (box.classList && (box.classList.contains('image-box') || box.classList.contains('line-box'))) return;
            if (box.dataset && box.dataset.resized === '1') { return; }
            if (box.dataset && box.dataset.noauto === '1') { return; }
            if ((box.getAttribute && box.getAttribute('data-dynamic') === '1')) { return; }
            const ln = getBaseLines(box);
            const baseH = ln * ROW_HEIGHT;
            const ch = box.clientHeight || baseH;
            // Robust overflow detection with tolerance to avoid jitter from subpixel/layout effects
            const over = (box.scrollHeight > (baseH + 4)) && (box.scrollHeight > (ch + 2));
            if (over && !isDynamic(box)) setDynamic(box, true);
            applyBoxLayout(box);
        }
        
        function showCategoryModal() {
            document.getElementById('categoryModal').classList.add('show');
            updateCategoryList();
            // Render preset swatches for quick selection
            const palette = ['#8B4513','#A0522D','#CD853F','#D2691E','#FF9800','#FFC107','#FF5722','#2196F3','#1E88E5','#64B5F6','#00BCD4','#009688','#4CAF50','#8BC34A','#9C27B0','#AB47BC','#E91E63','#F44336','#607D8B','#455A64','#000000','#333333','#666666','#999999','#CCCCCC','#FFFFFF'];
            const sw1 = document.getElementById('catSwatches1');
            const sw2 = document.getElementById('catSwatches2');
            if (sw1) sw1.innerHTML = palette.map(c=>`<div class="swatch" data-target="categoryColor1" data-c="${c}" style="width:22px;height:22px;border-radius:4px;border:1px solid #bbb;cursor:pointer;background:${c}"></div>`).join('');
            if (sw2) sw2.innerHTML = palette.map(c=>`<div class="swatch" data-target="categoryColor2" data-c="${c}" style="width:22px;height:22px;border-radius:4px;border:1px solid #bbb;cursor:pointer;background:${c}"></div>`).join('');
            document.getElementById('catColorGroup').addEventListener('click', function(e){
                const s = e.target.closest && e.target.closest('.swatch');
                if (!s) return;
                const target = s.getAttribute('data-target');
                const color = s.getAttribute('data-c');
                const input = document.getElementById(target);
                if (input) { input.value = color; updateColorPreview(); }
            });
            toggleGradient();
        }

        // === LAYOUT BUILDER ===
        function showLayoutBuilder(){
            const m = document.getElementById('layoutBuilderModal');
            document.getElementById('lbColumns').value = Math.max(1, document.querySelectorAll('.column').length || 2);
            renderLayoutBuilderGrid();
            m.classList.add('show');
        }

        function renderLayoutBuilderGrid(){
            const n = parseInt(document.getElementById('lbColumns').value, 10) || 1;
            const grid = document.getElementById('lbGrid');
            grid.innerHTML = '';
            for (let i=0;i<n;i++){
                const row = document.createElement('div');
                row.style.display='grid';
                row.style.gridTemplateColumns='1fr 1fr 1fr';
                row.style.gap='8px';
                row.style.alignItems='center';
                row.innerHTML = `
                    <div>
                        <label>Titel</label>
                        <input type="text" class="lbTitle" data-index="${i}" value="Spalte ${i+1}" style="width:100%">
                    </div>
                    <div>
                        <label>Splits</label>
                        <input type="number" class="lbSplits" data-index="${i}" min="1" max="8" value="1" style="width:100%">
                    </div>
                    <div>
                        <label>Sections/Teil</label>
                        <input type="number" class="lbSections" data-index="${i}" min="0" max="20" value="1" style="width:100%">
                    </div>`;
                grid.appendChild(row);
            }
        }

        function applyLayoutBuilder(){
            const cols = parseInt(document.getElementById('lbColumns').value,10) || 1;
            const titles = Array.from(document.querySelectorAll('#lbGrid .lbTitle')).map(i=>i.value.trim()||'Spalte');
            const splits = Array.from(document.querySelectorAll('#lbGrid .lbSplits')).map(i=>Math.max(1, parseInt(i.value,10)||1));
            const sections = Array.from(document.querySelectorAll('#lbGrid .lbSections')).map(i=>Math.max(0, parseInt(i.value,10)||0));

            const container = document.getElementById('mainContainer');
            container.innerHTML = '';
            for (let i=0;i<cols;i++){
                const col = createColumnElement(titles[i] || `Spalte ${i+1}`, i+1);
                container.appendChild(col);
                const parts = splits[i] || 1;
                if (parts > 1) applySplit(col, parts);
                const per = sections[i] || 0;
                if (parts === 1){
                    // Remove default section, then add desired
                    const content = col.querySelector('.column-content');
                    const def = content.querySelector('.section-group');
                    if (def) def.remove();
                    for (let s=0;s<per;s++){
                        const btn = content.querySelector('.add-section-btn');
                        addSection(btn);
                    }
                } else {
                    const partsNodes = col.querySelectorAll('.column-part');
                    partsNodes.forEach(pNode => {
                        // Remove any default section in part
                        const defS = pNode.querySelector('.section-group'); if (defS) defS.remove();
                        const btn = pNode.querySelector('.add-section-btn');
                        for (let s=0;s<per;s++){ addSection(btn); }
                    });
                }
            }
            // Add trailing + column button
            const addBtn = document.createElement('div');
            addBtn.className='add-column'; addBtn.onclick=addNewColumn; addBtn.innerHTML='<span>+</span>';
            container.appendChild(addBtn);
            // placeholders entfernt
            closeModal('layoutBuilderModal');
        }
        
        function updateCategoryList() {
            const list = document.getElementById('categoryList');
            list.innerHTML = '';
            const t = translations[currentLanguage];
            for (const [key, cat] of Object.entries(categories)) {
                const item = document.createElement('div');
                item.className = 'category-item';
                const c2 = cat.color2 || cat.color1;
                item.innerHTML = `
                    <div class="category-preview" style="background: linear-gradient(135deg, ${cat.color1} 0%, ${c2} 100%); color:${cat.textColor || (isLightColor(cat.color1)?'#1a1a1a':'#ffffff')}; display:flex; align-items:center; justify-content:center; font-weight:600;">Box</div>
                    <div class="category-controls">
                        <input type="text" value="${cat.name}" onchange="updateCategoryName('${key}', this.value)">
                        <input type="color" value="${cat.color1}" onchange="updateCategoryColor('${key}', this.value, '${c2}')">
                        <input type="color" value="${c2}" onchange="updateCategoryColor('${key}', '${cat.color1}', this.value)">
                        <input type="color" value="${cat.textColor || '#ffffff'}" title="Text-Farbe" onchange="updateCategoryTextColor('${key}', this.value)">
                        <button class="btn btn-danger small-btn" onclick="deleteCategory('${key}')">${t.delete}</button>
                    </div>`;
                list.appendChild(item);
            }
        }
        
        function addCategory() {
            const name = document.getElementById('categoryName').value.trim();
            const color1 = document.getElementById('categoryColor1').value;
            const useGrad = document.getElementById('useGradient').checked;
            const color2 = useGrad ? (document.getElementById('categoryColor2').value || color1) : color1;
            const textColor = (document.getElementById('categoryTextColor') && document.getElementById('categoryTextColor').value) || '#ffffff';
            const t = translations[currentLanguage];
            if (!name) { alert(t.alertEnterName); return; }
            
            const key = 'cat-' + Date.now();
            categories[key] = { name, color1, color2, textColor };
            
            updateCategoryStyles(); updateCategoryDropdown(); updateLegend(); updateCategoryList();
            document.getElementById('categoryName').value = '';
        }
        
        function updateCategoryName(key, newName) {
            if (categories[key] && newName.trim()) {
                categories[key].name = newName.trim();
                updateCategoryDropdown(); updateLegend();
            }
        }
        
        function updateCategoryColor(key, color1, color2) {
            if (categories[key]) {
                categories[key].color1 = color1; categories[key].color2 = color2;
                updateCategoryStyles(); updateLegend(); updateCategoryList();
            }
        }

        function updateCategoryTextColor(key, textColor) {
            if (categories[key]) {
                categories[key].textColor = textColor;
                updateCategoryStyles(); updateLegend(); updateCategoryList();
            }
        }

        function toggleGradient(){
            const row = document.getElementById('gradientRow');
            const sw2 = document.getElementById('catSwatches2');
            const chk = document.getElementById('useGradient');
            if (!row || !chk) return;
            const show = chk.checked;
            row.style.display = show ? 'flex' : 'none';
            if (sw2) sw2.style.display = show ? 'flex' : 'none';
            updateColorPreview();
        }

        async function pickEyeDropper(targetId){
            try{
                if (!('EyeDropper' in window)) { alert('Pipette wird von diesem Browser nicht unterstÃ¼tzt.'); return; }
                const ed = new EyeDropper();
                const res = await ed.open();
                const input = document.getElementById(targetId);
                if (input) { input.value = res.sRGBHex; updateColorPreview(); }
            }catch(err){ /* user cancelled */ }
        }
        
        function deleteCategory(key) {
            const t = translations[currentLanguage];
            if (Object.keys(categories).length <= 1) { alert(t.alertOneCategoryNeeded); return; }
            if (confirm(t.confirmDeleteCategory.replace('{name}', categories[key].name))) {
                delete categories[key];
                updateCategoryStyles(); updateCategoryDropdown(); updateLegend(); updateCategoryList();
            }
        }
        
        function filterByCategory(key) {
            document.querySelectorAll('.app-box').forEach(box => box.style.opacity = box.classList.contains(key) ? '1' : '0.3');
            setTimeout(() => document.querySelectorAll('.app-box').forEach(box => box.style.opacity = '1'), 2000);
        }

        function toggleGridLines() {
            const container = document.querySelector('.main-container');
            const btn = document.getElementById('gridToggleBtn');
            const t = translations[currentLanguage];
            container.classList.toggle('grid-lines');
            btn.textContent = container.classList.contains('grid-lines') ? t.gridLinesHide : t.gridLines;
        }
        
// HELFER-FUNKTION: Findet heraus, vor welches BOX-Element eingefÃ¼gt werden soll.
        function getDragAfterElement(container, x, y) {
            const draggableElements = [...container.querySelectorAll('.app-box:not(.dragging)')];

            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offsetY = y - box.top - box.height / 2;
                
                // Find the element we are vertically closest to being "before"
                if (offsetY < 0 && offsetY > closest.offset) {
                    return { offset: offsetY, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        // HELFER-FUNKTION: Findet heraus, vor welches SECTION-Element eingefÃ¼gt werden soll.
        function getDragAfterSection(container, y) {
            const draggableElements = [...container.querySelectorAll('.section-group:not(.dragging)')];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        // Calculates insertion point among direct children (sections or split blocks)
        function getDragAfterBlock(container, y) {
            const selector = ':scope > .section-group:not(.dragging), :scope > .column-split-content:not(.dragging)';
            const elements = [...container.querySelectorAll(selector)];
            return elements.reduce((closest, el) => {
                const rect = el.getBoundingClientRect();
                const offset = y - rect.top - rect.height / 2;
                if (offset < 0 && offset > closest.offset) {
                    return { offset, element: el };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        // ==================================================================
        // FINALE, KOMPLETTE DRAG & DROP FUNKTION
        // ==================================================================
        function initializeDragAndDrop() {
            let draggedElement = null; // Das Element, das WIRKLICH bewegt wird
            let placeholder = null;    // Das visuelle Feedback-Element
            let isCloning = false;     // Merkt sich, ob wir gerade klonen
            let draggedFromSplit = false; // Ursprung in .column-part?
            let sourceSplitParts = 0;      // Anzahl Parts im Ursprungs-Split
            let lastDragX = 0;             // letzte Maus-X-Position
            let selectedGroup = null;      // Mehrfachauswahl von Boxen

            // Mehrfachauswahl per STRG-Klick
            function getSelectedBoxes(){ return Array.from(document.querySelectorAll('.app-box.selected')); }
            function clearSelection(){ document.querySelectorAll('.app-box.selected').forEach(el => el.classList.remove('selected')); }
            document.addEventListener('click', function(e){
                const box = e.target && e.target.closest && e.target.closest('.app-box');
                if (!box) { if (!e.ctrlKey) clearSelection(); return; }
                if (e.ctrlKey) { e.preventDefault(); e.stopPropagation(); box.classList.toggle('selected'); }
                else { clearSelection(); }
            }, true);

            document.addEventListener('dragstart', function(e) {
                const target = e.target.closest && e.target.closest('.app-box, .section-group, .column-split-content');
                if (!target) return;
                if (target.classList.contains('section-group') && target.querySelector('.section-title input')) return;

                isCloning = e.ctrlKey;
                
                // Build group when dragging a selected app-box (non-clone)
                selectedGroup = null;
                if (target.classList.contains('app-box')) {
                    const sel = getSelectedBoxes();
                    if (sel.length > 1 && sel.includes(target)) selectedGroup = sel;
                }

                if (isCloning && !selectedGroup) {
                    draggedElement = target.cloneNode(true);
                    draggedElement.classList.add('dragging');
                } else {
                    draggedElement = target;
                    setTimeout(() => target.classList.add('dragging'), 0);
                }
                
                placeholder = document.createElement('div');
                placeholder.classList.add('dragging-placeholder');
                if (target.classList.contains('section-group')) {
                    placeholder.style.height = '100px';
                } else if (selectedGroup && target.classList.contains('app-box')) {
                    try { const sum = selectedGroup.reduce((s,el)=>s+el.offsetHeight,0); placeholder.style.height = sum + 'px'; } catch(_){ placeholder.style.height = target.offsetHeight + 'px'; }
                } else {
                    placeholder.style.height = target.offsetHeight + 'px';
                }
                // Track origin split context
                if (target.classList.contains('section-group')) {
                    const srcPart = target.closest('.column-part');
                    draggedFromSplit = !!srcPart;
                    const srcSplit = srcPart ? srcPart.parentElement : null;
                    sourceSplitParts = srcSplit ? srcSplit.querySelectorAll(':scope > .column-part').length : 0;
                } else { draggedFromSplit = false; sourceSplitParts = 0; }
                
                e.dataTransfer.effectAllowed = 'move';
                try { e.dataTransfer.setData('text/plain', ''); } catch (err) {}
            });

            document.addEventListener('dragover', function(e) {
                e.preventDefault();
                if (!draggedElement) return;
                lastDragX = e.clientX;

                if (draggedElement.classList.contains('app-box')) {
                    const container = e.target.closest('.box-container');
                    if (container) {
                        const afterElement = getDragAfterElement(container, e.clientX, e.clientY);
                        container.insertBefore(placeholder, afterElement);
                    }
                } 
                else if (draggedElement.classList.contains('section-group') || draggedElement.classList.contains('column-split-content')) {
                    // This part is for dragging a section from one split part to another.
                    // It should only apply when dragging a section-group.
                    if (draggedFromSplit && draggedElement.classList.contains('section-group')) {
                        let part = e.target.closest('.column-part');
                        if (!part) {
                            const split = e.target.closest('.column-split-content');
                            if (split) {
                                const parts = Array.from(split.querySelectorAll(':scope > .column-part'));
                                let best = null, bestDx = Infinity;
                                parts.forEach(p => { const r = p.getBoundingClientRect(); const cx = r.left + r.width/2; const dx = Math.abs(e.clientX - cx); if (dx < bestDx) { bestDx = dx; best = p; } });
                                part = best;
                            }
                        }
                        if (part) {
                            const afterElement = getDragAfterSection(part, e.clientY);
                            part.insertBefore(placeholder, afterElement);
                            return;
                        }
                    }
                    
                    // This part is for dropping into the main column content area.
                    // It should apply to both section-group and column-split-content.
                    const container = e.target.closest('.column-content');
                    if (container) {
                        const afterElement = getDragAfterBlock(container, e.clientY);
                        container.insertBefore(placeholder, afterElement);
                        // If we are dragging from a split, allow user to choose mode via Alt key
                        if (draggedFromSplit && draggedElement.classList.contains('section-group')) {
                            const full = !!e.altKey; // Alt = insert as full-width (unsplitted)
                            placeholder.setAttribute('data-drop-mode', full ? 'full' : 'split');
                            placeholder.classList.toggle('full-width-mode', full);
                        } else {
                            placeholder.removeAttribute('data-drop-mode');
                            placeholder.classList.remove('full-width-mode');
                        }
                    }
                }
            });

            document.addEventListener('drop', function(e) {
                e.preventDefault();
                if (!placeholder || !placeholder.parentElement) return;
                
                const dropContainer = placeholder.parentElement;
                if (draggedElement && draggedElement.classList && draggedElement.classList.contains('section-group')
                    && draggedFromSplit && dropContainer.classList.contains('column-content')) {
                    // Check placeholder mode: Alt during dragover toggles 'full' mode
                    const mode = placeholder && placeholder.getAttribute('data-drop-mode');
                    if (mode === 'full') {
                        dropContainer.replaceChild(draggedElement, placeholder);
                    } else {
                    // Preserve split: create a new split block here and insert into the nearest part
                    const column = dropContainer.closest('.column');
                    const parts = Math.max(2, parseInt((column && column.getAttribute('data-split-parts')) || (sourceSplitParts || '2'), 10) || 2);
                    const splitContainer = document.createElement('div');
                    splitContainer.className = 'column-split-content';
                    for (let i = 0; i < parts; i++) {
                        const partDiv = document.createElement('div');
                        partDiv.className = 'column-part';
                        splitContainer.appendChild(partDiv);
                    }
                    // Choose part by mouse X relative to container
                    let index = 0;
                    try {
                        const rect = dropContainer.getBoundingClientRect();
                        const relX = Math.max(0, Math.min(rect.width - 1, lastDragX - rect.left));
                        index = Math.min(parts - 1, Math.max(0, Math.floor(relX / (rect.width / parts))));
                    } catch(_) { index = 0; }
                    const targetPart = splitContainer.querySelectorAll(':scope > .column-part')[index];
                    targetPart.appendChild(draggedElement);
                    dropContainer.replaceChild(splitContainer, placeholder);
                    }
                } else if (draggedElement && draggedElement.classList && draggedElement.classList.contains('app-box') && selectedGroup && selectedGroup.length>1) {
                    // Move group (or clone if ctrl during dragstart)
                    const parent = dropContainer;
                    const ref = placeholder;
                    selectedGroup.forEach(el => {
                        let node = el;
                        if (isCloning) { node = el.cloneNode(true); node.classList.remove('selected'); }
                        parent.insertBefore(node, ref);
                    });
                    parent.removeChild(ref);
                } else {
                    dropContainer.replaceChild(draggedElement, placeholder);
                }
                // Clean any leftover dragging class
                try { draggedElement.classList.remove('dragging'); } catch(_){ }
                try { document.querySelectorAll('.app-box.dragging').forEach(n => n.classList.remove('dragging')); } catch(_){ }
                // Clear selection after move
                if (selectedGroup && selectedGroup.length>1 && !isCloning) clearSelection();

                // placeholders entfernt
            });

            document.addEventListener('dragend', function(e) {
                if(draggedElement) { try { draggedElement.classList.remove('dragging'); } catch(_){ } }
                try { document.querySelectorAll('.app-box.dragging').forEach(n => n.classList.remove('dragging')); } catch(_){ }
                if (placeholder && placeholder.parentElement) {
                    placeholder.remove();
                }
                draggedElement = null;
                placeholder = null;
                isCloning = false;
                selectedGroup = null;
            });
        }

        // Sorgt dafr, dass in jedem Content-Bereich (unsplitted oder .column-part)
        // genau ein "+ New Section"-Button vorhanden ist und am Ende steht.
        function normalizeAddButtons(){ /* Placeholder-Buttons entfernt: no-op */ }
        
        function initializeResize() {
            document.addEventListener('mousedown', e => {
                if (e.target.classList.contains('resize-handle')) {
                    isResizing = true;
                    currentResizeColumn = e.target.parentElement;
                    startX = e.pageX;
                    startWidth = currentResizeColumn.offsetWidth;
                    e.preventDefault();
                }
            });
            document.addEventListener('mousemove', e => {
                if (!isResizing) return;
                const width = startWidth + e.pageX - startX;
                const minW = 150;
                if (width >= minW) currentResizeColumn.style.width = width + 'px';
            });
            document.addEventListener('mouseup', () => { isResizing = false; currentResizeColumn = null; });
        }
        
        function initializeColumnDrag() {
            let draggedColumn = null;
            let cloningColumn = false;
            document.addEventListener('dragstart', e => {
                if (e.target.classList.contains('column-header')) {
                    const original = e.target.parentElement;
                    cloningColumn = !!e.ctrlKey;
                    if (cloningColumn) {
                        const clone = original.cloneNode(true);
                        original.parentNode.insertBefore(clone, original.nextSibling);
                        draggedColumn = clone;
                    } else {
                        draggedColumn = original;
                    }
                    // add visual dragging effect
                    draggedColumn.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                }
            });
            document.addEventListener('dragover', e => {
                if (!draggedColumn) return;
                e.preventDefault();
                const column = e.target.closest('.column');
                if (column && column !== draggedColumn) {
                    const columns = [...document.getElementById('mainContainer').querySelectorAll('.column')];
                    const draggedIndex = columns.indexOf(draggedColumn);
                    const targetIndex = columns.indexOf(column);
                    if (draggedIndex < targetIndex) column.parentNode.insertBefore(draggedColumn, column.nextSibling);
                    else column.parentNode.insertBefore(draggedColumn, column);
                }
            });
            document.addEventListener('dragend', () => {
                if (draggedColumn) draggedColumn.classList.remove('dragging');
                draggedColumn = null;
                cloningColumn = false;
            });
        }
        
        function addNewColumn() {
            const container = document.getElementById('mainContainer');
            const addButton = container.querySelector('.add-column');
            const t = translations[currentLanguage];
            const newColumn = createColumnElement(t.newColumn, columnIdCounter++);
            try { window.columnIdCounter = Math.max(window.columnIdCounter||0, columnIdCounter); } catch(_) {}
            container.insertBefore(newColumn, addButton);
            try {
                const mc = document.getElementById('mainContainer');
                if (mc && mc.classList.contains('canvas-mode')){
                    const mcr = mc.getBoundingClientRect();
                    const cr = newColumn.getBoundingClientRect();
                    const lx = Math.max(0, Math.round(cr.left - mcr.left));
                    const ty = Math.max(0, Math.round(cr.top - mcr.top));
                    newColumn.style.left = lx + 'px';
                    newColumn.style.top  = ty + 'px';
                    newColumn.setAttribute('data-canvas-x', String(lx));
                    newColumn.setAttribute('data-canvas-y', String(ty));
                    try { clampColumnsIntoCanvas(); } catch(_) {}
                    try { updateAllConnectors(); } catch(_) {}
                }
            } catch(_) {}
            requestAnimationFrame(equalizeHeaderHeights);
        }
        
        function deleteColumn(btn) {
            if (confirm(translations[currentLanguage].confirmDeleteColumn)) {
                btn.closest('.column').remove();
            }
        }

        // Insert a new split block at the end of the column
        function addSection(btn) {
  const columnContent = btn.parentElement;
  const t = translations[currentLanguage];
  const newSection = document.createElement("div");
  newSection.className = "section-group";
  newSection.draggable = true;
  newSection.innerHTML = '<div class="section-title">' + t.newSection + '<span class="section-delete" onclick="deleteSection(this)" title="' + t.deleteSectionTooltip + '">x</span><span class="section-menu" onclick="showSectionColorPicker(this)">ð¨</span></div><div class="box-container"></div>';
  columnContent.appendChild(newSection);
  try { const sd = newSection.querySelector(".section-delete"); if (sd) sd.textContent = 'x'; } catch(e) {}
}

function insertSplitBlock(btn) {
  try {
    const header = btn.closest(".column-header");
    const column = header.closest(".column");
    const content = column.querySelector(".column-content");
    const parts = parseInt(column.getAttribute("data-split-parts") || '2', 10) || 2;
    const splitContainer = document.createElement("div");
    splitContainer.className = "column-split-content";
    for (let i = 0; i < parts; i++) {
      const partDiv = document.createElement("div");
      partDiv.className = "column-part";
      splitContainer.appendChild(partDiv);
    }
    content.appendChild(splitContainer);
  } catch(e) { console.warn(e); }
}

        function deleteSection(deleteBtn) {
            if (confirm(translations[currentLanguage].confirmDeleteSection)) {
                const sectionGroup = deleteBtn.closest('.section-group');
                sectionGroup.remove();
            }
        }

        function deleteBox(btn) { btn.parentElement.remove(); }
        
        function toggleBoxWidth(btn) {
            const box = btn.parentElement;
            box.classList.toggle('full-width');
            box.classList.toggle('half-width');
        }
        
        function showAddBoxModal() {
            const modal = document.getElementById('addBoxModal');
            modal.classList.add('show');
            const input = document.getElementById('boxName');
            if (input) {
                input.value = '';
                // place caret to start and focus for immediate typing
                input.focus();
                input.select();
                // Pressing Enter triggers Add
                input.onkeydown = function(e){ if(e.key === 'Enter'){ e.preventDefault(); addBoxNew(); } };
            }
            // Reset image options each time the modal opens
            try {
                const t = translations[currentLanguage];
                const chk = document.getElementById('boxIsImage');
                const textOpts = document.getElementById('textOptions');
                const linesLabel = document.getElementById('boxLinesLabel');
                const linesSel = document.getElementById('boxLines');
                const imgOpts = document.getElementById('imageOptions');
                const fileInput = document.getElementById('boxImageFile');
                const dz = document.getElementById('imageDropzone');
                const prev = document.getElementById('imagePreview');
                if (chk) chk.checked = false;
                if (textOpts) textOpts.style.display = 'flex';
                if (linesLabel) linesLabel.style.display = 'block';
                if (linesSel) linesSel.style.display = 'block';
                if (imgOpts) imgOpts.style.display = 'none';
                if (fileInput) fileInput.value = '';
                if (prev) { prev.innerHTML = ''; prev.style.display = 'none'; }
                if (dz) { dz.classList.remove('dragover'); dz.textContent = t.imageSelectOrDrop || dz.textContent; }
                pendingImageDataUrl = null;
            } catch (e) {}

            // Initialize text color from selected category; Manage Categories is master
            try {
                const typeSel = document.getElementById('boxType');
                const tci = document.getElementById('boxTextColor');
                window.__boxTextColorDirty = false;
                const setFromCategory = () => {
                    if (!tci || !typeSel) return;
                    const cat = categories[typeSel.value];
                    if (!window.__boxTextColorDirty && cat){
                        const def = cat.textColor || (isLightColor(cat.color1) ? '#1a1a1a' : '#ffffff');
                        tci.value = def;
                    }
                };
                setFromCategory();
                if (tci) tci.addEventListener('input', () => { window.__boxTextColorDirty = true; });
                if (typeSel) typeSel.addEventListener('change', setFromCategory);
            } catch(_) {}
        }
        
        function closeModal(modalId) { document.getElementById(modalId).classList.remove('show'); }

        function showHelpModal(){
            const m = document.getElementById('helpModal');
            if(!m) return;
            m.classList.add('show');
            const de = m.querySelector('.help-de');
            const en = m.querySelector('.help-en');
            if(de && en){
                if(currentLanguage === 'de'){ de.style.display='block'; en.style.display='none'; }
                else { de.style.display='none'; en.style.display='block'; }
            }
        }
        
        // New: adds either a text-box or image-box based on modal state
        function addBoxNew() {
            const t = translations[currentLanguage];
            const isImage = !!document.getElementById('boxIsImage')?.checked;
            const name = document.getElementById('boxName').value;
            const type = document.getElementById('boxType').value;
            const width = document.getElementById('boxWidth').value;
            const lines = parseInt(document.getElementById('boxLines').value, 10) || 1;
            const textColorEl = document.getElementById('boxTextColor');
            const textColor = textColorEl ? textColorEl.value : '#000000';

            const newBox = document.createElement('div');
            newBox.draggable = true;

            if (isImage) {
                if (!pendingImageDataUrl) { alert(t.alertChooseImage); return; }
                newBox.className = `app-box image-box ${width}`;
                newBox.innerHTML = `<img src="${pendingImageDataUrl}" alt="image" />` +
                    `<button class="delete-btn" onclick="deleteBox(this)">ï¿½</button>` +
                    `<button class="resize-btn" onclick="toggleBoxWidth(this)">\u001d</button>`;
                pendingImageDataUrl = null;
            } else {
                newBox.className = `app-box ${type} ${width}`;
                newBox.innerHTML = `${name}<button class="delete-btn" onclick="deleteBox(this)">ï¿½</button><button class="resize-btn" onclick="toggleBoxWidth(this)">\u001d</button>`;
                newBox.dataset.lines = String(lines);
                newBox.setAttribute('data-base-lines', String(lines));
                newBox.setAttribute('data-dynamic','0');
                const minHeight = (lines * 30);
                newBox.style.minHeight = `${minHeight}px`;
                // Only apply inline color if user changed it in Add Box dialog
                if (window.__boxTextColorDirty) newBox.style.color = textColor;
            }

            const target = getTargetBoxContainer();
            if (target) target.appendChild(newBox);
            try { applyBoxLayout(newBox); } catch(_){}
            closeModal('addBoxModal');
            window.__boxTextColorDirty = false;
        }

        function addBox() {
            const name = document.getElementById('boxName').value;
            const type = document.getElementById('boxType').value;
            const width = document.getElementById('boxWidth').value;
            const lines = parseInt(document.getElementById('boxLines').value, 10) || 1;
            const textColor = document.getElementById('boxTextColor').value;

            const newBox = document.createElement('div');
            newBox.className = `app-box ${type} ${width}`;
            newBox.draggable = true;
            newBox.innerHTML = `${name}<button class="delete-btn" onclick="deleteBox(this)">Ã</button><button class="resize-btn" onclick="toggleBoxWidth(this)">â</button>`;
            newBox.dataset.lines = String(lines);
            newBox.setAttribute('data-base-lines', String(lines));
            newBox.setAttribute('data-dynamic','0');
            
            const minHeight = (lines * 30);
            newBox.style.minHeight = `${minHeight}px`;

            // ALT: if (textColor !== '#000000') newBox.style.color = textColor;
            // NEU: Die Farbe wird jetzt immer direkt zugewiesen, auch wenn es schwarz ist.
            newBox.style.color = textColor;
        
            try { const db = newBox.querySelector('.delete-btn'); if (db) db.textContent = 'x'; } catch(e) {}
            const target2 = getTargetBoxContainer();
            if (target2) target2.appendChild(newBox);
            closeModal('addBoxModal');
        }       
        
        function resetLayout() {
            if (confirm(translations[currentLanguage].confirmResetLayout)) location.reload();
        }
        
        function clearAll() {
            if (confirm(translations[currentLanguage].confirmClearAll)) {
                document.getElementById('mainContainer').innerHTML = '<div class="add-column" onclick="addNewColumn()"><span>+</span></div>';
            }
        }
        
        document.addEventListener('click', e => {
            if (e.target.classList.contains('section-title') && !e.target.closest('.section-menu, .section-delete')) {
                const title = e.target;
                const menuHTML = title.querySelector('.section-menu')?.outerHTML || '';
                const deleteHTML = title.querySelector('.section-delete')?.outerHTML || '';
                const currentText = title.textContent.replace('â', '').replace('Ã', '').trim();
                
                title.innerHTML = `<input type="text" value="${currentText}" onblur="updateSectionTitle(this)" onkeypress="if(event.key==='Enter') this.blur()">`;
                title.querySelector('input').focus();
                title.setAttribute('data-menu', deleteHTML + menuHTML);
            }
        });
        
        function updateSectionTitle(input) {
            const newTitle = input.value || translations[currentLanguage].newSection;
            const title = input.parentElement;
            const menuHTML = title.getAttribute('data-menu') || '';
            title.innerHTML = newTitle + ' ' + menuHTML;
            title.removeAttribute('data-menu');
            // Safety: ensure the section color menu exists after rename
            try {
                if (!title.querySelector('.section-menu')) {
                    const btn = document.createElement('span');
                    btn.className = 'section-menu';
                    btn.setAttribute('title', 'Farbe Ã¤ndern');
                    btn.textContent = 'ð¨';
                    btn.setAttribute('onclick', 'showSectionColorPicker(this)');
                    title.appendChild(btn);
                }
                // Ensure pipette icon exists after rename
                if (!title.querySelector('.section-pipette')) {
                    if (typeof addSectionPipette === 'function') {
                        addSectionPipette(title);
                    } else {
                        const pip = document.createElement('span');
                        pip.className = 'section-pipette pipette-btn';
                        pip.setAttribute('title', 'Farbe mit Pipette wÃ¤hlen');
                        pip.textContent = 'ð§ª';
                        pip.setAttribute('draggable','false');
                        ['pointerdown','mousedown','dragstart'].forEach(evt => pip.addEventListener(evt, ev => { ev.stopPropagation(); ev.preventDefault(); }, true));
                        // Click delegated globally, so no inline handler nÃ¶tig
                        title.appendChild(pip);
                    }
                }
            } catch(_) {}
        }
        
        document.addEventListener('dblclick', e => {
            if (e.target.classList.contains('column-header')) {
                const header = e.target;
                const currentText = header.childNodes[0].textContent.trim();
                const buttonsHTML = Array.from(header.querySelectorAll('.header-btn')).map(btn => btn.outerHTML).join('');
                header.innerHTML = `<input type="text" value="${currentText}" onblur="updateColumnTitle(this)" onkeypress="if(event.key==='Enter') this.blur()"> ${buttonsHTML}`;
                header.querySelector('input').focus();
            }
        });
        
        function updateColumnTitle(input) {
            const newTitle = input.value || translations[currentLanguage].newColumn;
            const header = input.parentElement;
            const buttonsHTML = Array.from(header.querySelectorAll('.header-btn')).map(btn => btn.outerHTML).join('');
            header.innerHTML = newTitle + ' ' + buttonsHTML;
            // If buttons were missing, recreate color button so picker stays available
            try {
                if (!header.querySelector('.color-column-btn')) {
                    var btn = document.createElement('span');
                    btn.className = 'header-btn color-column-btn';
                    btn.title = 'Header-Farbe Ã¤ndern';
                    btn.setAttribute('draggable','false');
                    btn.textContent = 'ðï¸';
                    btn.setAttribute('onclick', "showColumnColorPicker(this)");
                    header.appendChild(btn);
                }
            } catch(_) {}
            requestAnimationFrame(equalizeHeaderHeights);
        }

        // Capture-phase handler to sanitize section title editing and avoid stray 'x' character
        document.addEventListener('click', function(e){
            if (e.target.classList && e.target.classList.contains('section-title') && !e.target.closest('.section-menu, .section-delete')) {
                const title = e.target;
                const menuHTML = title.querySelector('.section-menu')?.outerHTML || '';
                const deleteHTML = title.querySelector('.section-delete')?.outerHTML || '';
                const textNode = (title.childNodes && title.childNodes[0] && title.childNodes[0].nodeType === 3) ? title.childNodes[0] : null;
                const currentText = textNode ? textNode.textContent.trim() : title.textContent.replace(/[xÃâ?ð¨]/g, '').trim();
                title.classList.add('editing');
                title.innerHTML = `<input type="text" value="${currentText}" onblur="updateSectionTitle(this)" onkeypress="if(event.key==='Enter') this.blur()">`;
                title.setAttribute('data-menu', deleteHTML + menuHTML);
                const inp = title.querySelector('input'); if (inp) { try { inp.focus(); inp.select && inp.select(); } catch(_){} }
                // Prevent the original bubble listener from re-running with unsanitized text
                e.stopImmediatePropagation();
                e.stopPropagation();
            }
        }, true);

        // Ensure editing class is removed after blur/update, regardless of original implementation
        (function(){
            try {
                var __orig = window.updateSectionTitle || updateSectionTitle;
                window.updateSectionTitle = function(input){
                    try { __orig(input); } catch(_) { try { updateSectionTitle(input); } catch(__){} }
                    try { var t = input && input.parentElement; if (t) t.classList.remove('editing'); } catch(__){}
                };
            } catch(__) {}
        })();

        document.addEventListener('contextmenu', e => {
            if (e.target.classList.contains('app-box')) {
                e.preventDefault();
                const box = e.target;
                const types = Object.keys(categories);
                const currentType = types.find(t => box.classList.contains(t));
                const currentIndex = types.indexOf(currentType);
                const nextIndex = (currentIndex + 1) % types.length;
                
                if (currentType) box.classList.remove(currentType);
                box.classList.add(types[nextIndex]);
            }
        });

        // Right-click cycles forward; Alt+Left-Click cycles backward (safe: no conflict with rename)
        (function(){
            const basePalette = ['#FFFFFF', '#000000', '#8B4513','#A0522D','#CD853F','#D2691E','#FF9800','#FFC107','#FF5722','#2196F3','#1E88E5','#64B5F6','#00BCD4','#009688','#4CAF50','#8BC34A','#9C27B0','#AB47BC','#E91E63','#F44336','#607D8B','#455A64','#333333','#666666','#999999','#CCCCCC'];
            function norm(c){ return (c||'').toLowerCase(); }
            function toHex(rgb){
                try{
                    if (!rgb) return '';
                    if (rgb.startsWith('#')) return rgb;
                    const m = rgb.match(/rgba?\((\d+)\s*,\s*(\d+)\s*,\s*(\d+)/i);
                    if (!m) return '';
                    const r = (parseInt(m[1])|0).toString(16).padStart(2,'0');
                    const g = (parseInt(m[2])|0).toString(16).padStart(2,'0');
                    const b = (parseInt(m[3])|0).toString(16).padStart(2,'0');
                    return ('#'+r+g+b).toLowerCase();
                }catch(_){ return ''; }
            }
            function cycleHeaderTextColor(el, reverse){
                if (!el) return;
                const cs = window.getComputedStyle(el);
                const current = toHex(cs.color) || '#ffffff';
                // create deduped palette starting with white, black, then others
                const seen = new Set();
                const palette = [];
                basePalette.forEach(c=>{ const k=norm(c); if(!seen.has(k)){ seen.add(k); palette.push(k); } });
                let idx = palette.indexOf(norm(current));
                if (reverse) {
                    idx = (idx < 0) ? 0 : (idx - 1 + palette.length) % palette.length;
                } else {
                    idx = (idx < 0) ? 0 : (idx + 1) % palette.length;
                }
                const next = palette[idx];
                el.style.color = next;
                // keep inline inputs (during rename) in sync
                const inp = el.querySelector('input'); if (inp) inp.style.color = next;
            }
            document.addEventListener('contextmenu', function(e){
                const isBtn = (sel, n)=> n && n.closest && n.closest(sel);
                // Section title
                const st = e.target && e.target.closest && e.target.closest('.section-title');
                if (st && !isBtn('.section-menu, .section-delete', e.target)){
                    e.preventDefault(); e.stopPropagation();
                    cycleHeaderTextColor(st, false);
                    return;
                }
                // Column header
                const ch = e.target && e.target.closest && e.target.closest('.column-header');
                if (ch && !isBtn('.header-btn, .split-counter', e.target)){
                    e.preventDefault(); e.stopPropagation();
                    cycleHeaderTextColor(ch, false);
                    return;
                }
            }, true);

            // Alt+Left-Click cycles backward to avoid breaking existing left-click behaviors
            document.addEventListener('click', function(e){
                if (!e.altKey) return;
                const isBtn = (sel, n)=> n && n.closest && n.closest(sel);
                const st = e.target && e.target.closest && e.target.closest('.section-title');
                if (st && !isBtn('.section-menu, .section-delete', e.target)){
                    e.preventDefault(); e.stopPropagation();
                    cycleHeaderTextColor(st, true);
                    return;
                }
                const ch = e.target && e.target.closest && e.target.closest('.column-header');
                if (ch && !isBtn('.header-btn, .split-counter', e.target)){
                    e.preventDefault(); e.stopPropagation();
                    cycleHeaderTextColor(ch, true);
                    return;
                }
            }, true);
        })();

        function showSectionColorPicker(menuBtn) {
            document.querySelectorAll('.section-color-picker').forEach(picker => picker.remove());
            const sectionTitle = menuBtn.closest('.section-title');
            const picker = document.createElement('div');
            picker.className = 'section-color-picker show';
            // Build palette identical to column header: swatch-only grid (no labels)
            const extraColors = ['#8B4513','#A0522D','#CD853F','#D2691E','#FF9800','#FFC107','#FF5722','#2196F3','#1E88E5','#64B5F6','#00BCD4','#009688','#4CAF50','#8BC34A','#9C27B0','#AB47BC','#E91E63','#F44336','#607D8B','#455A64','#000000','#333333','#666666','#999999','#CCCCCC','#FFFFFF'];
            const base = (Array.isArray(sectionColorPalette)? sectionColorPalette: []).map(c => (typeof c === 'string' ? c : c.color));
            const merged = [];
            const seen = new Set();
            base.concat(extraColors).forEach(c=>{ if(!seen.has(c)){ seen.add(c); merged.push(c);} });
            picker.innerHTML = merged.map(c => `<div class="swatch" data-c="${c}" style="background:${c}" title="${c}"></div>`).join('');
            
            sectionTitle.appendChild(picker);

            // After render, prevent off-screen clipping (left/right)
            requestAnimationFrame(() => {
                try {
                    const rect = picker.getBoundingClientRect();
                    const vw = window.innerWidth || document.documentElement.clientWidth;
                    if (rect.left < 0) { picker.style.left = '0'; picker.style.right = 'auto'; }
                    else if (rect.right > vw) { picker.style.right = '0'; picker.style.left = 'auto'; }
                    // If picker goes below viewport, try to open upwards
                    const vh = window.innerHeight || document.documentElement.clientHeight;
                    if (rect.bottom > vh && rect.height < vh) {
                        picker.style.top = 'auto';
                        picker.style.bottom = '25px';
                    }
                } catch(e) {}
            });

            // Event handling like column picker
            ['mousedown','pointerdown','click'].forEach(evt => picker.addEventListener(evt, e => e.stopPropagation(), true));
            picker.addEventListener('click', e => {
                const sw = e.target.closest && e.target.closest('.swatch');
                if (sw) { applySectionColor(sectionTitle, sw.getAttribute('data-c')); picker.remove(); }
            }, true);
            function onDoc(ev){ if(!picker.contains(ev.target) && ev.target!==menuBtn){ picker.remove(); document.removeEventListener('mousedown', onDoc, true);} }
            setTimeout(()=> document.addEventListener('mousedown', onDoc, true), 0);
        }

        function applySectionColor(sectionTitle, color){
            sectionTitle.style.background = color;
            sectionTitle.setAttribute('data-color', color);
        }
        
        function changeSectionColor(color, optionElement) {
            const sectionTitle = optionElement.closest('.section-title');
            sectionTitle.style.background = color;
            sectionTitle.setAttribute('data-color', color);
            optionElement.closest('.section-color-picker').remove();
        }

        // === COLUMN VISIBILITY MENU ===
        function showColumnVisibilityMenu(e, sectionGroup) {
            // Remove any existing menu
            document.querySelectorAll('.column-visibility-menu').forEach(m => m.remove());

            const column = sectionGroup.closest('.column');
            if (!column) return;

            const hideColumnHeader = column.getAttribute('data-hide-column-header') === 'true';
            const hideSectionHeaders = column.getAttribute('data-hide-section-headers') === 'true';

            const menu = document.createElement('div');
            menu.className = 'column-visibility-menu show';
            menu.style.left = e.clientX + 'px';
            menu.style.top = e.clientY + 'px';

            menu.innerHTML = `
                <div class="column-visibility-menu-item" data-action="toggle-column-header">
                    <span class="checkbox ${!hideColumnHeader ? 'checked' : ''}">${!hideColumnHeader ? 'â' : ''}</span>
                    <span>Spalten-Header anzeigen</span>
                </div>
                <div class="column-visibility-menu-item" data-action="toggle-section-headers">
                    <span class="checkbox ${!hideSectionHeaders ? 'checked' : ''}">${!hideSectionHeaders ? 'â' : ''}</span>
                    <span>Section-Header anzeigen</span>
                </div>
            `;

            document.body.appendChild(menu);

            // Prevent menu from going off-screen
            requestAnimationFrame(() => {
                const rect = menu.getBoundingClientRect();
                const vw = window.innerWidth || document.documentElement.clientWidth;
                const vh = window.innerHeight || document.documentElement.clientHeight;

                if (rect.right > vw) {
                    menu.style.left = (vw - rect.width - 10) + 'px';
                }
                if (rect.bottom > vh) {
                    menu.style.top = (vh - rect.height - 10) + 'px';
                }
            });

            // Event handlers
            menu.addEventListener('click', (ev) => {
                const item = ev.target.closest('.column-visibility-menu-item');
                if (!item) return;

                const action = item.getAttribute('data-action');
                if (action === 'toggle-column-header') {
                    toggleColumnHeaderVisibility(column);
                } else if (action === 'toggle-section-headers') {
                    toggleSectionHeadersVisibility(column);
                }

                // Recreate menu to update checkboxes
                menu.remove();
                showColumnVisibilityMenu(e, sectionGroup);
            });

            // Close menu when clicking outside
            function onDocClick(ev) {
                if (!menu.contains(ev.target)) {
                    menu.remove();
                    document.removeEventListener('mousedown', onDocClick, true);
                }
            }
            setTimeout(() => document.addEventListener('mousedown', onDocClick, true), 0);
        }

        function toggleColumnHeaderVisibility(column) {
            const current = column.getAttribute('data-hide-column-header') === 'true';
            if (current) {
                column.removeAttribute('data-hide-column-header');
            } else {
                column.setAttribute('data-hide-column-header', 'true');
            }
            try { if (typeof updateAllConnectors === 'function') updateAllConnectors(); } catch(_) {}
        }

        function toggleSectionHeadersVisibility(column) {
            const current = column.getAttribute('data-hide-section-headers') === 'true';
            if (current) {
                column.removeAttribute('data-hide-section-headers');
            } else {
                column.setAttribute('data-hide-section-headers', 'true');
            }
        }

        // Context menu handler for section-groups
        document.addEventListener('contextmenu', function(e) {
            // Check if we're on a section-group but not on specific child elements
            const sectionGroup = e.target.closest('.section-group');
            if (!sectionGroup) return;

            // Ignore if clicking on section-title, app-box, or their buttons
            if (e.target.closest('.section-title')) return;
            if (e.target.closest('.app-box')) return;

            // Only trigger if clicking on section-group background or box-container
            const isBoxContainer = e.target.classList.contains('box-container');
            const isSectionGroup = e.target.classList.contains('section-group');

            if (isBoxContainer || isSectionGroup) {
                e.preventDefault();
                e.stopPropagation();
                showColumnVisibilityMenu(e, sectionGroup);
            }
        }, true);

        // === TEMPLATE MANAGEMENT FUNCTIONS ===
        // Track the currently loaded template name for sane save behavior
        window.currentTemplateName = window.currentTemplateName || '';

        function deepClone(obj){ try { return JSON.parse(JSON.stringify(obj)); } catch(_) { return obj; } }
        // Remove heavy image data for localStorage (keeps structure so it still loads)
        function stripImagesForStorage(layout){
            const clone = deepClone(layout);
            try {
                (clone.columns||[]).forEach(col => {
                    const areas = col.contentAreas || [];
                    areas.forEach(area => {
                        const sectLists = [];
                        if (Array.isArray(area.sections)) sectLists.push(area.sections);
                        if (Array.isArray(area.splitParts)) area.splitParts.forEach(p=> sectLists.push(p.sections||[]));
                        sectLists.forEach(list => (list||[]).forEach(sec => {
                            (sec.boxes||[]).forEach(box => { if (box && box.isImage) { box.imageSrc = ''; } });
                        }));
                    });
                });
            } catch(_){}
            return clone;
        }
        function saveTemplate() {
            const t = translations[currentLanguage];
            const templates = getStoredTemplates();
            // Prefer the current loaded name when present
            const suggested = window.currentTemplateName && typeof window.currentTemplateName === 'string'
                ? window.currentTemplateName
                : `${t.defaultTemplateName} ${new Date().toLocaleDateString()}`;

            let name = prompt(t.promptTemplateName, suggested);
            if (!name) return;

            // Helper to find a free name with (n) suffix
            function nextName(base) {
                let i = 1; let candidate = base;
                while (templates[candidate]) { i++; candidate = `${base} (${i})`; }
                return candidate;
            }

            if (templates[name]) {
                // Ask before overwriting; if declined, pick next available sequential name
                const overwrite = confirm(t.confirmOverwriteTemplate ? t.confirmOverwriteTemplate.replace('{name}', name) : `Template "${name}" Ã¼berschreiben?`);
                if (!overwrite) name = nextName(name);
            }

            const templateData = { name, date: new Date().toISOString(), categories, layout: extractLayoutData(), fontSettings: (function(fs){ try { return JSON.parse(JSON.stringify(fs)); } catch(_) { return fs||null; } })(window.fontSettings), canvas: (function(){ try{ var mc=document.getElementById('mainContainer'); var enabled = mc && mc.classList.contains('canvas-mode'); if(!enabled) return {enabled:false}; var w=parseInt(mc.style.width)||1920, h=parseInt(mc.style.height)||1080; var cons = (typeof window.__getCanvasConnectors==='function') ? window.__getCanvasConnectors() : []; return {enabled:true, width:w, height:h, connectors: cons}; }catch(_){ return {enabled:false}; } })() };
            templates[name] = templateData;
            // localStorage write guarded; full template always downloaded below
            try { localStorage.setItem('architectureTemplates', JSON.stringify(templates)); } catch(_) {}
            window.currentTemplateName = name; // remember last saved name

            downloadTemplateAsFile(templateData);
            alert(t.alertTemplateSaved.replace('{name}', name));
            updateTemplateList();
        }
        
        function getStoredTemplates() { return JSON.parse(localStorage.getItem('architectureTemplates') || '{}'); }
        
// Extract current layout data
        function extractLayoutData() {
            const columns = [];
            document.querySelectorAll('.column').forEach(column => {
                const columnData = {
                    id: column.getAttribute('data-column-id'),
                    title: column.querySelector('.column-header').childNodes[0].textContent.trim(),
                    width: column.offsetWidth + 'px',
                    headerColor: (function(){
                        try{
                            var h = column.querySelector('.column-header');
                            return h.getAttribute('data-header-color') || column.style.borderColor || '';
                        }catch(_){ return ''; }
                    })(),
                    splitState: column.getAttribute('data-split-state') || 'normal',
                    splitParts: parseInt(column.getAttribute('data-split-parts') || (function(ss){ if(ss==='split-2') return 2; if(ss==='split-3') return 3; return 1; })(column.getAttribute('data-split-state')||'normal'), 10),
                    hideColumnHeader: column.getAttribute('data-hide-column-header') === 'true',
                    hideSectionHeaders: column.getAttribute('data-hide-section-headers') === 'true',
                    contentAreas: []
                };
                // Save canvas positions when in canvas mode
                try{
                    var mc=document.getElementById('mainContainer');
                    if (mc && mc.classList.contains('canvas-mode')){
                        var lx = parseInt(column.style.left)||0; var ty = parseInt(column.style.top)||0;
                        columnData.canvasX = lx; columnData.canvasY = ty;
                    }
                }catch(_){ }
                
                const contentWrapper = column.querySelector('.column-content');

                function serializeSectionNodes(nodes) {
                    const areaData = { sections: [] };
                    nodes.forEach(section => {
                        const sectionTitle = section.querySelector('.section-title');
                        const sectionData = {
                            title: sectionTitle.childNodes[0].textContent.trim(),
                            color: sectionTitle.getAttribute('data-color') || '#8B4513',
                                boxes: Array.from(section.querySelectorAll('.app-box')).map(box => {
                                    const isImage = box.classList.contains('image-box');
                                    const isLine = box.classList.contains('line-box');
                                    if (isImage) {
                                        const img = box.querySelector('img');
                                        return {
                                            isImage: true,
                                            imageSrc: img ? img.getAttribute('src') : '',
                                            width: ['full-width', 'half-width'].find(cls => box.classList.contains(cls)) || 'full-width'
                                        };
                                    } else if (isLine) {
                                        const cls = Array.from(box.classList).find(c => c.startsWith('line-')) || 'line-solid-1';
                                        return {
                                            isLine: true,
                                            lineClass: cls,
                                            width: ['full-width', 'half-width'].find(cls => box.classList.contains(cls)) || 'full-width'
                                        };
                                    } else {
                                            return {
                                                isImage: false,
                                                // extract only direct text nodes, ignore button labels
                                                text: (function(b){ var s=''; b.childNodes.forEach(function(n){ if(n.nodeType===3) s+=n.nodeValue; }); return s.trim(); })(box),
                                                type: Object.keys(categories).find(type => box.classList.contains(type)) || 'saas',
                                                width: ['full-width', 'half-width'].find(cls => box.classList.contains(cls)) || 'full-width',
                                                baseLines: (box.getAttribute('data-base-lines') || box.getAttribute('data-lines') || box.dataset.lines || '1'),
                                                dynamic: ((box.getAttribute('data-dynamic') || '0') === '1'),
                                            textColor: box.style.color || '',
                                            textAlign: box.style.textAlign || '',
                                            justify: box.style.justifyContent || '',
                                            resized: (box.dataset && box.dataset.resized === '1'),
                                            heightPx: (function(){
                                                try {
                                                    var h = box.getBoundingClientRect().height;
                                                    var lh = 30; // ROW_HEIGHT baseline
                                                    var lines = Math.max(1, Math.round(h / lh));
                                                    return lines * lh; // normalize to exact multiples to avoid growth on reload
                                                } catch(_){ return null; }
                                            })()
                                            };
                                    }
                                })
                        };
                        areaData.sections.push(sectionData);
                    });
                    return areaData;
                }

                // New flexible serialization: walk children, supporting multiple split blocks
                if (contentWrapper) {
                    let buffer = [];
                    const flush = () => { if (buffer.length) { columnData.contentAreas.push(serializeSectionNodes(buffer)); buffer = []; } };
                    Array.from(contentWrapper.children).forEach(ch => {
                        if (ch.classList && ch.classList.contains('section-group')) {
                            buffer.push(ch);
                        } else if (ch.classList && ch.classList.contains('column-split-content')) {
                            flush();
                            const parts = [];
                            ch.querySelectorAll(':scope > .column-part').forEach(part => {
                                const sections = Array.from(part.querySelectorAll(':scope > .section-group'));
                                parts.push(serializeSectionNodes(sections));
                            });
                            columnData.contentAreas.push({ splitParts: parts });
                        }
                    });
                    flush();
                }
                columns.push(columnData);
            });
            return { columns };
        } 
        
        function downloadTemplateAsFile(templateData) {
            const blob = new Blob([JSON.stringify(templateData, null, 2)], { type: 'application/json' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `${templateData.name.replace(/[^a-z0-9]/gi, '_')}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }
        
        function showLoadTemplateModal() {
            document.getElementById('loadTemplateModal').classList.add('show');
            updateTemplateList();
        }

        // Built-in templates
        const builtinTemplates = {
            organigram: {
                name: 'Organigramm',
                categories: {
                    mgmt: { name:'Management', color1:'#8B4513', color2:'#8B4513' },
                    eng:  { name:'Engineering', color1:'#667eea', color2:'#764ba2' },
                    sales:{ name:'Sales', color1:'#84fab0', color2:'#8fd3f4' },
                    ops:  { name:'Operations', color1:'#f093fb', color2:'#f5576c' },
                    hr:   { name:'HR', color1:'#f6d365', color2:'#fda085' }
                },
                layout: {
                    columns: [
                        { id: '1', title:'Organisation', width:'400px', splitState:'normal', splitParts:1, contentAreas:[
                            { sections:[ { title:'CEO', color:'#8B4513', boxes:[{ isImage:false, text:'Max Mustermann', type:'mgmt', width:'full-width', lines:'1'}] } ] },
                            { splitParts:[
                                { sections:[ { title:'Engineering', color:'#667eea', boxes:[{ isImage:false, text:'Team A', type:'eng', width:'full-width', lines:'1'},{ isImage:false, text:'Team B', type:'eng', width:'full-width', lines:'1'}] } ] },
                                { sections:[ { title:'Sales', color:'#84fab0', boxes:[{ isImage:false, text:'DACH', type:'sales', width:'full-width', lines:'1'},{ isImage:false, text:'EMEA', type:'sales', width:'full-width', lines:'1'}] } ] },
                                { sections:[ { title:'Operations', color:'#f093fb', boxes:[{ isImage:false, text:'IT Ops', type:'ops', width:'full-width', lines:'1'},{ isImage:false, text:'Finance Ops', type:'ops', width:'full-width', lines:'1'}] } ] }
                            ]},
                            { sections:[ { title:'HR', color:'#f6d365', boxes:[{ isImage:false, text:'Recruiting', type:'hr', width:'half-width', lines:'1'},{ isImage:false, text:'People & Culture', type:'hr', width:'half-width', lines:'1'}] } ] }
                        ]}
                    ]
                }
            },
            office: {
                name: 'Office Map',
                categories: {
                    space:{ name:'Space', color1:'#E0E0E0', color2:'#E0E0E0' },
                    room: { name:'Room',  color1:'#B0BEC5', color2:'#B0BEC5' },
                    desk: { name:'Desk',  color1:'#90CAF9', color2:'#90CAF9' }
                },
                layout: {
                    columns: [
                        { id:'1', title:'Etage 3', splitState:'normal', splitParts:1, contentAreas:[
                            { splitParts:[
                                { sections:[ { title:'Open Space', color:'#E0E0E0', boxes:[{ isImage:false, text:'Desk 1', type:'desk', width:'half-width', lines:'1'},{ isImage:false, text:'Desk 2', type:'desk', width:'half-width', lines:'1'},{ isImage:false, text:'Desk 3', type:'desk', width:'half-width', lines:'1'},{ isImage:false, text:'Desk 4', type:'desk', width:'half-width', lines:'1'}] } ] },
                                { sections:[ { title:'Meeting', color:'#B0BEC5', boxes:[{ isImage:false, text:'Room A', type:'room', width:'full-width', lines:'1'}] } ] }
                            ]},
                            { splitParts:[
                                { sections:[ { title:'Open Space', color:'#E0E0E0', boxes:[{ isImage:false, text:'Desk 5', type:'desk', width:'half-width', lines:'1'},{ isImage:false, text:'Desk 6', type:'desk', width:'half-width', lines:'1'}] } ] },
                                { sections:[ { title:'KÃ¼che', color:'#B0BEC5', boxes:[{ isImage:false, text:'Coffee', type:'room', width:'full-width', lines:'1'}] } ] }
                            ]}
                        ]}
                    ]
                }
            },
            kanban: {
                name: 'Kanban',
                categories: {
                    todo: { name:'To Do', color1:'#FFAB91', color2:'#FFAB91' },
                    doing:{ name:'Doing', color1:'#FFD54F', color2:'#FFD54F' },
                    done: { name:'Done',  color1:'#A5D6A7', color2:'#A5D6A7' }
                },
                layout: {
                    columns: [
                        { id:'1', title:'To Do', splitState:'normal', splitParts:1, contentAreas:[ { sections:[ { title:'Backlog', color:'#FFAB91', boxes:[{ isImage:false, text:'Task 1', type:'todo', width:'full-width', lines:'1'},{ isImage:false, text:'Task 2', type:'todo', width:'full-width', lines:'1'}] } ] } ] },
                        { id:'2', title:'Doing', splitState:'normal', splitParts:1, contentAreas:[ { sections:[ { title:'In Arbeit', color:'#FFD54F', boxes:[{ isImage:false, text:'Implement Feature', type:'doing', width:'full-width', lines:'1'}] } ] } ] },
                        { id:'3', title:'Done',  splitState:'normal', splitParts:1, contentAreas:[ { sections:[ { title:'Abgeschlossen', color:'#A5D6A7', boxes:[{ isImage:false, text:'Review OK', type:'done', width:'full-width', lines:'1'}] } ] } ] }
                    ]
                }
            }
        };

        function loadBuiltinTemplate(key){
            const tpl = builtinTemplates[key]; if(!tpl) return;
            categories = tpl.categories || categories;
            updateCategoryStyles(); updateCategoryDropdown(); updateLegend();
            applyLayoutData(tpl.layout);
            applyBoxLayoutAll(document);
            window.currentTemplateName = tpl.name || key;
            closeModal('loadTemplateModal');
        }
        
        function updateTemplateList() {
            const list = document.getElementById('templateList');
            const templates = getStoredTemplates();
            const t = translations[currentLanguage];
            list.innerHTML = '';
            
            if (Object.keys(templates).length === 0) {
                list.innerHTML = `<div style="text-align: center; color: #666; padding: 20px;">${t.noSavedTemplates}</div>`;
                return;
            }
            
            for (const [name, template] of Object.entries(templates)) {
                const item = document.createElement('div');
                item.className = 'template-item';
                item.innerHTML = `
                    <div class="template-info" onclick="loadTemplate('${name}')">
                        <div class="template-name">${template.name}</div>
                        <div class="template-date">${new Date(template.date).toLocaleString()}</div>
                    </div>
                    <div class="template-actions">
                        <button class="btn btn-primary small-btn" onclick="loadTemplate('${name}')">${t.loadTemplate.split(' ')[0]}</button>
                        <button class="btn btn-warning small-btn" onclick="downloadStoredTemplate('${name}')">Download</button>
                        <button class="btn btn-danger small-btn" onclick="deleteTemplate('${name}')">${t.delete}</button>
                    </div>`;
                list.appendChild(item);
            }
        }
        
        function loadTemplate(templateName) {
            const t = translations[currentLanguage];
            const templates = getStoredTemplates();
            const template = templates[templateName];
            if (!template) { alert(t.alertTemplateNotFound); return; }
            if (!confirm(t.confirmLoadTemplate.replace('{name}', templateName))) return;
            
            categories = template.categories || categories;
            updateCategoryStyles(); updateCategoryDropdown(); updateLegend();
            // Restore font settings if present
            if (template.fontSettings) { try { window.fontSettings = template.fontSettings; if (typeof applyAllFontStyles==='function') applyAllFontStyles(); } catch(_){} }
            applyLayoutData(template.layout);
            try { if (typeof enforceBoxFlex==='function') enforceBoxFlex(document); if (typeof applyBoxLayoutAll==='function') applyBoxLayoutAll(document); } catch(_){}
            // Restore canvas mode + connectors from root canvas block
            try{
                if (template.canvas && template.canvas.enabled){
                    if (typeof setCanvasSize==='function') setCanvasSize(template.canvas.width||1920, template.canvas.height||1080);
                    var mc=document.getElementById('mainContainer'); if (typeof toggleCanvasMode==='function' && mc && !mc.classList.contains('canvas-mode')) toggleCanvasMode();
                    if (template.canvas.connectors && typeof window.__setCanvasConnectors==='function') { try{ if (typeof ensureConnectorLayer==='function') ensureConnectorLayer(); }catch(_){ } window.__setCanvasConnectors(template.canvas.connectors); }
                }
            }catch(_){ }
            window.currentTemplateName = template.name || templateName;
            
            closeModal('loadTemplateModal');
            // HINWEIS: Die Erfolgsmeldung wurde hier entfernt (auskommentiert).
            // alert(t.alertTemplateLoaded.replace('{name}', templateName)); 
        }
        
// Apply layout data
        function applyLayoutData(layoutData) {
            const container = document.getElementById('mainContainer');
            container.innerHTML = ''; // Leert den Container fÃ¼r das neue Layout
            const t = translations[currentLanguage];

            if (layoutData.columns) {
                layoutData.columns.forEach(columnData => {
                    const column = createColumnElement(columnData.title, columnData.id);
                    // restore header color if present
                    try{
                        if (columnData.headerColor){
                            var headerEl = column.querySelector('.column-header');
                            if (typeof applyHeaderColor==='function') applyHeaderColor(headerEl, columnData.headerColor);
                            else { headerEl.style.background = 'linear-gradient(to bottom,'+columnData.headerColor+','+columnData.headerColor+')'; column.style.borderColor = columnData.headerColor; headerEl.setAttribute('data-header-color', columnData.headerColor); }
                        }
                    }catch(_){ }
                    // carry canvas positions as attributes (applied when enabling canvas later)
                    if (typeof columnData.canvasX !== 'undefined') column.setAttribute('data-canvas-x', String(columnData.canvasX));
                    if (typeof columnData.canvasY !== 'undefined') column.setAttribute('data-canvas-y', String(columnData.canvasY));
                    if(columnData.width) column.style.width = columnData.width;

                    // Restore visibility settings
                    if (columnData.hideColumnHeader) column.setAttribute('data-hide-column-header', 'true');
                    if (columnData.hideSectionHeaders) column.setAttribute('data-hide-section-headers', 'true');

                    const splitState = columnData.splitState || 'normal';
                    column.setAttribute('data-split-state', splitState);
                    const splitParts = parseInt((columnData.splitParts != null ? columnData.splitParts : (splitState==='split-2'?2:(splitState==='split-3'?3:1))), 10);
                    column.setAttribute('data-split-parts', String(splitParts));
                    
                    const contentWrapper = column.querySelector('.column-content');
                    contentWrapper.innerHTML = ''; // Leert den Standard-Inhalt, der von createColumnElement kommt

                    // Flexible builder: if contentAreas contains splitParts, render sequential blocks
                    const __areas = Array.isArray(columnData.contentAreas) ? columnData.contentAreas : [];
                    const __hasFlexible = __areas.some(a => a && Array.isArray(a.splitParts));
                    if (__hasFlexible) {
                        __areas.forEach(area => {
                            if (area && Array.isArray(area.splitParts)) {
                                const splitContainer = document.createElement('div');
                                splitContainer.className = 'column-split-content';
                                splitContainer.setAttribute('draggable', 'true');
                                area.splitParts.forEach(partArea => {
                                    const partDiv = document.createElement('div');
                                    partDiv.className = 'column-part';
                                    let sectionsHtml = '';
                                    (partArea.sections || []).forEach(sectionData => { sectionsHtml += buildSectionHtmlEx(sectionData, t); });
                                    partDiv.innerHTML = sectionsHtml;
                                    splitContainer.appendChild(partDiv);
                                });
                                contentWrapper.appendChild(splitContainer);
                            } else if (area && Array.isArray(area.sections)) {
                                let sectionsHtml = '';
                                area.sections.forEach(sectionData => { sectionsHtml += buildSectionHtmlEx(sectionData, t); });
                                contentWrapper.innerHTML += sectionsHtml;
                            }
                        });
                        contentWrapper.innerHTML += `<button class=\"add-section-btn\" onclick=\"addSection(this)\">+ ${t.newSection}</button>`;
                    } else {
                    // Baut die Spaltenstruktur (normal oder geteilt) auf
                    if (splitParts === 1 || splitState === 'normal') {
                        // FÃ¼r normale Spalten gibt es nur einen Inhaltsbereich
                        const areaData = columnData.contentAreas[0] || { sections: [] };
                        let sectionsHtml = '';
                        areaData.sections.forEach(sectionData => {
                            sectionsHtml += buildSectionHtmlEx(sectionData, t);
                        });
                        contentWrapper.innerHTML = sectionsHtml;
                    
                    } else {
                        // FÃ¼r geteilte Spalten wird die Split-Struktur erstellt
                        const parts = parseInt(columnData.splitParts || (splitState==='split-2'?2:(splitState==='split-3'?3:1)), 10);
                        const partClass = 'column-part';

                        const splitContainer = document.createElement('div');
                        splitContainer.className = 'column-split-content';
                        splitContainer.setAttribute('draggable', 'true');
                        // Optional Top-/Bottom-Bereiche um die Splits herum
                        const totalAreas = (columnData.contentAreas || []).length;
                        let startIdx = 0;
                        let endIdxOffset = 0;
                        if (totalAreas === parts + 2) { startIdx = 1; endIdxOffset = 1; }
                        else if (totalAreas === parts + 1) { startIdx = 1; endIdxOffset = 0; }
                        if (startIdx === 1) {
                            const topArea = columnData.contentAreas[0] || { sections: [] };
                            let topHtml = '';
                            topArea.sections.forEach(s => topHtml += buildSectionHtmlEx(s, t));
                            contentWrapper.innerHTML += topHtml;
                        }

                        for (let i = 0; i < parts; i++) {
                            const partDiv = document.createElement('div');
                            partDiv.className = partClass;

                            const areaData = columnData.contentAreas[i + (typeof startIdx !== 'undefined' ? startIdx : 0)] || { sections: [] };
                            let sectionsHtml = '';
                            areaData.sections.forEach(sectionData => {
                                sectionsHtml += buildSectionHtmlEx(sectionData, t);
                            });
                            partDiv.innerHTML = sectionsHtml;
                            splitContainer.appendChild(partDiv);
                        }
                        contentWrapper.appendChild(splitContainer);
                        if (typeof endIdxOffset !== 'undefined' && endIdxOffset === 1) {
                            const totalAreas2 = (columnData.contentAreas || []).length;
                            const bottomArea = columnData.contentAreas[totalAreas2 - 1] || { sections: [] };
                            let bottomHtml = '';
                            bottomArea.sections.forEach(s => bottomHtml += buildSectionHtmlEx(s, t));
                            contentWrapper.innerHTML += bottomHtml;
                        }
                    }
                    }
                    updateSplitCounterDisplay(column);
                    container.appendChild(column);
                });
            }
            // placeholders entfernt
            // FÃ¼gt am Ende den "+" Button fÃ¼r neue Spalten hinzu
            const addBtn = document.createElement('div');
            addBtn.className = 'add-column';
            addBtn.onclick = addNewColumn;
            addBtn.innerHTML = '<span>+</span>';
            container.appendChild(addBtn);

            // Post-load normalization: ensure resizers exist and alignment defaults are applied
            try {
                if (typeof enforceBoxFlex === 'function') enforceBoxFlex(document);
                if (typeof applyBoxLayoutAll === 'function') applyBoxLayoutAll(document);
            } catch(_) {}
            // If template saved canvas mode, restore it and positions
            try{
                if (layoutData && layoutData.canvas && layoutData.canvas.enabled){
                    if (typeof setCanvasSize==='function') setCanvasSize(layoutData.canvas.width||1920, layoutData.canvas.height||1080);
                    if (typeof toggleCanvasMode==='function') { var mc=document.getElementById('mainContainer'); if (mc && !mc.classList.contains('canvas-mode')) toggleCanvasMode(); }
                    if (layoutData.canvas.connectors && typeof window.__setCanvasConnectors==='function') window.__setCanvasConnectors(layoutData.canvas.connectors);
                }
            }catch(_){ }
        }

// HELFER-FUNKTION: Baut das HTML fÃ¼r eine einzelne Sektion (wird von applyLayoutData genutzt)
        function buildSectionHtml(sectionData, t) {
            let boxesHtml = '';
            if (sectionData.boxes && Array.isArray(sectionData.boxes)) {
                sectionData.boxes.forEach(boxData => {
                    const lines = parseInt((boxData.baseLines || boxData.lines || '1'), 10) || 1;
                    const minHeight = (lines * 30);
                    const isDyn = !!boxData.dynamic;
                    const dataLinesAttr = `data-lines="${lines}" data-base-lines="${lines}" data-dynamic="${isDyn ? '1':'0'}"`;

                    let styleString = `min-height: ${minHeight}px;` + (isDyn ? '' : ` height: ${minHeight}px; overflow-y: hidden;`);
                    if (boxData.textColor) styleString += ` color: ${boxData.textColor};`;
                    // enforce flex centering (vertical) and default horizontal centering for one-liners
                    styleString += ` display: inline-flex; align-items: center;`;
                    if (!isDyn && lines === 1) {
                        styleString += ` justify-content: center; line-height: ${minHeight}px;`;
                    }
                    const styleAttr = `style="${styleString}"`;

                    boxesHtml += `<div class="app-box ${boxData.type || 'saas'} ${boxData.width || 'full-width'}" draggable="true" ${dataLinesAttr} ${styleAttr}>${boxData.text}<button class="delete-btn" onclick="deleteBox(this)">Ã</button><button class="resize-btn" onclick="toggleBoxWidth(this)">â</button></div>`;
                });
            }
            const sectionColor = sectionData.color || '#8B4513';
            return `
                <div class="section-group" draggable="true">
                    <div class="section-title" style="background: ${sectionColor}" data-color="${sectionColor}">
                        ${sectionData.title}
                        <span class="section-delete" onclick="deleteSection(this)" title="${t.deleteSectionTooltip}">Ã</span>
                        <span class="section-menu" onclick="showSectionColorPicker(this)">ð¨</span>
                    </div>
                    <div class="box-container">${boxesHtml}</div>
                </div>`;
        }  
        
        // Extended builder supporting image boxes in templates
        function buildSectionHtmlEx(sectionData, t) {
            let boxesHtml = '';
            if (sectionData.boxes && Array.isArray(sectionData.boxes)) {
                sectionData.boxes.forEach(boxData => {
                    if (boxData && boxData.isImage) {
                        boxesHtml += `<div class="app-box image-box ${boxData.width || 'full-width'}" draggable="true"><img src="${boxData.imageSrc || ''}" alt="image" /><button class="delete-btn" onclick="deleteBox(this)">x</button><button class="resize-btn" onclick="toggleBoxWidth(this)">\u001d</button></div>`;
                    } else if (boxData && boxData.isLine) {
                        const lineCls = boxData.lineClass || 'line-solid-1';
                        boxesHtml += `<div class="app-box line-box ${boxData.width || 'full-width'} ${lineCls}" draggable="true"><button class="delete-btn" onclick="deleteBox(this)">x</button></div>`;
                    } else {
                        const lines = parseInt((boxData && (boxData.baseLines || boxData.lines) ) || '1', 10) || 1;
                        const minHeight = (lines * 30);
                        const isDyn = !!(boxData && boxData.dynamic);
                        const dataLinesAttr = `data-lines="${lines}" data-base-lines="${lines}" data-dynamic="${isDyn ? '1':'0'}"`;
                        // Normalize restored height to 30px grid to prevent growth on reload
                        let restoredH = (boxData && boxData.resized && boxData.heightPx) ? Math.max(30, Math.round(boxData.heightPx / 30) * 30) : null;
                        let styleString = `min-height: ${minHeight}px;` + (isDyn && !restoredH ? '' : ` height: ${(restoredH || minHeight)}px; overflow-y: hidden;`);
                        if (boxData && boxData.textColor) styleString += ` color: ${boxData.textColor};`;
                        // restore alignment; default to centered if empty
                        const align = (boxData && boxData.textAlign) ? boxData.textAlign : 'center';
                        styleString += ` text-align: ${align};`;
                        // ensure correct flexbox for vertical centering
                        // some inline styles from templates may override CSS; enforce here
                        styleString += ` display: inline-flex; align-items: center;`;
                        // map text-align to flex justification (persist exact value if present)
                        let justify = (boxData && boxData.justify) ? boxData.justify : '';
                        if (!justify) {
                            if (align === 'left') justify = 'flex-start';
                            else if (align === 'right') justify = 'flex-end';
                            else if (align === 'center') justify = 'center';
                            else if (align === 'justify') justify = 'flex-start';
                        }
                        // Always set justify-content to ensure proper alignment on load
                        styleString += ` justify-content: ${justify};`;
                        const styleAttr = `style="${styleString}"`;
                        const noAuto = (!isDyn && !restoredH && lines===1) ? 'data-noauto="1"' : '';
                        boxesHtml += `<div class="app-box ${(boxData && boxData.type) || 'saas'} ${(boxData && boxData.width) || 'full-width'}" draggable="true" ${dataLinesAttr} ${styleAttr} ${(boxData && boxData.resized)? 'data-resized="1"' : ''} ${noAuto}>${(boxData && boxData.text) || ''}<button class="delete-btn" onclick="deleteBox(this)">x</button><button class="resize-btn" onclick="toggleBoxWidth(this)">\u001d</button></div>`;
                    }
                });
            }
            const sectionColor = sectionData.color || '#8B4513';
            return `
                <div class="section-group" draggable="true">
                    <div class="section-title" style="background: ${sectionColor}" data-color="${sectionColor}">
                        ${sectionData.title}
                        <span class="section-delete" onclick="deleteSection(this)" title="${t.deleteSectionTooltip}">x</span>
                        <span class="section-menu" onclick="showSectionColorPicker(this)">?</span>
                    </div>
                    <div class="box-container">${boxesHtml}</div>
                </div>`;
        }
        
        function downloadStoredTemplate(templateName) {
            const template = getStoredTemplates()[templateName];
            if (template) downloadTemplateAsFile(template);
        }
        
        function deleteTemplate(templateName) {
            if (confirm(translations[currentLanguage].confirmDeleteCategory.replace('{name}', templateName))) {
                const templates = getStoredTemplates();
                delete templates[templateName];
            try {
                localStorage.setItem('architectureTemplates', JSON.stringify(templates));
            } catch(e) {
                console.warn('LocalStorage quota exceeded', e);
                // Keine Reduktion der Bilddaten â volle Vorlage bleibt im Download erhalten
                alert((translations[currentLanguage] && translations[currentLanguage].alertTemplateSaved ? translations[currentLanguage].alertTemplateSaved : 'Template gespeichert und heruntergeladen!').replace('{name}', name) + "\n(Hinweis: Speicherung im Browser-Speicher ist fehlgeschlagen â Limit Ã¼berschritten.)");
            }
                updateTemplateList();
            }
        }
        
        function loadTemplateFromFile() {
            const fileInput = document.getElementById('templateFileInput');
            const file = fileInput.files[0];
            const t = translations[currentLanguage];
            if (!file) { alert(t.alertChooseFile); return; }
            
            const reader = new FileReader();
            reader.onload = e => {
                try {
                    const templateData = JSON.parse(e.target.result);
                    if (!templateData.categories || !templateData.layout) throw new Error('Invalid format');
                    if (!confirm(t.confirmLoadFromFile.replace('{name}', templateData.name))) return;
                    
                    categories = templateData.categories;
                    updateCategoryStyles(); updateCategoryDropdown(); updateLegend();
                    if (templateData.fontSettings) { try { window.fontSettings = templateData.fontSettings; if (typeof applyAllFontStyles==='function') applyAllFontStyles(); } catch(_){} }
                    applyLayoutData(templateData.layout);
                    try { if (typeof enforceBoxFlex==='function') enforceBoxFlex(document); if (typeof applyBoxLayoutAll==='function') applyBoxLayoutAll(document); else if (typeof enforceBoxHeights==='function') enforceBoxHeights(document); } catch(_){}
                    window.currentTemplateName = templateData.name || '';
                    
                    closeModal('loadTemplateModal');
                    // HINWEIS: Die Erfolgsmeldung wurde hier entfernt (auskommentiert).
                    // alert(t.alertFileLoaded.replace('{name}', templateData.name));
                } catch (error) {
                    alert(t.alertFileLoadError + error.message);
                }
            };
            reader.readAsText(file);
        }
        
        // === PNG EXPORT FUNCTIONS ===
        function exportToPNG() {
            const container = document.querySelector('.main-container');
            const t = translations[currentLanguage];
            
            const button = event.target;
            const originalText = button.textContent;
            button.textContent = t.exporting;
            button.disabled = true;
            
            hideExportUIElements();
            
            // Compute bounding box of currently visible columns (and connectors) with padding
            function getVisibleColumnsBBox(padding){
                const cols = Array.from(document.querySelectorAll('.column'));
                const vw = window.innerWidth || document.documentElement.clientWidth || 0;
                const vh = window.innerHeight || document.documentElement.clientHeight || 0;
                let left = Infinity, top = Infinity, right = -Infinity, bottom = -Infinity;
                cols.forEach(col => {
                    const r = col.getBoundingClientRect();
                    const visible = r.right > 0 && r.left < vw && r.bottom > 0 && r.top < vh;
                    if (!visible) return;
                    left = Math.min(left, r.left);
                    top = Math.min(top, r.top);
                    right = Math.max(right, r.right);
                    bottom = Math.max(bottom, r.bottom);
                });
                // include connectors if present
                try{
                    const svg = document.getElementById('canvasConnectors');
                    if (svg && svg.style.display !== 'none'){
                        svg.querySelectorAll('path').forEach(p => {
                            const r = p.getBoundingClientRect();
                            left = Math.min(left, r.left);
                            top = Math.min(top, r.top);
                            right = Math.max(right, r.right);
                            bottom = Math.max(bottom, r.bottom);
                        });
                    }
                }catch(_){ }
                if (right <= left || bottom <= top) return null;
                const pad = typeof padding==='number' ? padding : 5;
                // Coordinates are viewportârelative for html2canvas(target=document.body)
                const x = Math.max(0, Math.floor(left) - pad);
                const y = Math.max(0, Math.floor(top) - pad);
                const width = Math.ceil((right - left) + pad * 2 + 2);   // +2 to avoid right edge truncation
                const height = Math.ceil((bottom - top) + pad * 2);
                return { x, y, width, height };
            }

            setTimeout(() => {
                const bbox = getVisibleColumnsBBox(5);
                const target = document.body; // crop from full page to avoid scroll issues
                const opts = bbox ? {
                    x: bbox.x, y: bbox.y, width: bbox.width, height: bbox.height,
                    scale: 2, backgroundColor: '#ffffff'
                } : {
                    scale: 2, backgroundColor: '#ffffff',
                    width: Math.max(container.scrollWidth, container.offsetWidth),
                    height: Math.max(container.scrollHeight, container.offsetHeight)
                };

                html2canvas(target, opts).then(canvas => {
                    // Wrap with a constant 5px border on all sides
                    try {
                        const BORDER = 5;
                        const out = document.createElement('canvas');
                        out.width = canvas.width + BORDER*2;
                        out.height = canvas.height + BORDER*2;
                        const ctx = out.getContext('2d');
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(0,0,out.width,out.height);
                        ctx.drawImage(canvas, BORDER, BORDER);
                        canvas = out;
                    } catch(_){ }
                    showExportUIElements();
                    const a = document.createElement('a');
                    a.href = canvas.toDataURL('image/png', 0.95);
                    a.download = 'enterprise-architecture-' + new Date().toISOString().split('T')[0] + '.png';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    
                    button.textContent = originalText;
                    button.disabled = false;
                    alert(t.alertExportSuccess);
                }).catch(error => {
                    showExportUIElements();
                    button.textContent = originalText;
                    button.disabled = false;
                    alert(t.alertExportError + error.message);
                });
            }, 100);
        }
        
        function hideExportUIElements() {
            // Mark document for screenshot-specific CSS rules
            document.documentElement.setAttribute('data-screenshot', 'true');

            // Hide interactive UI for clean export
            document.querySelectorAll('.add-section-btn').forEach(el => el.style.display = 'none');
            document.querySelectorAll('.header-btn, .split-counter, .resize-handle').forEach(el => el.style.visibility = 'hidden');
            document.querySelectorAll('.section-delete, .section-menu').forEach(el => el.style.visibility = 'hidden');
            // Also hide per-box controls and resize grips
            document.querySelectorAll('.delete-btn, .resize-btn, .height-resizer').forEach(el => el.style.visibility = 'hidden');
            document.querySelectorAll('.column-color-picker, .section-color-picker').forEach(el => el.style.display = 'none');
            document.querySelectorAll('.section-group').forEach(section => { section.style.border = 'none'; section.style.background = 'transparent'; });

            // Fix: Replace box-shadow with thin border for columns without header (better for html2canvas)
            document.querySelectorAll('.column[data-hide-column-header="true"]').forEach(col => {
                col.style.boxShadow = 'none';
                col.style.border = '1px solid #ddd';
            });
        }
        
        function showExportUIElements() {
            // Remove screenshot flag
            document.documentElement.removeAttribute('data-screenshot');

            // Restore interactive UI
            document.querySelectorAll('.add-section-btn').forEach(el => el.style.display = 'block');
            document.querySelectorAll('.header-btn').forEach(el => el.style.visibility = 'visible');
            document.querySelectorAll('.split-counter, .resize-handle').forEach(el => el.style.visibility = 'visible');
            document.querySelectorAll('.section-delete, .section-menu').forEach(el => el.style.visibility = 'visible');
            document.querySelectorAll('.delete-btn, .resize-btn, .height-resizer').forEach(el => el.style.visibility = 'visible');
            document.querySelectorAll('.section-group').forEach(section => { section.style.border = '2px dashed #999'; section.style.background = ''; });

            // Restore original styling for columns without header
            document.querySelectorAll('.column[data-hide-column-header="true"]').forEach(col => {
                col.style.boxShadow = '';
                col.style.border = '';
            });
        }
    </script>

<!-- Injected from Explainator2: Formatting Modal -->
<div class="modal" id="formattingModal" data-target="columns">
        <div class="modal-content">
            <div class="modal-header">ð  Schriftart anpassen</div>
            <div class="formatting-target-selector">
                <button class="btn active" onclick="switchFormattingTarget('columns', this)">Spalten</button>
                <button class="btn" onclick="switchFormattingTarget('sections', this)">Sections</button>
                <button class="btn" onclick="switchFormattingTarget('boxes', this)">Boxen</button>
            </div>
            <div class="modal-body">
                <label for="fontFamily">Schriftart:</label>
                <select id="fontFamily">
                    <option value="'Segoe UI', Arial, sans-serif">Segoe UI (Default)</option>
                    <option value="Arial, sans-serif">Arial</option>
                    <option value="'Times New Roman', Times, serif">Times New Roman</option>
                    <option value="'Courier New', Courier, monospace">Courier New</option>
                    <option value="Verdana, sans-serif">Verdana</option>
                    <option value="Georgia, serif">Georgia</option>
                </select>
                <label for="fontSize">SchriftgrÃ¶Ãe (px):</label>
                <input type="number" id="fontSize" value="14" min="8" max="32">
                <div style="display: flex; gap: 20px; margin-top: 15px;">
                    <label class="checkbox-label"><input type="checkbox" id="fontBold"><strong>Fett</strong></label>
                    <label class="checkbox-label"><input type="checkbox" id="fontItalic"><em>Kursiv</em></label>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" onclick="saveCurrentFontStyle()">Anwenden & SchlieÃen</button>
                <button class="btn btn-danger" onclick="closeModal('formattingModal')">Abbrechen</button>
            </div>
        </div>
    </div>

<script>
(function(){
  var styleEl = document.getElementById('font-styles');
  if(!styleEl){ styleEl = document.createElement('style'); styleEl.id='font-styles'; document.head.appendChild(styleEl); }

  window.fontSettings = window.fontSettings || {
    columns: { family:"'Segoe UI', Arial, sans-serif", size:14, bold:true, italic:false },
    sections:{ family:"'Segoe UI', Arial, sans-serif", size:12, bold:true, italic:false },
    boxes:   { family:"'Segoe UI', Arial, sans-serif", size:11, bold:false, italic:false }
  };

  function toCss(cfg){
    return "font-family:"+cfg.family+" !important; font-size:"+cfg.size+"px !important; font-weight:"+(cfg.bold?'700':'400')+" !important; font-style:"+(cfg.italic?'italic':'normal')+" !important;";
  }

  window.applyAllFontStyles = function(){
    var css = ""
      + ".column .column-header, .column .column-header input { " + toCss(window.fontSettings.columns) + " }\n"
      + ".section-title, .section-title input { " + toCss(window.fontSettings.sections) + " }\n"
      + ".app-box { " + toCss(window.fontSettings.boxes) + " }\n";
    styleEl.textContent = css;
  };

  window.showFormattingModal = function(){
    var m=document.getElementById('formattingModal'); if(m){ m.classList.add('show'); }
    // Load current target's values if selector exists
    var t = (m && m.getAttribute('data-target')) || 'columns';
    var cfg = window.fontSettings[t];
    var fam=document.getElementById('fontFamily'), size=document.getElementById('fontSize'), b=document.getElementById('fontBold'), i=document.getElementById('fontItalic');
    if(fam) fam.value = cfg.family;
    if(size) size.value = cfg.size;
    if(b) b.checked = !!cfg.bold;
    if(i) i.checked = !!cfg.italic;
  };

  window.switchFormattingTarget = function(target, btn){
    var m=document.getElementById('formattingModal'); if(m){ m.setAttribute('data-target', target); }
    if(btn && btn.parentElement){ btn.parentElement.querySelectorAll('.btn').forEach(function(x){ x.classList.remove('active'); }); btn.classList.add('active'); }
    // sync form
    var cfg = window.fontSettings[target];
    var fam=document.getElementById('fontFamily'), size=document.getElementById('fontSize'), b=document.getElementById('fontBold'), i=document.getElementById('fontItalic');
    if(fam) fam.value = cfg.family;
    if(size) size.value = cfg.size;
    if(b) b.checked = !!cfg.bold;
    if(i) i.checked = !!cfg.italic;
  };

  window.saveCurrentFontStyle = function(){
    var m=document.getElementById('formattingModal'); var t=(m && m.getAttribute('data-target'))||'columns';
    var fam=document.getElementById('fontFamily'), size=document.getElementById('fontSize'), b=document.getElementById('fontBold'), i=document.getElementById('fontItalic');
    var cfg=window.fontSettings[t];
    if(fam) cfg.family=fam.value||cfg.family;
    if(size){ var v=parseInt(size.value,10); if(!isNaN(v)) cfg.size=v; }
    if(b) cfg.bold=!!b.checked; if(i) cfg.italic=!!i.checked;
    window.applyAllFontStyles();
    if(m) m.classList.remove('show');
  };

  // Apply once
  window.applyAllFontStyles();
})();
</script>

<script>
// Inject "Linien" feature: button + modal + logic, without touching existing header markup
(function(){
  try{
    function t(key, fallback){
      try{ return (translations && translations[currentLanguage] && translations[currentLanguage][key]) || fallback; }catch(_){ return fallback; }
    }
    // 1) Inject Lines button next to "Neue Box"
    // ensureLinesButton removed; lines button is now static in HTML

    // 2) Inject CSS for line boxes
    function ensureLineStyles(){
      if(document.getElementById('line-box-styles')) return;
      var css = '/* line boxes */\n'
        + '.app-box.line-box{display:block;width:100%;min-height:30px;height:30px;margin:0;padding:0;background:transparent;border:none;box-shadow:none;cursor:move;position:relative;}\n'
        + '.app-box.line-box .delete-btn{top:-6px;right:-6px;}\n'
        + '.app-box.line-box .resize-btn{display:none;}\n'
        + '.app-box.line-box::before{content:"";position:absolute;left:0;right:0;top:50%;transform:translateY(-50%);}\n'
        + '.app-box.line-box.line-solid-1::before{border-top:2px solid #444;} .app-box.line-box.line-solid-2::before{border-top:4px solid #444;} .app-box.line-box.line-solid-3::before{border-top:6px solid #444;}\n'
        + '.app-box.line-box.line-dashed-1::before{border-top:2px dashed #444;} .app-box.line-box.line-dashed-2::before{border-top:4px dashed #444;} .app-box.line-box.line-dashed-3::before{border-top:6px dashed #444;}\n'
        + '.section-separator{width:100%;margin:6px 0;position:relative;height:30px;}\n'
        + '.section-separator::before{content:"";position:absolute;left:0;right:0;top:50%;transform:translateY(-50%);}\n'
        + '.section-separator.line-solid-1::before{border-top:2px solid #444;} .section-separator.line-solid-2::before{border-top:4px solid #444;} .section-separator.line-solid-3::before{border-top:6px solid #444;}\n'
        + '.section-separator.line-dashed-1::before{border-top:2px dashed #444;} .section-separator.line-dashed-2::before{border-top:4px dashed #444;} .section-separator.line-dashed-3::before{border-top:6px dashed #444;}\n';
      var st = document.createElement('style'); st.id='line-box-styles'; st.textContent = css; document.head.appendChild(st);
    }

    // 3) Inject modal markup
    function ensureLineModal(){
      if(document.getElementById('addLineModal')) return;
      var wrap = document.createElement('div'); wrap.className='modal'; wrap.id='addLineModal';
      wrap.innerHTML = '\n<div class="modal-content">\n'
        + '  <div class="modal-header">'+t('addLineModalTitle','Linie hinzufÃ¼gen')+'</div>\n'
        + '  <div class="modal-body">\n'
        + '    <div style="display:flex; gap:16px; align-items:center; margin-bottom:10px;">\n'
        + '      <label style="min-width:120px;">'+t('lineStyle','Stil')+'</label>\n'
        + '      <label><input type="radio" name="lineStyle" value="solid" checked> '+t('solid','Durchgehend')+'</label>\n'
        + '      <label><input type="radio" name="lineStyle" value="dashed"> '+t('dashed','Gestrichelt')+'</label>\n'
        + '    </div>\n'
        + '    <div style="display:flex; gap:16px; align-items:center;">\n'
        + '      <label style="min-width:120px;">'+t('lineThickness','StÃ¤rke')+'</label>\n'
        + '      <label><input type="radio" name="lineThk" value="1" checked> 1</label>\n'
        + '      <label><input type="radio" name="lineThk" value="2"> 2</label>\n'
        + '      <label><input type="radio" name="lineThk" value="3"> 3</label>\n'
        + '    </div>\n'
        + '  </div>\n'
        + '  <div class="modal-footer">\n'
        + '    <button class="btn btn-primary" data-action="add">'+t('add','HinzufÃ¼gen')+'</button>\n'
        + '    <button class="btn btn-danger" data-action="cancel">'+t('cancel','Abbrechen')+'</button>\n'
        + '  </div>\n'
        + '</div>';
      document.body.appendChild(wrap);
      wrap.addEventListener('click', function(e){
        if(e.target.getAttribute && e.target.getAttribute('data-action')==='add'){ addLineNew(); }
        if(e.target.getAttribute && e.target.getAttribute('data-action')==='cancel'){ closeModal('addLineModal'); }
      }, true);
    }

    // 4) Public helpers
    // target for section separators
    window.__lineInsertTarget = { mode:'box', section:null, position:null };
    window.showAddLineModal = function(opts){
      ensureLineStyles(); ensureLineModal();
      window.__lineInsertTarget = Object.assign({ mode:'box', section:null, position:null }, opts||{});
      var m=document.getElementById('addLineModal'); if(m) m.classList.add('show');
    };
    window.addLineNew = function(){
      try{
        var style = (document.querySelector('input[name="lineStyle"]:checked')||{}).value || 'solid';
        var thk = (document.querySelector('input[name="lineThk"]:checked')||{}).value || '1';
        var cls = 'line-'+style+'-'+thk;
        if (window.__lineInsertTarget && window.__lineInsertTarget.mode === 'section' && window.__lineInsertTarget.section) {
          // Insert as section separator
          var sep = document.createElement('div');
          sep.className = 'section-separator '+cls;
          var sec = window.__lineInsertTarget.section;
          var pos = window.__lineInsertTarget.position === 'before' ? 'before' : 'after';
          if (pos === 'before') sec.parentNode.insertBefore(sep, sec);
          else sec.parentNode.insertBefore(sep, sec.nextSibling);
        } else {
          // Default: line inside current section's box-container
          var box = document.createElement('div');
          box.className = 'app-box line-box full-width '+cls;
          box.draggable = true;
          box.innerHTML = '<button class="delete-btn" onclick="deleteBox(this)">x</button>';
          var target = (typeof getTargetBoxContainer==='function') ? getTargetBoxContainer() : document.querySelector('.box-container');
          if(target) target.appendChild(box);
          try { if (typeof applyBoxLayout==='function') applyBoxLayout(box); } catch(_){ }
        }
        closeModal('addLineModal');
      } catch(err){ console.warn(err); }
    };

    // Initialize
    if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', function(){ ensureLineStyles(); }, { once:true });
    else { ensureLineStyles(); }
  }catch(err){ console.warn(err); }
})();
</script>

<script>
// Vertical height resizer for all app-box (except line/image boxes)
(function(){
  function ensureHandle(box){
    try{
      if (!box || !box.classList || box.classList.contains('image-box') || box.classList.contains('line-box')) return;
      if (box.querySelector('.height-resizer')) return;
      const h = document.createElement('div');
      h.className = 'height-resizer';
      h.style.cssText = 'position:absolute; left:6px; bottom:-3px; width:36px; height:6px; cursor:ns-resize; background:#bbb; border-radius:3px; opacity:0.8;';
      box.style.position = box.style.position || 'relative';
      box.appendChild(h);
    }catch(_){ }
  }
  function ensureAll(){ document.querySelectorAll('.app-box').forEach(ensureHandle); }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', ensureAll, { once:true }); else ensureAll();
  try{
    const obs = new MutationObserver(muts => {
      muts.forEach(m => {
        (m.addedNodes||[]).forEach(n => {
          if (n.nodeType===1){
            if (n.classList && n.classList.contains('app-box')) ensureHandle(n);
            else if (n.querySelectorAll) n.querySelectorAll('.app-box').forEach(ensureHandle);
          }
        });
      });
    });
    obs.observe(document.body, { childList:true, subtree:true });
  }catch(_){ }

  // Drag behavior
  (function(){
    let active = null, startY = 0, startH = 0;
    let snapTargets = [];
    let snapGuide = null;

    function ensureSnapGuide(){
      if (snapGuide && document.body.contains(snapGuide)) return snapGuide;
      snapGuide = document.createElement('div');
      snapGuide.id = 'snapGuideLine';
      snapGuide.style.cssText = 'position:absolute; left:0; right:0; height:0; border-top:1px dashed #2196F3; pointer-events:none; z-index:20000; display:none;';
      document.body.appendChild(snapGuide);
      return snapGuide;
    }

    function collectSnapTargets(exclude){
      const list = [];
      document.querySelectorAll('.app-box').forEach(box => {
        if (!box || box === exclude) return;
        // include image-boxes as valid snap targets; skip only helper line-boxes
        if (box.classList.contains('line-box')) return;
        const r = box.getBoundingClientRect();
        const y = Math.round(r.bottom + window.scrollY);
        list.push(y);
      });
      // de-duplicate close values
      list.sort((a,b)=>a-b);
      const unique = [];
      for (let i=0;i<list.length;i++){
        if (!unique.length || Math.abs(list[i]-unique[unique.length-1])>1) unique.push(list[i]);
      }
      return unique;
    }
    function onDown(e){
      const grip = e.target.closest && e.target.closest('.height-resizer');
      if(!grip) return;
      e.preventDefault(); e.stopPropagation();
      active = grip.parentElement;
      startY = e.clientY || (e.touches && e.touches[0] && e.touches[0].clientY) || 0;
      startH = active.getBoundingClientRect().height;
      // prepare snapping
      snapTargets = collectSnapTargets(active);
      ensureSnapGuide(); snapGuide.style.display = 'none';
      document.addEventListener('mousemove', onMove, true);
      document.addEventListener('touchmove', onMove, { passive:false, capture:true });
      document.addEventListener('mouseup', onUp, true);
      document.addEventListener('touchend', onUp, true);
    }
    function onMove(e){
      if(!active) return;
      const y = e.clientY || (e.touches && e.touches[0] && e.touches[0].clientY) || 0;
      const dy = y - startY;
      let nh = Math.max(30, Math.round(startH + dy));
      // snapping: align bottom to nearest target (within tolerance)
      try{
        const topAbs = Math.round(active.getBoundingClientRect().top + window.scrollY);
        const tentativeBottom = topAbs + nh;
        let best = null, bestDelta = Infinity;
        for (let i=0;i<snapTargets.length;i++){
          const t = snapTargets[i];
          const d = Math.abs(t - tentativeBottom);
          if (d < bestDelta){ bestDelta = d; best = t; }
        }
        const TOL = 6; // px
        if (best !== null && bestDelta <= TOL){
          nh = Math.max(30, best - topAbs);
          if (snapGuide){ snapGuide.style.top = best + 'px'; snapGuide.style.display = 'block'; }
        } else {
          if (snapGuide) snapGuide.style.display = 'none';
        }
      }catch(_){ if (snapGuide) snapGuide.style.display = 'none'; }
      active.style.height = nh + 'px';
      active.dataset.resized = '1';
      try { active.removeAttribute('data-noauto'); } catch(_){ }
      active.setAttribute('data-dynamic','1');
      if (e.cancelable) { e.preventDefault(); }
    }
    function onUp(){
      document.removeEventListener('mousemove', onMove, true);
      document.removeEventListener('touchmove', onMove, true);
      document.removeEventListener('mouseup', onUp, true);
      document.removeEventListener('touchend', onUp, true);
      try{ if (snapGuide) snapGuide.style.display = 'none'; }catch(_){ }
      active = null;
    }
    document.addEventListener('mousedown', onDown, true);
    document.addEventListener('touchstart', onDown, { passive:false, capture:true });
  })();
})();
</script>

<script>
// Post-pass to ensure all boxes have proper flex centering and sane geometry
(function(){
  window.enforceBoxFlex = function(root){
    try{
      var scope = root && root.querySelectorAll ? root : document;
      scope.querySelectorAll('.app-box').forEach(function(box){
        if (box.classList.contains('image-box') || box.classList.contains('line-box')) return;
        var st = box.style;
        // enforce inline-flex and vertical centering
        if (st.display !== 'inline-flex') st.display = 'inline-flex';
        if (st.alignItems !== 'center') st.alignItems = 'center';
        // ensure baseline line-height does not clip/crop text
        if (!st.lineHeight || st.lineHeight === '') st.lineHeight = 'normal';
        // map text-align to justify-content if not explicitly set
        if (!st.justifyContent || st.justifyContent === ''){
          var ta = st.textAlign || window.getComputedStyle(box).textAlign || 'center';
          if (ta === 'left') st.justifyContent = 'flex-start';
          else if (ta === 'right') st.justifyContent = 'flex-end';
          else st.justifyContent = 'center';
        }
        
      });
    }catch(_){ }
  };
})();
</script>

<style id="box-stability-fixes">
/* Ensure control buttons never influence box height */
.app-box { position: relative; }
.app-box .delete-btn,
.app-box .resize-btn { position: absolute; }
/* keep center grip visual without affecting layout */
.app-box .resize-btn { bottom: 4px; left: 50%; transform: translateX(-50%); }
.app-box .delete-btn { top: 4px; right: 6px; }
</style>


<script>
// Excel export (columns -> sections -> boxes). Images become placeholders image1, image2, ...
(function(){
  /* function ensureExcelButton(){
    try{
      var controls = document.querySelector('.controls'); if(!controls) return;
      if (controls.querySelector('[data-role="excel-export-btn"]')) return;
      var btn = document.createElement('button');
      btn.className = 'btn btn-info'; btn.type='button'; btn.setAttribute('data-role','excel-export-btn');
      btn.textContent = 'ð Excel';
      btn.addEventListener('click', function(e){ e.preventDefault(); e.stopPropagation(); try{ exportToExcel(); }catch(err){ console.warn(err); } }, true);
      var anchor = controls.querySelector('[onclick*="showCategoryModal"]');
      controls.insertBefore(btn, anchor || controls.firstChild);
    }catch(_){ }
  } */

  // Canvas toggle button
  /* function ensureCanvasToggle(){
    try{
      var controls = document.querySelector('.controls'); if(!controls) return;
      if (controls.querySelector('[data-role="canvas-toggle-btn"]')) return;
      var btn = document.createElement('button');
      btn.className = 'btn btn-secondary'; btn.type='button'; btn.setAttribute('data-role','canvas-toggle-btn');
      btn.textContent = 'ð¼ï¸ Canvas'; btn.title = 'Open Canvas Mode ein/aus';
      btn.addEventListener('click', function(e){ e.preventDefault(); e.stopPropagation(); try{ toggleCanvasMode(); }catch(err){ console.warn(err); } }, true);
      var anchor = controls.querySelector('[onclick*="exportToPNG"]');
      if (anchor && anchor.nextSibling) controls.insertBefore(btn, anchor.nextSibling); else controls.appendChild(btn);
    }catch(_){ }
  } */

  // Resolution selector for canvas (HD / Full HD)
  /* function ensureCanvasResolution(){
    try{
      var controls = document.querySelector('.controls'); if(!controls) return;
      if (controls.querySelector('[data-role="canvas-res-select"]')) return;
      var sel = document.createElement('select'); sel.className='btn'; sel.style.padding='6px 8px'; sel.setAttribute('data-role','canvas-res-select'); sel.title='Canvas AuflÃ¶sung';
      sel.innerHTML = '<option value="1280x720">HD 1280Ã720</option><option value="1920x1080" selected>Full HD 1920Ã1080</option>';
      sel.addEventListener('change', function(){ try{ var v=this.value.split('x'); setCanvasSize(parseInt(v[0],10), parseInt(v[1],10)); }catch(_){ } });
      var anchor = controls.querySelector('[data-role="canvas-toggle-btn"]');
      if (anchor && anchor.nextSibling) controls.insertBefore(sel, anchor.nextSibling); else controls.appendChild(sel);
    }catch(_){ }
  } */

  // Connector tool toggle
  /* function ensureConnectorToggle(){
    try{
      var controls = document.querySelector('.controls'); if(!controls) return;
      if (controls.querySelector('[data-role="connector-toggle-btn"]')) return;
      var btn = document.createElement('button');
      btn.className='btn btn-info'; btn.setAttribute('data-role','connector-toggle-btn'); btn.textContent='ð Verbindungen'; btn.title='Connector-Modus ein/aus';
      btn.addEventListener('click', function(e){ e.preventDefault(); e.stopPropagation(); try{ toggleConnectorMode(); }catch(err){ console.warn(err);} }, true);
      controls.appendChild(btn);
    }catch(_){ }
  } */

  // Static controls in HTML now; only ensure CSS helpers elsewhere

  function collectExcelColumns(){
    var columns = [];
    var imgCount = 0; // placeholders only; no sources to avoid Excel cell limits
    var main = document.getElementById('mainContainer'); if(!main) return {columns:[], images:[]};
    main.querySelectorAll(':scope > .column').forEach(function(col){
      var title = (col.querySelector('.column-header') && col.querySelector('.column-header').childNodes[0] && col.querySelector('.column-header').childNodes[0].textContent.trim()) || '';
      var lines = [];
      var content = col.querySelector('.column-content'); if(!content){ columns.push({title:title, lines:lines}); return; }
      function pushSection(sec){
        var secTitleEl = sec.querySelector('.section-title');
        var secTitle = (secTitleEl && secTitleEl.childNodes[0] && secTitleEl.childNodes[0].textContent.trim()) || '';
        if (secTitle) lines.push(secTitle);
        var bc = sec.querySelector(':scope > .box-container'); if(!bc) return;
        bc.querySelectorAll(':scope > .app-box').forEach(function(box){
          if (box.classList.contains('image-box')){
            imgCount++; var ph = (imgCount<10? 'image0'+imgCount : 'image'+imgCount);
            // Only put placeholder in worksheet; do not include source anywhere to prevent 32767 char limit
            lines.push(ph);
          } else if (box.classList.contains('line-box')){
            lines.push('â');
          } else {
            var text=''; box.childNodes.forEach(function(n){ if(n.nodeType===3) text+=n.nodeValue; }); lines.push(text.trim());
          }
        });
        // spacer between sections
        lines.push('');
      }
      content.querySelectorAll(':scope > .section-group').forEach(pushSection);
      content.querySelectorAll(':scope > .column-split-content > .column-part > .section-group').forEach(pushSection);
      columns.push({title:title, lines:lines});
    });
    return {columns:columns, images:[]};
  }

  window.exportToExcel = function(){
    try{
      if (typeof XLSX === 'undefined' || !XLSX || !XLSX.utils) { alert('Excel export not available'); return; }
      var data = collectExcelColumns();
      var wb = XLSX.utils.book_new();
      var ws = XLSX.utils.aoa_to_sheet([[]]);
      // place each canvas column into its own Excel column (with a blank spacer column in-between)
      var colOffset = 0; var maxRows = 0;
      data.columns.forEach(function(c){ if (c.lines.length+1 > maxRows) maxRows = c.lines.length+1; });
      data.columns.forEach(function(c){
        XLSX.utils.sheet_add_aoa(ws, [[c.title]], {origin: {r:0, c:colOffset}});
        var colData = c.lines.map(function(v){ return [v]; });
        if (colData.length) XLSX.utils.sheet_add_aoa(ws, colData, {origin: {r:1, c:colOffset}});
        colOffset += 2; // spacer
      });
      XLSX.utils.book_append_sheet(wb, ws, 'Content');
      // No Images sheet: avoid huge Base64 URLs that exceed Excel cell limits
      var name = (window.currentTemplateName || 'Explainator') + '_export.xlsx';
      XLSX.writeFile(wb, name);
    }catch(err){ console.warn(err); alert('Excel export failed: '+err.message); }
  };

  // ensureExcelButton hook removed
})();
</script>
<script>
// Batch importer: paste lines -> create 1-line boxes into a new Import column split into 2 parts
(function(){
  function t(key, fallback){
    try{ return (translations && translations[currentLanguage] && translations[currentLanguage][key]) || fallback; }catch(_){ return fallback; }
  }
  /* function ensureImportButton(){
    var controls = document.querySelector('.controls'); if(!controls) return;
    if (controls.querySelector('[data-role="batch-import-btn"]')) return;
    var btn = document.createElement('button');
    btn.className = 'btn btn-secondary'; btn.type = 'button'; btn.setAttribute('data-role','batch-import-btn');
    btn.textContent = t('batchImport','ð¥ Batch Import');
    btn.addEventListener('click', function(e){ e.preventDefault(); e.stopPropagation(); showBatchImportModal(); }, true);
    // place after "Neue Box"
    var ref = controls.querySelector('[onclick*="showAddBoxModal"]');
    if (ref && ref.nextSibling) controls.insertBefore(btn, ref.nextSibling); else controls.appendChild(btn);
  } */

  function ensureImportModal(){
    if (document.getElementById('batchImportModal')) return;
    var wrap = document.createElement('div'); wrap.className = 'modal'; wrap.id = 'batchImportModal';
    wrap.innerHTML = '\n  <div class="modal-content">\n'
      + '    <div class="modal-header">'+t('batchImportTitle','Text â Box (1 line)')+'</div>\n'
      + '    <div class="modal-body">\n'
      + '      <div style="font-size:12px; color:#555; margin-bottom:6px;">'+t('batchImportHint','Eine Zeile pro Box. Leere Zeilen werden ignoriert.')+'</div>\n'
      + '      <textarea id="batchImportText" style="width:100%; min-height:180px; border:2px solid #ddd; border-radius:6px; padding:8px; font-family:inherit; font-size:13px;" placeholder="'+t('batchImportPlaceholder','Zeilen hier einfÃ¼gen...')+'"></textarea>\n'
      + '      <div style="display:flex; gap:12px; align-items:center; margin-top:10px;">\n'
      + '        <label>'+t('width','Breite')+': </label>\n'
      + '        <select id="batchImportWidth"><option value="full-width">'+t('fullWidth','Volle Breite')+'</option><option value="half-width">'+t('halfWidth','Halbe Breite')+'</option></select>\n'
      + '      </div>\n'
      + '    </div>\n'
      + '    <div class="modal-footer">\n'
      + '      <button class="btn btn-primary" data-action="apply">'+t('add','HinzufÃ¼gen')+'</button>\n'
      + '      <button class="btn btn-danger" data-action="cancel">'+t('cancel','Abbrechen')+'</button>\n'
      + '    </div>\n'
      + '  </div>';
    document.body.appendChild(wrap);
    wrap.addEventListener('click', function(e){
      var act = e.target && e.target.getAttribute && e.target.getAttribute('data-action');
      if (act === 'apply') { applyBatchImport(); }
      if (act === 'cancel') { closeModal('batchImportModal'); }
    }, true);
  }

  window.showBatchImportModal = function(){ ensureImportModal(); var m=document.getElementById('batchImportModal'); if(m) m.classList.add('show'); };

  function uniqueImportTitle(base){
    var name = base || 'Import';
    var exists = function(t){ return Array.from(document.querySelectorAll('.column-header')).some(h => (h.childNodes[0] && (h.childNodes[0].textContent||'').trim()===t)); };
    if (!exists(name)) return name;
    var i=2; while(exists(base+' '+i)) i++; return base+' '+i;
  }

  window.applyBatchImport = function(){
    try{
      var raw = (document.getElementById('batchImportText')||{}).value || '';
      var width = (document.getElementById('batchImportWidth')||{}).value || 'full-width';
      var lines = raw.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
      if (!lines.length) { closeModal('batchImportModal'); return; }

      var tdict = translations && translations[currentLanguage] || {};
      var title = uniqueImportTitle(tdict.importColumnTitle || 'Import');
      // Create column
      var col = createColumnElement(title, ++window.columnIdCounter);
      // Insert before the "+" add-column button if present
      var mc = document.getElementById('mainContainer');
      var addBtn = mc && mc.querySelector('.add-column');
      if (addBtn) mc.insertBefore(col, addBtn); else mc.appendChild(col);
      // Split into 2 parts
      try { applySplit(col, 2); } catch(_){ }
      // Prepare a section in each part
      var parts = col.querySelectorAll('.column-part');
      function ensureSectionIn(el){
        var s = document.createElement('div'); s.className='section-group'; s.setAttribute('draggable','true');
        var st = document.createElement('div'); st.className='section-title'; st.textContent = (tdict.newSection || 'Neue Section');
        var del = document.createElement('span'); del.className='section-delete'; del.textContent='x'; del.setAttribute('onclick','deleteSection(this)');
        var menu = document.createElement('span'); menu.className='section-menu'; menu.textContent='ð¨'; menu.setAttribute('onclick','showSectionColorPicker(this)');
        st.appendChild(del); st.appendChild(menu);
        var bc = document.createElement('div'); bc.className='box-container';
        s.appendChild(st); s.appendChild(bc);
        el.appendChild(s);
        return bc;
      }
      var bc1 = (parts[0] && parts[0].querySelector('.box-container')) || ensureSectionIn(parts[0]||col.querySelector('.column-content'));
      var bc2 = (parts[1] && parts[1].querySelector('.box-container')) || ensureSectionIn(parts[1]||col.querySelector('.column-content'));

      // Create boxes alternating between the two parts
      lines.forEach(function(txt, idx){
        var box = document.createElement('div');
        box.className = 'app-box saas ' + width; box.draggable = true;
        box.innerHTML = txt + '<button class="delete-btn" onclick="deleteBox(this)">x</button><button class="resize-btn" onclick="toggleBoxWidth(this)">\u001d</button>';
        // ensure centered like normal boxes
        box.style.textAlign = 'center';
        box.style.justifyContent = 'center';
        box.dataset.lines = '1'; box.setAttribute('data-base-lines','1'); box.setAttribute('data-dynamic','0'); box.setAttribute('data-noauto','1');
        box.style.minHeight = (1*30)+'px'; box.style.height = (1*30)+'px'; box.style.overflowY = 'hidden';
        ((idx%2===0)? bc1 : bc2).appendChild(box);
        try { applyBoxLayout(box); } catch(_){ }
      });

      closeModal('batchImportModal');
    }catch(err){ console.warn(err); }
  };

  // ensureImportButton hook removed
})();
</script>

<script>
(function(){
  function addColumnPipette(header){
    if (!header || header.querySelector('.pipette-column-btn')) return;
    var pip = document.createElement('span');
    pip.className = 'header-btn pipette-column-btn pipette-btn';
    pip.title = 'Farbe mit Pipette wÃ¤hlen';
    pip.setAttribute('draggable','false');
    pip.textContent = 'ð§ª';
    pip.addEventListener('pointerdown', function(ev){ ev.stopPropagation(); }, true);
    pip.addEventListener('click', async function(e){
      e.preventDefault(); e.stopPropagation();
      try{
        var headerEl = header; // capture via closure
        // Call picker without a target ID, just get the color back
        const color = await (window.pickEyeDropper ? pickEyeDropper() : (async ()=>null)());
        if (color && headerEl) {
            applyHeaderColor(headerEl, color);
        }
      }catch(_){ }
    }, true);
    header.appendChild(pip);
  }
  function addSectionPipette(title){
    if (!title || title.querySelector('.section-pipette')) return;
    var pip = document.createElement('span');
    pip.className = 'section-pipette pipette-btn';
    pip.title = 'Farbe mit Pipette wÃ¤hlen';
    pip.textContent = 'ð§ª';
    pip.addEventListener('pointerdown', function(ev){ ev.stopPropagation(); }, true);
    pip.addEventListener('click', async function(e){
      e.preventDefault(); e.stopPropagation();
      try{
        // Call picker without a target ID, just get the color back
        const color = await (window.pickEyeDropper ? pickEyeDropper() : (async ()=>null)());
        if (color) {
            applySectionColor(title, color);
        }
      }catch(_){ }
    }, true);
    title.appendChild(pip);
  }
  function bootstrap(){
    document.querySelectorAll('.column-header').forEach(addColumnPipette);
    document.querySelectorAll('.section-title').forEach(addSectionPipette);
  }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', bootstrap, { once:true }); else bootstrap();
  try{
    var mo = new MutationObserver(function(muts){
      for (var m of muts){
        for (var n of m.addedNodes||[]){
          if (n.nodeType!==1) continue;
          if (n.classList && n.classList.contains('column-header')) addColumnPipette(n);
          if (n.classList && n.classList.contains('section-title')) addSectionPipette(n);
          if (n.querySelectorAll){
            n.querySelectorAll('.column-header').forEach(addColumnPipette);
            n.querySelectorAll('.section-title').forEach(addSectionPipette);
          }
        }
      }
    });
    mo.observe(document.body, {childList:true, subtree:true});
  }catch(_){ }
})();
</script>

<script>
// Open Canvas Mode: free repositioning of columns on a fixed canvas
(function(){
  if (window.__canvas_mode_installed__) return; window.__canvas_mode_installed__ = true;
  var state = { enabled:false, width:1920, height:1080 };

  window.toggleCanvasMode = function(){
    var mc = document.getElementById('mainContainer'); if(!mc) return;
    state.enabled = !state.enabled;
    if (state.enabled) enableCanvas(); else disableCanvas();
  };

  window.setCanvasSize = function(w,h){
    state.width = Math.max(640, parseInt(w,10)||state.width);
    state.height = Math.max(360, parseInt(h,10)||state.height);
    var mc = document.getElementById('mainContainer'); if(!mc) return;
    if (state.enabled){ mc.style.width = state.width+'px'; mc.style.height = state.height+'px'; clampColumnsIntoCanvas(); }
  };

  function enableCanvas(){
    var mc = document.getElementById('mainContainer'); if(!mc) return;
    mc.classList.add('canvas-mode');
    mc.style.width = state.width + 'px';
    mc.style.height = state.height + 'px';
    // ensure connector layer
    ensureConnectorLayer();
    // position columns in a simple grid initially
    var cols = Array.from(mc.querySelectorAll(':scope > .column'));
    var x = 10, y = 10, maxH = 0; var gap = 10;
    cols.forEach(function(c, idx){
      var sx = c.getAttribute('data-canvas-x'); var sy = c.getAttribute('data-canvas-y');
      if (sx!=null && sy!=null){
        c.style.left = parseInt(sx,10)+'px'; c.style.top = parseInt(sy,10)+'px';
      } else {
        c.setAttribute('data-canvas-x', x);
        c.setAttribute('data-canvas-y', y);
        c.style.left = x + 'px';
        c.style.top = y + 'px';
      }
      var h = c.getBoundingClientRect().height; if (h>maxH) maxH=h;
      x += (c.offsetWidth + gap);
      if (x + c.offsetWidth + gap > state.width){ x = 10; y += (maxH + gap); maxH = 0; }
    });
    installColumnDrag();
    try{ updateAllConnectors(); }catch(_){ }
  }

  // Column/Section header visibility toggles
  /* window.ensureHeaderModeToggles = function(){
    try{ ensureHeaderModeCss(); }catch(_){ }
    try{
      var controls = document.querySelector('.controls'); if(!controls) return;
      // Column mode toggle (default ON => headers visible)
      if (!controls.querySelector('[data-role="columns-mode-toggle"]')){
        var cbtn = document.createElement('button');
        cbtn.className = 'btn btn-secondary';
        cbtn.type = 'button';
        cbtn.setAttribute('data-role','columns-mode-toggle');
        cbtn.textContent = 'Spalten: An';
        cbtn.title = 'Spalten-Header ein/aus';
        cbtn.addEventListener('click', function(e){
          e.preventDefault(); e.stopPropagation();
          var root = document.documentElement;
          var off = root.classList.toggle('mode-columns-off');
          cbtn.textContent = off ? 'Spalten: Aus' : 'Spalten: An';
          try{ if (typeof updateAllConnectors==='function') updateAllConnectors(); }catch(_){ }
        }, true);
        var anchor = controls.querySelector('[data-role="canvas-toggle-btn"]');
        if (anchor && anchor.nextSibling) controls.insertBefore(cbtn, anchor.nextSibling); else controls.appendChild(cbtn);
      }
      // Section mode toggle (default ON => section titles visible)
      if (!controls.querySelector('[data-role="sections-mode-toggle"]')){
        var sbtn = document.createElement('button');
        sbtn.className = 'btn btn-secondary';
        sbtn.type = 'button';
        sbtn.setAttribute('data-role','sections-mode-toggle');
        sbtn.textContent = 'Sections: An';
        sbtn.title = 'Section-Header ein/aus';
        sbtn.addEventListener('click', function(e){
          e.preventDefault(); e.stopPropagation();
          var root = document.documentElement;
          var off = root.classList.toggle('mode-sections-off');
          sbtn.textContent = off ? 'Sections: Aus' : 'Sections: An';
        }, true);
        controls.appendChild(sbtn);
      }
    }catch(_){ }
  } */

  // CSS rules are now statically defined in <head>, so this function is no longer needed
  // Kept for backward compatibility (does nothing if style tag already exists)
  window.ensureHeaderModeCss = function(){
    // Style tag with id="header-modes-css" is now always present in <head>
    // This function is a no-op but kept for compatibility with existing code
  }

  // Provide simple togglers for static buttons
  window.toggleColumnsMode = function(btn){
    try{ ensureHeaderModeCss(); }catch(_){ }
    var root = document.documentElement;
    var off = root.classList.toggle('mode-columns-off');
    if (btn) btn.textContent = off ? 'Spalten: Aus' : 'Spalten: An';
    try{ if (typeof updateAllConnectors==='function') updateAllConnectors(); }catch(_){ }
  };
  window.toggleSectionsMode = function(btn){
    try{ ensureHeaderModeCss(); }catch(_){ }
    var root = document.documentElement;
    var off = root.classList.toggle('mode-sections-off');
    if (btn) btn.textContent = off ? 'Sections: Aus' : 'Sections: An';
  };

  function disableCanvas(){
    var mc = document.getElementById('mainContainer'); if(!mc) return;
    mc.classList.remove('canvas-mode');
    mc.style.width = '';
    mc.style.height = '';
    // hide connector layer
    var svg = document.getElementById('canvasConnectors'); if (svg) svg.style.display='none';
    // reset absolute positioning but keep saved attributes for later re-enable
    mc.querySelectorAll(':scope > .column').forEach(function(c){
      c.style.left = ''; c.style.top = ''; c.style.position='';
    });
    uninstallColumnDrag();
  }

  var dragging = null, dx=0, dy=0;
  function onHeaderDown(e){
    var mc = document.getElementById('mainContainer'); if(!mc || !mc.classList.contains('canvas-mode')) return;

    // First try to find column-header (preferred drag handle)
    var hdr = e.target.closest && e.target.closest('.column-header');
    var col = null;

    if (hdr) {
      col = hdr.parentElement;
    } else {
      // If no header found (or header is hidden), allow dragging from column itself
      col = e.target.closest && e.target.closest('.column');
      if (!col) return;

      // Check if column has hidden header
      var hasHiddenHeader = col.getAttribute('data-hide-column-header') === 'true';
      if (!hasHiddenHeader) return; // Only allow direct column drag if header is hidden

      // Ignore if clicking on interactive elements
      if (e.target.closest('.section-title')) return;
      if (e.target.closest('.app-box')) return;
      if (e.target.closest('.resize-handle')) return;
      if (e.target.closest('button')) return;
      if (e.target.closest('.section-menu')) return;
      if (e.target.closest('.section-delete')) return;
    }

    if (!col) return;
    dragging = col;
    if (hdr) hdr.style.cursor='grabbing';
    else col.style.cursor='grabbing';
    var r = col.getBoundingClientRect();
    dx = e.clientX - r.left; dy = e.clientY - r.top;
    document.addEventListener('mousemove', onMove, true);
    document.addEventListener('mouseup', onUp, true);
    e.preventDefault(); e.stopPropagation();
  }
  function onMove(e){
    if (!dragging) return;
    var mc = document.getElementById('mainContainer');
    var mcr = mc.getBoundingClientRect();
    var nx = e.clientX - mcr.left - dx; var ny = e.clientY - mcr.top - dy;
    // clamp
    nx = Math.max(0, Math.min(nx, mcr.width - dragging.offsetWidth));
    ny = Math.max(0, Math.min(ny, mcr.height - dragging.offsetHeight));
    // snap to grid (40px) for edges (left/top and right/bottom)
    var STEP = 40, TOL = 8;
    function snap(val, size, max){
      var leftQuot = Math.round(val/STEP)*STEP;
      if (Math.abs(leftQuot - val) <= TOL) val = leftQuot;
      // right edge snap
      var right = val + size;
      var rightQuot = Math.round(right/STEP)*STEP;
      if (Math.abs(rightQuot - right) <= TOL){ val = rightQuot - size; }
      return Math.max(0, Math.min(val, max - size));
    }
    nx = snap(nx, dragging.offsetWidth, mcr.width);
    ny = snap(ny, dragging.offsetHeight, mcr.height);
    dragging.style.left = Math.round(nx) + 'px';
    dragging.style.top  = Math.round(ny) + 'px';
    // live update connectors
    try{ updateAllConnectors(); }catch(_){ }
  }
  function onUp(){
    if (dragging){
      var hdr = dragging.querySelector('.column-header');
      if (hdr && hdr.style.display !== 'none') {
        hdr.style.cursor='grab';
      } else {
        // Column was dragged without header, reset column cursor
        dragging.style.cursor='grab';
      }
      document.removeEventListener('mousemove', onMove, true);
      document.removeEventListener('mouseup', onUp, true);
      // persist current positions in attributes for saving
      try{
        var mc = document.getElementById('mainContainer'); var mcr = mc.getBoundingClientRect();
        var cr = dragging.getBoundingClientRect();
        dragging.setAttribute('data-canvas-x', Math.round(cr.left - mcr.left));
        dragging.setAttribute('data-canvas-y', Math.round(cr.top - mcr.top));
      }catch(_){ }
      dragging = null;
    }
  }
  function installColumnDrag(){
    document.addEventListener('mousedown', onHeaderDown, true);
  }
  function uninstallColumnDrag(){
    document.removeEventListener('mousedown', onHeaderDown, true);
  }

  function clampColumnsIntoCanvas(){
    try{
      var mc = document.getElementById('mainContainer'); var mcr = mc.getBoundingClientRect();
      mc.querySelectorAll(':scope > .column').forEach(function(c){
        var r = c.getBoundingClientRect();
        var nx = Math.max(0, Math.min(r.left - mcr.left, mcr.width - c.offsetWidth));
        var ny = Math.max(0, Math.min(r.top - mcr.top,  mcr.height - c.offsetHeight));
        c.style.left = Math.round(nx)+'px'; c.style.top = Math.round(ny)+'px';
      });
      try{ updateAllConnectors(); }catch(_){ }
    }catch(_){ }
  }
  // ===== Connectors =====
  var connectors = []; // {from: 'id', to: 'id'}
  var connectorMode = false; var pendingFrom = null;
  function ensureConnectorLayer(){
    var mc = document.getElementById('mainContainer'); if(!mc) return;
    var svg = document.getElementById('canvasConnectors');
    if (!svg){
      svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
      svg.setAttribute('id','canvasConnectors');
      svg.setAttribute('class','canvas-connectors');
      svg.style.display='block';
      mc.appendChild(svg);
    } else { svg.style.display='block'; }
  }
  // Get anchor point for column in specified direction
  // Supports 8 directions: top, top-right, right, bottom-right, bottom, bottom-left, left, top-left
  // Returns pixel-perfect coordinates rounded to whole pixels
  function getAnchorPoint(col, direction){
    var mc = document.getElementById('mainContainer'); if(!mc) return null;
    var mcr = mc.getBoundingClientRect();
    var r = col.getBoundingClientRect();

    // Round all values to whole pixels for crisp rendering
    var relX = Math.round(r.left - mcr.left);
    var relY = Math.round(r.top - mcr.top);
    var width = Math.round(r.width);
    var height = Math.round(r.height);
    var cx = Math.round(relX + width / 2);
    var cy = Math.round(relY + height / 2);

    switch(direction){
      // Cardinal directions (centered on edges)
      case 'top': return { x: cx, y: relY };
      case 'right': return { x: relX + width, y: cy };
      case 'bottom': return { x: cx, y: relY + height };
      case 'left': return { x: relX, y: cy };
      // Corner directions
      case 'top-right': return { x: relX + width, y: relY };
      case 'bottom-right': return { x: relX + width, y: relY + height };
      case 'bottom-left': return { x: relX, y: relY + height };
      case 'top-left': return { x: relX, y: relY };
      default: return { x: cx, y: cy }; // center fallback
    }
  }

  function getColCenterEdge(col){
    // legacy helper (not used anymore)
    var mc = document.getElementById('mainContainer'); var mcr = mc.getBoundingClientRect(); var r = col.getBoundingClientRect();
    var cxLeft = r.left - mcr.left; var cxRight = r.right - mcr.left; var cy = r.top - mcr.top + r.height/2;
    return {left:{x:cxLeft, y:cy}, right:{x:cxRight, y:cy}};
  }
  // Compute anchor points (relative to main container) between two columns
  // Now supports 360Â° (top, right, bottom, left)
  function chooseBestAnchors(fromEl, toEl, fromAnchor, toAnchor){
    try{
      // If manual anchors specified, use them
      if (fromAnchor && toAnchor) {
        var a = getAnchorPoint(fromEl, fromAnchor);
        var b = getAnchorPoint(toEl, toAnchor);
        if (a && b) return { a: a, b: b, fromDir: fromAnchor, toDir: toAnchor };
      }

      var mc = document.getElementById('mainContainer'); if(!mc) return null;
      var mcr = mc.getBoundingClientRect();
      var ar = fromEl.getBoundingClientRect();
      var br = toEl.getBoundingClientRect();

      var aRelLeft = ar.left - mcr.left, aRelRight = ar.right - mcr.left;
      var bRelLeft = br.left - mcr.left, bRelRight = br.right - mcr.left;
      var aRelTop = ar.top - mcr.top, aRelBottom = ar.bottom - mcr.top;
      var bRelTop = br.top - mcr.top, bRelBottom = br.bottom - mcr.top;

      var aCX = aRelLeft + ar.width/2, aCY = aRelTop + ar.height/2;
      var bCX = bRelLeft + br.width/2, bCY = bRelTop + br.height/2;

      var dx = Math.abs(bCX - aCX);
      var dy = Math.abs(bCY - aCY);

      // Prefer horizontal connections if columns are more horizontally separated
      if (dx > dy) {
        // Check if clearly left-to-right
        if (aRelRight <= bRelLeft) {
          return { a: getAnchorPoint(fromEl, 'right'), b: getAnchorPoint(toEl, 'left'), fromDir: 'right', toDir: 'left' };
        }
        // Check if clearly right-to-left
        if (bRelRight <= aRelLeft) {
          return { a: getAnchorPoint(fromEl, 'left'), b: getAnchorPoint(toEl, 'right'), fromDir: 'left', toDir: 'right' };
        }
        // Horizontal overlap: choose based on relative centers
        if (aCX < bCX) {
          return { a: getAnchorPoint(fromEl, 'right'), b: getAnchorPoint(toEl, 'left'), fromDir: 'right', toDir: 'left' };
        }
        return { a: getAnchorPoint(fromEl, 'left'), b: getAnchorPoint(toEl, 'right'), fromDir: 'left', toDir: 'right' };
      } else {
        // Prefer vertical connections if columns are more vertically separated
        // Check if clearly top-to-bottom
        if (aRelBottom <= bRelTop) {
          return { a: getAnchorPoint(fromEl, 'bottom'), b: getAnchorPoint(toEl, 'top'), fromDir: 'bottom', toDir: 'top' };
        }
        // Check if clearly bottom-to-top
        if (bRelBottom <= aRelTop) {
          return { a: getAnchorPoint(fromEl, 'top'), b: getAnchorPoint(toEl, 'bottom'), fromDir: 'top', toDir: 'bottom' };
        }
        // Vertical overlap: choose based on relative centers
        if (aCY < bCY) {
          return { a: getAnchorPoint(fromEl, 'bottom'), b: getAnchorPoint(toEl, 'top'), fromDir: 'bottom', toDir: 'top' };
        }
        return { a: getAnchorPoint(fromEl, 'top'), b: getAnchorPoint(toEl, 'bottom'), fromDir: 'top', toDir: 'bottom' };
      }
    }catch(_){ return null; }
  }
  // Smooth path with direction awareness
  // All coordinates rounded to whole pixels for crisp rendering
  function pathFor(a, b, fromDir, toDir){
    // Ensure input coordinates are rounded
    var ax = Math.round(a.x), ay = Math.round(a.y);
    var bx = Math.round(b.x), by = Math.round(b.y);
    var dx = bx - ax;
    var dy = by - ay;
    var adx = Math.abs(dx);
    var ady = Math.abs(dy);

    // Determine if connection is primarily horizontal or vertical
    var isHorizontal = (fromDir === 'left' || fromDir === 'right') && (toDir === 'left' || toDir === 'right');
    var isVertical = (fromDir === 'top' || fromDir === 'bottom') && (toDir === 'top' || toDir === 'bottom');

    if (isHorizontal || (!isVertical && adx > ady)) {
      // Horizontal-oriented curve
      var c1x = Math.round(ax + dx*0.5);
      var c2x = Math.round(bx - dx*0.5);
      return `M ${ax},${ay} C ${c1x},${ay} ${c2x},${by} ${bx},${by}`;
    } else if (isVertical || ady > adx) {
      // Vertical-oriented curve
      var c1y = Math.round(ay + dy*0.5);
      var c2y = Math.round(by - dy*0.5);
      return `M ${ax},${ay} C ${ax},${c1y} ${bx},${c2y} ${bx},${by}`;
    } else {
      // Diagonal/mixed - use smooth S-curve
      var c1x = Math.round(ax + dx*0.5);
      var c1y = Math.round(ay + dy*0.25);
      var c2x = Math.round(bx - dx*0.5);
      var c2y = Math.round(by - dy*0.25);
      return `M ${ax},${ay} C ${c1x},${c1y} ${c2x},${c2y} ${bx},${by}`;
    }
  }
function updateAllConnectors(){
    var svg = document.getElementById('canvasConnectors'); if(!svg) return;
    while (svg.firstChild) svg.removeChild(svg.firstChild);
    connectors.forEach(function(c, idx){
      var from = document.querySelector(`.column[data-column-id="${c.from}"]`);
      var to = document.querySelector(`.column[data-column-id="${c.to}"]`);
      if (!from || !to) return;

      // Use manual anchors if specified, otherwise auto-choose
      var pair = chooseBestAnchors(from, to, c.fromAnchor, c.toAnchor);
      if (!pair) return;

      var start = pair.a, end = pair.b;
      var fromDir = pair.fromDir || 'right';
      var toDir = pair.toDir || 'left';

      var p = document.createElementNS('http://www.w3.org/2000/svg','path');
      p.setAttribute('d', pathFor(start, end, fromDir, toDir));
      p.setAttribute('data-conn-index', String(idx));
      svg.appendChild(p);
    });
    // enable selection/deletion
    svg.querySelectorAll('path').forEach(function(path){
      path.addEventListener('click', function(ev){ ev.preventDefault(); ev.stopPropagation(); selectConnector(parseInt(path.getAttribute('data-conn-index'))); }, true);
    });
  }
  var selectedConn = -1;
  function selectConnector(i){
    selectedConn = i;
    var svg=document.getElementById('canvasConnectors'); if(!svg) return;
    svg.querySelectorAll('path').forEach(function(p){ p.classList.remove('conn-highlight'); });
    var el = svg.querySelector(`path[data-conn-index="${i}"]`); if (el) el.classList.add('conn-highlight');
  }
  document.addEventListener('keydown', function(e){
    if (selectedConn>=0 && (e.key==='Delete' || e.key==='Backspace')){
      connectors.splice(selectedConn,1); selectedConn=-1; updateAllConnectors();
    }
  }, true);
  // Anchor selection state
  var pendingFromAnchor = null;

  function showAnchorSelector(col, callback){
    // Remove existing overlay
    var existing = document.querySelector('.connector-anchor-overlay');
    if (existing) existing.remove();

    var mc = document.getElementById('mainContainer'); if(!mc) return;
    var mcr = mc.getBoundingClientRect();
    var r = col.getBoundingClientRect();

    var overlay = document.createElement('div');
    overlay.className = 'connector-anchor-overlay active';
    overlay.style.left = (r.left - mcr.left) + 'px';
    overlay.style.top = (r.top - mcr.top) + 'px';
    overlay.style.width = r.width + 'px';
    overlay.style.height = r.height + 'px';

    // 8 anchor points: 4 cardinal + 4 corners
    var directions = ['top', 'top-right', 'right', 'bottom-right', 'bottom', 'bottom-left', 'left', 'top-left'];
    directions.forEach(function(dir){
      var anchor = getAnchorPoint(col, dir);
      if (!anchor) return;

      var dot = document.createElement('div');
      dot.className = 'anchor-point';
      dot.style.left = anchor.x - (r.left - mcr.left) + 'px';
      dot.style.top = anchor.y - (r.top - mcr.top) + 'px';
      dot.setAttribute('data-direction', dir);
      dot.title = dir;

      dot.addEventListener('click', function(ev){
        ev.preventDefault(); ev.stopPropagation();
        overlay.remove();
        callback(dir);
      }, true);

      overlay.appendChild(dot);
    });

    mc.appendChild(overlay);

    // Auto-close after 5 seconds or click outside
    setTimeout(function(){
      function closeOverlay(ev){
        if (!overlay.contains(ev.target)){
          overlay.remove();
          document.removeEventListener('mousedown', closeOverlay, true);
        }
      }
      document.addEventListener('mousedown', closeOverlay, true);
    }, 100);
  }

  window.toggleConnectorMode = function(){
    connectorMode = !connectorMode;
    pendingFrom = null;
    pendingFromAnchor = null;
    // Remove any open anchor overlays
    document.querySelectorAll('.connector-anchor-overlay').forEach(function(el){ el.remove(); });
    ensureConnectorLayer();
    updateAllConnectors();
    var btn = document.querySelector('[data-role="connector-toggle-btn"]');
    if (btn) { btn.classList.toggle('is-active', connectorMode); btn.setAttribute('aria-pressed', connectorMode? 'true':'false'); }
  };

  // capture clicks on columns to build connections in connector mode
  document.addEventListener('click', function(e){
    if (!connectorMode) return;
    // ignore anchor point clicks (handled by their own listeners)
    if (e.target.closest('.anchor-point')) return;
    // ignore UI chrome clicks
    if (e.target && e.target.closest && (e.target.closest('.controls') || e.target.closest('.modal') || e.target.closest('.column-color-picker') || e.target.closest('.section-color-picker') || e.target.closest('.column-visibility-menu'))) return;
    var col = e.target && e.target.closest && e.target.closest('.column'); if (!col) return;
    var id = col.getAttribute('data-column-id'); if (!id) return;
    e.preventDefault(); e.stopPropagation();

    if (!pendingFrom){
      // First column clicked - show anchor selector
      showAnchorSelector(col, function(anchorDir){
        pendingFrom = String(id);
        pendingFromAnchor = anchorDir;
      });
    }
    else if (pendingFrom && pendingFrom !== id){
      // Second column clicked - show anchor selector and create connection
      showAnchorSelector(col, function(anchorDir){
        connectors.push({
          from: String(pendingFrom),
          to: String(id),
          fromAnchor: pendingFromAnchor,
          toAnchor: anchorDir
        });
        pendingFrom = null;
        pendingFromAnchor = null;
        ensureConnectorLayer();
        updateAllConnectors();
      });
    }
  }, true);
  // expose connectors for template persistence
  window.__getCanvasConnectors = function(){ return connectors.slice(); };
  window.__setCanvasConnectors = function(list){ connectors = Array.isArray(list)? list.slice(): []; ensureConnectorLayer(); updateAllConnectors(); };
})();
</script>
<script>
(function(){
  if (typeof window.applyHeaderColor !== 'function') {
    window.applyHeaderColor = function(header, color){
      if(!header) return;
      header.style.background = 'linear-gradient(to bottom,'+color+','+color+')';
      try { header.setAttribute('data-header-color', color); } catch(_){ }
      var col = header.closest('.column'); if(col) col.style.borderColor = color;
    };
  }
  // Delegated handler to ensure button always works for dynamic columns
  if (!window.__ea_color_delegate__) {
    window.__ea_color_delegate__ = true;
    document.addEventListener('click', function(e){
      var btn = e.target && e.target.closest && e.target.closest('.color-column-btn');
      if (!btn) return;
      e.preventDefault(); e.stopPropagation();
      try { if (typeof showColumnColorPicker === 'function') showColumnColorPicker(btn); } catch(err) { console.warn(err); }
    }, true);
  }
})();
</script>

<script>

window.showColumnColorPicker = function(btn){
  try{
    // Prevent header drag from swallowing events
    btn.setAttribute('draggable','false');
    btn.addEventListener('pointerdown', function(ev){ ev.stopPropagation(); ev.preventDefault(); }, { once:true });
  }catch(e){}

  // Close other pickers
  document.querySelectorAll('.column-color-picker').forEach(function(p){ p.remove(); });

  var header = btn.closest('.column-header');
  if(!header) return;
  header.style.position = header.style.position || 'relative';

  var p = document.createElement('div');
  p.className = 'column-color-picker';
  var headerColors = ['#8B4513','#A0522D','#CD853F','#D2691E','#FF9800','#FFC107','#FF5722',
                      '#2196F3','#1E88E5','#64B5F6','#00BCD4','#009688','#4CAF50','#8BC34A',
                      '#9C27B0','#AB47BC','#F44336','#E91E63','#607D8B','#455A64',
                      '#000000','#333333','#666666','#999999','#CCCCCC','#FFFFFF'];
  p.innerHTML = headerColors.map(function(c){return '<div class="swatch" data-c="'+c+'" style="background:'+c+'" title="'+c+'"></div>';}).join('')
    + '<div class="row" style="margin-top:8px;"><input type="color" id="col-custom" value="#8B4513" style="flex:0 0 40px;border:none;padding:0;"><button class="btn small-btn">Ãbernehmen</button></div>';

  // Stop events inside picker from bubbling to global handlers
  ['mousedown','pointerdown','click'].forEach(function(evt){
    p.addEventListener(evt, function(e){ e.stopPropagation(); }, true);
    btn.addEventListener(evt, function(e){ e.stopPropagation(); }, true);
  });

  header.appendChild(p);
  requestAnimationFrame(function(){ p.classList.add('show'); });

  // Enhance custom row: mark apply button and add pipette
  try{
    var row = p.querySelector('div.row');
    if(row){
      var firstBtn = row.querySelector('button');
      if(firstBtn){ firstBtn.setAttribute('data-action','apply'); firstBtn.textContent = 'Ãbernehmen'; }
      // Pipette in Column-Colorpicker entfernen (nur Farbfelder + Custom-Farbe)
    }
  }catch(_){ }

  p.addEventListener('click', function(e){
    var sw = e.target.closest && e.target.closest('.swatch');
    if(sw){ applyHeaderColor(header, sw.getAttribute('data-c')); p.remove(); return; }
    if(e.target && e.target.tagName === 'BUTTON'){
      var act = e.target.getAttribute('data-action');
      if(act === 'apply'){
        var c = p.querySelector('#col-custom').value; applyHeaderColor(header, c); p.remove(); return;
      }
    }
  }, true);

  // Close on outside mousedown (but not if inside picker)
  function onDoc(ev){
    if(!p.contains(ev.target) && ev.target!==btn){
      p.remove(); document.removeEventListener('mousedown', onDoc, true);
    }
  }
  setTimeout(function(){ document.addEventListener('mousedown', onDoc, true); }, 0);
};

</script>

<script>
(function(){
  // Helper to make header/menu buttons immune to drag swallowing
  function hardenInteractive(root){
    try{
      var scope = root || document;
      var sel = '.color-column-btn, .section-menu, .pipette-column-btn, .section-pipette';
      scope.querySelectorAll(sel).forEach(function(btnEl){
        try{
          btnEl.setAttribute('draggable','false');
          ['pointerdown','mousedown','dragstart'].forEach(function(evt){
            btnEl.addEventListener(evt, function(ev){ ev.stopPropagation(); ev.preventDefault(); }, true);
          });
        }catch(_){ }
      });
    }catch(_){ }
  }

  if(!window.__ea_color_delegate_v2__){
    window.__ea_color_delegate_v2__ = true;
    // Delegated pipette handlers so cloned icons always work
    document.addEventListener('click', function(e){
      var pip = e.target && e.target.closest && e.target.closest('.pipette-column-btn');
      if(!pip) return;
      e.preventDefault(); e.stopPropagation();
      try{
        var header = pip.closest('.column-header');
        Promise.resolve(window.pickEyeDropper ? pickEyeDropper() : null)
          .then(function(color){ if(color && header && typeof applyHeaderColor==='function') applyHeaderColor(header, color); })
          .catch(function(){ /* ignore */ });
      }catch(_){ }
    }, true);
    document.addEventListener('click', function(e){
      var pip = e.target && e.target.closest && e.target.closest('.section-pipette');
      if(!pip) return;
      e.preventDefault(); e.stopPropagation();
      try{
        var title = pip.closest('.section-title');
        Promise.resolve(window.pickEyeDropper ? pickEyeDropper() : null)
          .then(function(color){ if(color && title && typeof applySectionColor==='function') applySectionColor(title, color); })
          .catch(function(){ /* ignore */ });
      }catch(_){ }
    }, true);
    document.addEventListener('click', function(e){
      var b = e.target && e.target.closest && e.target.closest('.color-column-btn');
      if(!b) return;
      e.preventDefault(); e.stopPropagation();
      try{ (window.showColumnColorPicker||showColumnColorPicker)(b); }catch(err){ console.warn(err); }
    }, true);
    document.addEventListener('pointerdown', function(e){
      var b = e.target && e.target.closest && e.target.closest('.color-column-btn');
      if(b){ e.preventDefault(); e.stopPropagation(); }
    }, true);
    // Initial harden on load
    if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', function(){ hardenInteractive(document); }, { once:true });
    else hardenInteractive(document);
    // Re-harden after any drag lifecycle events
    ['dragend','drop'].forEach(function(evt){
      document.addEventListener(evt, function(){ hardenInteractive(document); }, true);
    });
    // Re-harden on dynamic DOM changes
    try{
      var obs = new MutationObserver(function(muts){
        for (var i=0;i<muts.length;i++){
          var m = muts[i];
          for (var j=0;j<(m.addedNodes?m.addedNodes.length:0); j++){
            var n = m.addedNodes[j];
            if (n && n.nodeType===1) hardenInteractive(n);
          }
          if (m.target && m.target.nodeType===1) hardenInteractive(m.target);
        }
      });
      obs.observe(document.body, { childList:true, subtree:true });
    }catch(_){ }
  }
})();
</script>

<script>
// Delegated handler for section color menu to survive clones/moves/renames
(function(){
  if (window.__ea_section_menu_delegate__) return;
  window.__ea_section_menu_delegate__ = true;
  // Open picker on click
  document.addEventListener('click', function(e){
    var m = e.target && e.target.closest && e.target.closest('.section-menu');
    if (!m) return;
    e.preventDefault(); e.stopPropagation();
    try { (window.showSectionColorPicker||showSectionColorPicker)(m); } catch(err){ console.warn(err); }
  }, true);
  // Prevent drags from swallowing clicks
  ['pointerdown','mousedown','dragstart'].forEach(function(evt){
    document.addEventListener(evt, function(ev){
      if (ev.target && ev.target.closest && ev.target.closest('.section-menu, .section-color-picker')){
        ev.preventDefault(); ev.stopPropagation();
      }
    }, true);
  });
  // Ensure every section-title has a section-menu; auto-repair if missing
  function ensureSectionMenu(title){
    try{
      if (!title || !title.classList || !title.classList.contains('section-title')) return;
      if (!title.querySelector('.section-menu')){
        var btn = document.createElement('span');
        btn.className = 'section-menu';
        btn.title = 'Farbe Ã¤ndern';
        btn.textContent = 'ð¨';
        btn.setAttribute('onclick', 'showSectionColorPicker(this)');
        btn.setAttribute('draggable','false');
        ['pointerdown','mousedown','click','dragstart'].forEach(function(evt){
          btn.addEventListener(evt, function(ev){ ev.stopPropagation(); if(evt!=='click') ev.preventDefault(); }, true);
        });
        title.appendChild(btn);
      }
      // Harden existing buttons as well
      title.querySelectorAll('.section-menu').forEach(function(btn){
        btn.setAttribute('draggable','false');
        ['pointerdown','mousedown','dragstart'].forEach(function(evt){
          btn.addEventListener(evt, function(ev){ ev.stopPropagation(); ev.preventDefault(); }, true);
        });
      });
    }catch(_){ }
  }
  function ensureAll(){ document.querySelectorAll('.section-title').forEach(ensureSectionMenu); }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', ensureAll, { once:true }); else ensureAll();
  try{
    var obs = new MutationObserver(function(muts){
      for (var i=0;i<muts.length;i++){
        var m = muts[i];
        for (var j=0;j<(m.addedNodes?m.addedNodes.length:0); j++){
          var n = m.addedNodes[j];
          if(n.nodeType===1){
            if (n.classList && n.classList.contains('section-title')) ensureSectionMenu(n);
            else if (n.querySelectorAll) n.querySelectorAll('.section-title').forEach(ensureSectionMenu);
          }
        }
        if (m.target && m.target.nodeType===1 && m.target.classList && m.target.classList.contains('section-title')){
          ensureSectionMenu(m.target);
        }
      }
    });
    obs.observe(document.body, { childList:true, subtree:true });
  }catch(_){ }
  // Close any open pickers when starting/ending a drag to avoid interference
  ['dragstart','dragend','drop'].forEach(function(evt){
    document.addEventListener(evt, function(){
      try {
        document.querySelectorAll('.section-color-picker, .column-color-picker').forEach(function(p){ p.remove(); });
      } catch(_){ }
    }, true);
  });
})();
</script>


<script>
(function(){
  function ensureColorButton(header){
    if(!header) return;
    if(header.querySelector('.color-column-btn')) return;
    var btn = document.createElement('span');
    btn.className = 'header-btn color-column-btn';
    btn.title = 'Header-Farbe Ã¤ndern';
    btn.setAttribute('draggable','false');
    btn.textContent = 'ðï¸';
    // Guard: prevent drag handlers from eating click
    btn.addEventListener('pointerdown', function(ev){ ev.stopPropagation(); }, true);
    btn.addEventListener('click', function(e){
      e.preventDefault(); e.stopPropagation();
      try { (window.showColumnColorPicker||showColumnColorPicker)(btn); } catch(err){ console.warn(err); }
    }, true);
    header.appendChild(btn);
  }
  function ensureCloneButton(header){
    if(!header) return;
    if(header.querySelector('.clone-column')) return;
    var btn = document.createElement('span');
    btn.className = 'header-btn clone-column';
    btn.title = 'Spalte klonen';
    btn.setAttribute('draggable','false');
    btn.textContent = 'â§';
    btn.addEventListener('pointerdown', function(ev){ ev.stopPropagation(); }, true);
    btn.addEventListener('click', function(e){ e.preventDefault(); e.stopPropagation(); try{ cloneColumn(btn); }catch(err){ console.warn(err);} }, true);
    header.appendChild(btn);
  }
  function ensureAll(){
    document.querySelectorAll('.column-header').forEach(function(h){ ensureColorButton(h); ensureCloneButton(h); });
  }
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', ensureAll, { once:true });
  } else {
    ensureAll();
  }
  // Observe dynamic changes to re-add icon when columns are re-rendered
  try{
    var obs = new MutationObserver(function(muts){
      for (var i=0;i<muts.length;i++){
        var m = muts[i];
        for (var j=0;j<(m.addedNodes?m.addedNodes.length:0); j++){
          var n = m.addedNodes[j];
          if(n.nodeType===1){
            if (n.classList && n.classList.contains('column-header')) { ensureColorButton(n); ensureCloneButton(n); }
            else if (n.querySelectorAll) n.querySelectorAll('.column-header').forEach(function(h){ ensureColorButton(h); ensureCloneButton(h); });
          }
        }
      }
    });
    obs.observe(document.body, { childList:true, subtree:true });
  }catch(e){}
})();
</script>


<script>
window.enterScreenshotMode = function(){ document.body.classList.add('screenshot-mode'); };
window.exitScreenshotMode = function(){ document.body.classList.remove('screenshot-mode'); };
window.addEventListener('vc:screenshot:start', function(){ document.body.classList.add('screenshot-mode'); });
window.addEventListener('vc:screenshot:end', function(){ document.body.classList.remove('screenshot-mode'); });
</script>


<script>
(function(){
  if (window.__colorBrushGuardInstalled__) return;
  window.__colorBrushGuardInstalled__ = true;
  const stop = ev => { ev.stopPropagation(); };
  ['pointerdown','mousedown','dragstart'].forEach(evt => {
    document.addEventListener(evt, function(ev){
      if (ev.target && ev.target.closest && ev.target.closest('.color-column-btn, .column-color-picker')) {
        // Allow pipette buttons to receive a real user gesture
        if (ev.target.closest('.pipette-btn')) return;
        // prevent column header drag when interacting with the color UI
        ev.preventDefault();
        ev.stopPropagation();
      }
    }, true);
  });
})();
</script>

<script>
    // ErmÃ¶glicht das Bearbeiten von Box-Texten per Doppelklick
    document.getElementById('mainContainer').addEventListener('dblclick', function(e) {
        const box = e.target.closest('.app-box');
        if (!box) return;
        // Do not edit line boxes
        if (box.classList && box.classList.contains('line-box')) return;

        // Verhindern, dass ein Input-Feld in sich selbst erstellt wird
        if (e.target.tagName === 'INPUT') return;

        const currentText = box.childNodes[0].nodeValue.trim();
        
        // TemporÃ¤r die Buttons ausblenden fÃ¼r mehr Platz
        const deleteBtn = box.querySelector('.delete-btn');
        const resizeBtn = box.querySelector('.resize-btn');
        if(deleteBtn) deleteBtn.style.display = 'none';
        if(resizeBtn) resizeBtn.style.display = 'none';

        // Erstelle das Input-Feld
        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'app-box-editor';
        input.value = currentText;
        
        // Ersetze den Textknoten durch das Input-Feld
        box.childNodes[0].replaceWith(input);
        input.focus();
        input.select();

        // Funktion, um die Bearbeitung abzuschlieÃen
        const finishEditing = () => {
            const newText = input.value.trim() || currentText; // Fallback auf alten Text, wenn leer
            const newTextNode = document.createTextNode(newText);
            input.replaceWith(newTextNode);

            // Buttons wieder einblenden
            if(deleteBtn) deleteBtn.style.display = '';
            if(resizeBtn) resizeBtn.style.display = '';

            // Event Listener wieder entfernen, um Speicherlecks zu vermeiden
            input.removeEventListener('blur', finishEditing);
            input.removeEventListener('keypress', handleKeyPress);
        };
        
        const handleKeyPress = (e) => {
            if (e.key === 'Enter') {
                finishEditing();
            }
        };

        // Event Listener hinzufÃ¼gen, um die Bearbeitung zu beenden
        input.addEventListener('blur', finishEditing);
        input.addEventListener('keypress', handleKeyPress);
    });
// Override global pipette with safe wrapper to ensure accurate sampling
(function(){
  if (window.__pipetteWrapperInstalled__) return; window.__pipetteWrapperInstalled__ = true;
  window.pickEyeDropper = async function(targetId){
    try{
      if (!('EyeDropper' in window)) {
        alert('Pipette wird von diesem Browser nicht unterstÃ¼tzt.');
        return null;
      }
      document.body.classList.add('eye-drop-mode');
      const ed = new EyeDropper();
      const res = await ed.open();
      const color = res && res.sRGBHex ? res.sRGBHex : null;
      if (color && targetId) {
          const input = document.getElementById(targetId);
          if (input) {
            input.value = color;
            // Trigger change event for any listeners, e.g. the color preview
            input.dispatchEvent(new Event('input', { bubbles: true }));
          }
      }
      return color;
    } catch(_) {
      return null; // User cancelled or browser doesn't support it
    }
    finally { document.body.classList.remove('eye-drop-mode'); }
  };
})();
</script>


</body>
</html>

<script>
// Rich text editor override for app-box (capture-phase to bypass old handler)
(function(){
  const mc = document.getElementById('mainContainer');
  if(!mc) return;
  mc.addEventListener('dblclick', function(e){
    const box = e.target && e.target.closest && e.target.closest('.app-box');
    if(!box || box.classList.contains('image-box')) return;
    if (box.classList && box.classList.contains('line-box')) return;
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
    e.preventDefault(); e.stopPropagation();

    // Helper: extract only plain text from direct text nodes (ignore button labels)
    function getBoxTextOnly(el){
      let t = '';
      el.childNodes.forEach(n => { if(n.nodeType===3) t += n.nodeValue; });
      return t;
    }
    const firstNode = box.childNodes[0];
    const currentText = (firstNode && firstNode.nodeType===3 ? firstNode.nodeValue : getBoxTextOnly(box)).trim();

    // Path A: Alt + DblClick => dynamic editor (textarea)
    if (e.altKey) {
      box.setAttribute('data-dynamic','1');
      try { applyBoxLayout(box); } catch(_){}
    } else {
      // Path B: plain DblClick => single-line quick edit (fixed height)
      const deleteBtn = box.querySelector('.delete-btn');
      const resizeBtn = box.querySelector('.resize-btn');
      if(deleteBtn) deleteBtn.style.display='none';
      if(resizeBtn) resizeBtn.style.display='none';
      const input = document.createElement('input');
      input.type = 'text';
      input.className = 'app-box-editor';
      input.value = currentText;
      if (firstNode && firstNode.nodeType===3) firstNode.replaceWith(input); else box.insertBefore(input, box.firstChild);
      input.focus(); input.select();
      const finishQuick = (apply=true)=>{
        const txt = apply ? (input.value || currentText) : currentText;
        const tn = document.createTextNode(txt);
        input.replaceWith(tn);
        box.setAttribute('data-dynamic','0');
        try { applyBoxLayout(box); } catch(_){}
        if(deleteBtn) deleteBtn.style.display='';
        if(resizeBtn) resizeBtn.style.display='';
        input.removeEventListener('keydown', onKey, true);
        input.removeEventListener('blur', onBlur, true);
      };
      const onKey = (ev)=>{ if(ev.key==='Escape'){ ev.preventDefault(); finishQuick(false);} if(ev.key==='Enter'){ ev.preventDefault(); finishQuick(true);} };
      const onBlur = ()=> finishQuick(true);
      input.addEventListener('keydown', onKey, true);
      input.addEventListener('blur', onBlur, true);
      return;
    }
    const deleteBtn = box.querySelector('.delete-btn');
    const resizeBtn = box.querySelector('.resize-btn');
    if(deleteBtn) deleteBtn.style.display='none';
    if(resizeBtn) resizeBtn.style.display='none';

    const editorWrap = document.createElement('div');
    editorWrap.style.cssText='width:100%; display:flex; flex-direction:column; gap:6px;';
    const toolbar = document.createElement('div');
    toolbar.style.cssText='display:flex; gap:6px; justify-content:center;';
    const options=[{k:'left',t:'Links'},{k:'center',t:'Mitte'},{k:'right',t:'Rechts'},{k:'justify',t:'Blocksatz'}];
    function alignIcon(kind){
      // small 16x16 inline SVGs for text alignment
      const base = {
        left:  '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="3" width="12" height="2" rx="1" fill="#333"/><rect x="2" y="7" width="9" height="2" rx="1" fill="#333"/><rect x="2" y="11" width="12" height="2" rx="1" fill="#333"/></svg>',
        center:'<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="3" width="12" height="2" rx="1" fill="#333"/><rect x="3.5" y="7" width="9" height="2" rx="1" fill="#333"/><rect x="2" y="11" width="12" height="2" rx="1" fill="#333"/></svg>',
        right: '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="3" width="12" height="2" rx="1" fill="#333"/><rect x="5" y="7" width="9" height="2" rx="1" fill="#333"/><rect x="2" y="11" width="12" height="2" rx="1" fill="#333"/></svg>',
        justify:'<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="3" width="12" height="2" rx="1" fill="#333"/><rect x="2" y="7" width="12" height="2" rx="1" fill="#333"/><rect x="2" y="11" width="12" height="2" rx="1" fill="#333"/></svg>'
      };
      return base[kind] || '';
    }
    let align = (box.style.textAlign || window.getComputedStyle(box).textAlign || 'center');
    const ta = document.createElement('textarea');
        ta.className='app-box-editor';
        // ensure editor is comfortably visible (min 160px) and resizable
        const MIN_EDIT_H = 160;
        // make box overflow visible while editing so editor isn't clipped
        const prevOverflow = box.style.overflow;
        box.style.overflow = 'visible';
        // if box had fixed height, relax to allow growth during edit
        const prevHeight = box.style.height; const prevMinHeight = box.style.minHeight;
        box.style.height = ''; box.style.minHeight = Math.max(MIN_EDIT_H, box.clientHeight)+'px';
        ta.style.minHeight = MIN_EDIT_H+'px';
        ta.style.height = Math.max(MIN_EDIT_H,(box.clientHeight-12))+'px';
        ta.style.resize='vertical'; ta.value=currentText; ta.style.textAlign=align;
    options.forEach(o=>{ const b=document.createElement('button'); b.type='button'; b.innerHTML=alignIcon(o.k); b.title=o.t; b.className='btn small-btn'; b.style.padding='2px 8px'; if(align===o.k) b.style.outline='2px solid #2196F3';
      // prevent textarea blur on toolbar interaction
      b.addEventListener('mousedown', ev => { ev.preventDefault(); });
      b.addEventListener('click',()=>{ align=o.k; ta.style.textAlign=align; Array.from(toolbar.children).forEach(c=>c.style.outline=''); b.style.outline='2px solid #2196F3'; ta.focus(); });
      toolbar.appendChild(b);
    });
    editorWrap.appendChild(toolbar); editorWrap.appendChild(ta);
    if(firstNode && firstNode.nodeType===3) firstNode.replaceWith(editorWrap); else box.insertBefore(editorWrap, box.firstChild);
    ta.focus(); ta.select();
    const cleanup=()=>{ if(deleteBtn) deleteBtn.style.display=''; if(resizeBtn) resizeBtn.style.display=''; };
    const finish=(apply=true)=>{
      const txt = apply ? (ta.value||currentText) : currentText;
      const tn = document.createTextNode(txt);
      editorWrap.replaceWith(tn);
      box.style.textAlign = align;
      // Keep flex centering in sync so alignment is visible
      try{
        if (align === 'left') box.style.justifyContent = 'flex-start';
        else if (align === 'right') box.style.justifyContent = 'flex-end';
        else if (align === 'center') box.style.justifyContent = 'center';
        else if (align === 'justify') box.style.justifyContent = 'flex-start';
      }catch(_){ }
      try {
        // restore box overflow and minHeight sensibly
        box.style.overflow = prevOverflow || '';
        box.style.height = prevHeight || '';
        box.style.minHeight = prevMinHeight || '';
        applyBaseMinHeight(box); checkOverflowAndToggle(box);
      } catch(_){ }
      cleanup();
      ta.removeEventListener('keydown',onKey,true);
      ta.removeEventListener('blur',onBlur,true);
    };
    const onKey=(ev)=>{ if(ev.key==='Escape'){ ev.preventDefault(); finish(false);} if(ev.key==='Enter' && (ev.ctrlKey||ev.metaKey)){ ev.preventDefault(); finish(true);} };
    ta.addEventListener('keydown', onKey, true);
    ta.addEventListener('blur', function(){
      // defer to see where focus went; close only if focus leaves editorWrap
      setTimeout(function(){ if (!editorWrap.contains(document.activeElement)) finish(true); }, 0);
    }, true);
  }, true);
})();
</script>
<script>
// Enhance section color picker with pipette + custom color row
(function(){
  try{
    // Disable pipette/custom row as requested
    if (true) return;
    function enhance(picker){
      try{
        if (!picker || !picker.classList || !picker.classList.contains('section-color-picker')) return;
        if (picker.querySelector('.section-custom-color')) return; // already enhanced
        const sectionTitle = picker.closest('.section-title');
        const row = document.createElement('div');
        row.className = 'row';
        row.style.cssText = 'width:100%; display:flex; gap:8px; align-items:center; margin-top:8px;';
        var cid = 'sec-col-' + Date.now().toString(36) + Math.random().toString(36).slice(2);
        row.innerHTML = '<button class="btn small-btn pipette-btn" type="button" data-action="pipette" title="Pipette" onclick="pickEyeDropper(\''+cid+'\')">ð§ª</button>'
                       + '<input type="color" id="'+cid+'" class="section-custom-color" value="#8B4513" style="flex:0 0 40px; border:none; padding:0;" />'
                       + '<button class="btn small-btn" type="button" data-action="apply">Ãbernehmen</button>';
        picker.appendChild(row);
        ['mousedown','pointerdown','click'].forEach(evt => row.addEventListener(evt, e => e.stopPropagation(), true));
        const applyBtn = row.querySelector('button[data-action="apply"]');
        if (applyBtn && sectionTitle){
          applyBtn.addEventListener('click', function(ev){
            ev.preventDefault(); ev.stopPropagation();
            const inp = picker.querySelector('.section-custom-color');
            if (inp && typeof applySectionColor === 'function') applySectionColor(sectionTitle, inp.value);
            picker.remove();
          }, true);
        }
        // No extra JS for pipette; inline onclick uses existing pickEyeDropper
      }catch(_){ }
    }
    const obs = new MutationObserver(function(muts){
      for (let m of muts){
        for (let n of m.addedNodes||[]){
          if (n.nodeType===1){
            if (n.classList && n.classList.contains('section-color-picker')) enhance(n);
            else if (n.querySelectorAll) n.querySelectorAll('.section-color-picker').forEach(enhance);
          }
        }
      }
    });
    obs.observe(document.body, {childList:true, subtree:true});
  }catch(_){ }
})();
</script>


